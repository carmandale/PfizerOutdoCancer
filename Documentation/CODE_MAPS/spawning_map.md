<file_map>
/Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer
├── ADC
│   ├── ECS
│   │   ├── ADCBillboardSystem.swift
│   │   ├── ADCCameraSystem.swift
│   │   ├── ADCGestureComponent.swift
│   │   ├── ADCProximitySystem.swift
│   │   └── ADCSimpleBillboardSystem.swift
│   ├── Extensions
│   │   ├── Gestures
│   │   │   ├── ADCEntityExtensions.swift
│   │   │   ├── ADCGestureExtensions.swift
│   │   │   └── ADCRealityViewExtensions.swift
│   │   ├── ADCColor+Extensions.swift
│   │   ├── ADCEntity+Extensions.swift
│   │   ├── ADCMaterialUtility.swift
│   │   ├── ADCMath+Extensions.swift
│   │   ├── ADCModelEntity+Extensions.swift
│   │   └── ADCView+Extensions.swift
│   ├── Models
│   │   └── ADCDataModel.swift
│   └── Views
│       └── ADCBuilder
│           ├── ADCOptimizedImmersive
│           │   ├── ADCOptimizedImmersive.swift
│           │   ├── ADCOptimizedImmersive+Attachments.swift
│           │   ├── ADCOptimizedImmersive+Audio.swift
│           │   ├── ADCOptimizedImmersive+Entities.swift
│           │   └── ADCOptimizedImmersive+Gestures.swift
│           ├── ADCBuilderView.swift
│           ├── ADCButtonSquareWithOutline.swift
│           ├── ADCCheckmarkButton.swift
│           ├── ADCLinkerSelectorView.swift
│           ├── ADCPayloadSelectorView.swift
│           ├── ADCSelectorView.swift
│           └── ADCView.swift
├── AppModel
│   ├── AppModel.swift
│   └── AppModel+AssetLoading.swift
├── AssetManagement
│   ├── AssetLoadingManager.swift
│   └── AssetLoadingManager+Lab.swift
├── Assets.xcassets
│   ├── AccentColor.colorset
│   │   └── Contents.json
│   ├── ADCBuilder
│   │   ├── antibody0.imageset
│   │   │   ├── antibody0.png
│   │   │   └── Contents.json
│   │   ├── antibody1.imageset
│   │   │   ├── antibody1.png
│   │   │   └── Contents.json
│   │   ├── antibody2.imageset
│   │   │   ├── antibody2.png
│   │   │   └── Contents.json
│   │   ├── antibody3.imageset
│   │   │   ├── antibody3.png
│   │   │   └── Contents.json
│   │   ├── linkers0.imageset
│   │   │   ├── Contents.json
│   │   │   └── linkers0.png
│   │   ├── linkers1.imageset
│   │   │   ├── Contents.json
│   │   │   └── linkers1.png
│   │   ├── linkers2.imageset
│   │   │   ├── Contents.json
│   │   │   └── linkers2.png
│   │   ├── linkers3.imageset
│   │   │   ├── Contents.json
│   │   │   └── linkers3.png
│   │   ├── payload0.imageset
│   │   │   ├── Contents.json
│   │   │   └── payload0.png
│   │   ├── payload1.imageset
│   │   │   ├── Contents.json
│   │   │   └── payload1.png
│   │   ├── payload2.imageset
│   │   │   ├── Contents.json
│   │   │   └── payload2.png
│   │   ├── payload3.imageset
│   │   │   ├── Contents.json
│   │   │   └── payload3.png
│   │   ├── questionMark.imageset
│   │   │   ├── Contents.json
│   │   │   └── questionMark.png
│   │   └── Contents.json
│   ├── AppIcon.solidimagestack
│   │   ├── Back.solidimagestacklayer
│   │   │   ├── Content.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── PfizerIconBackground.jpg
│   │   │   └── Contents.json
│   │   ├── Front.solidimagestacklayer
│   │   │   ├── Content.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── PfizerIconFront.png
│   │   │   └── Contents.json
│   │   ├── Middle.solidimagestacklayer
│   │   │   ├── Content.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── PfizerIconMiddle.png
│   │   │   └── Contents.json
│   │   └── Contents.json
│   ├── DarkRed050.colorset
│   │   └── Contents.json
│   ├── DarkRed200.colorset
│   │   └── Contents.json
│   ├── DarkRed400.colorset
│   │   └── Contents.json
│   ├── DarkRed600.colorset
│   │   └── Contents.json
│   ├── DarkRed800.colorset
│   │   └── Contents.json
│   ├── gradient050.colorset
│   │   └── Contents.json
│   ├── gradient200.colorset
│   │   └── Contents.json
│   ├── gradient400.colorset
│   │   └── Contents.json
│   ├── gradient600.colorset
│   │   └── Contents.json
│   ├── gradient800.colorset
│   │   └── Contents.json
│   ├── LightBlue050.colorset
│   │   └── Contents.json
│   ├── LightBlue200.colorset
│   │   └── Contents.json
│   ├── LightBlue400.colorset
│   │   └── Contents.json
│   ├── LightBlue600.colorset
│   │   └── Contents.json
│   ├── LightBlue800.colorset
│   │   └── Contents.json
│   ├── LightGreen050.colorset
│   │   └── Contents.json
│   ├── LightGreen200.colorset
│   │   └── Contents.json
│   ├── LightGreen400.colorset
│   │   └── Contents.json
│   ├── LightGreen600.colorset
│   │   └── Contents.json
│   ├── LightGreen800.colorset
│   │   └── Contents.json
│   ├── LightMustard050.colorset
│   │   └── Contents.json
│   ├── LightMustard200.colorset
│   │   └── Contents.json
│   ├── LightMustard400.colorset
│   │   └── Contents.json
│   ├── LightMustard600.colorset
│   │   └── Contents.json
│   ├── LightMustard800.colorset
│   │   └── Contents.json
│   ├── LightRed050.colorset
│   │   └── Contents.json
│   ├── LightRed200.colorset
│   │   └── Contents.json
│   ├── LightRed400.colorset
│   │   └── Contents.json
│   ├── LightRed600.colorset
│   │   └── Contents.json
│   ├── LightRed800.colorset
│   │   └── Contents.json
│   ├── Pfizer_Logo_Color_RGB.imageset
│   │   ├── Contents.json
│   │   └── Pfizer_Logo_Color_RGB.png
│   ├── Pfizer_Logo_White_RGB.imageset
│   │   ├── Contents.json
│   │   └── Pfizer_Logo_White_RGB.png
│   ├── screen.imageset
│   │   ├── Contents.json
│   │   └── screen.jpg
│   ├── tap.imageset
│   │   ├── Contents.json
│   │   └── tap.jpg
│   └── Contents.json
├── Extensions
│   ├── Entity+Animation.swift
│   ├── Entity+Audio.swift
│   ├── Entity+AudioSystem.swift
│   ├── Entity+Find.swift
│   ├── Entity+Opacity.swift
│   ├── Entity+Trace.swift
│   ├── EnvironmentResource.swift
│   ├── Transitions.swift
│   ├── View+SelectorAnimation.swift
│   ├── View+WordAnimation.swift
│   └── WordByWordTransition.swift
├── FollowSystemAndComponent
│   ├── FollowComponent.swift
│   ├── FollowSystem.swift
│   ├── HeadPositionTracker.swift
│   ├── PositioningComponent.swift
│   └── PositioningSystem.swift
├── Managers
│   ├── HandTrackingManager.swift
│   └── TrackingSessionManager.swift
├── Preview Content
│   └── Preview Assets.xcassets
│       └── Contents.json
├── Resources
│   ├── lab_v005.exr
│   └── metro_noord_2k.exr
├── Systems
│   ├── ADCMovementSystem.swift
│   ├── ADCMovementSystem+Math.swift
│   ├── ADCMovementSystem+Retargeting.swift
│   ├── ADCMovementSystem+Utils.swift
│   ├── ADCSystem.swift
│   ├── AntigenSystem.swift
│   ├── AttachmentSystem.swift
│   ├── BreathingSystem.swift
│   ├── CancerCellMovementData.swift
│   ├── CancerCellSpeedBoostSystem.swift
│   ├── MovementSystem.swift
│   ├── RotationAxis.swift
│   ├── RotationSystem.swift
│   ├── SwirlingSystem.swift
│   ├── TraceComponent.swift
│   ├── UIAttachmentSystem.swift
│   ├── UIStabilizerSystem.swift
│   └── UIStateSyncSystem.swift
├── Utility
│   ├── ClosureComponent.swift
│   ├── CollisionGroups.swift
│   ├── Floats.swift
│   ├── Gravity.swift
│   ├── HeadTracker.swift
│   ├── IBLUtility.swift
│   ├── Logger.swift
│   ├── PortalManager.swift
│   ├── RotationHelpers.swift
│   └── UnorderedPair.swift
├── ViewModels
│   ├── AttackCancerViewModel
│   │   ├── AttackCancerViewModel.swift
│   │   ├── AttackCancerViewModel+ADC.swift
│   │   ├── AttackCancerViewModel+Audio.swift
│   │   ├── AttackCancerViewModel+Collisions.swift
│   │   ├── AttackCancerViewModel+GameStats.swift
│   │   ├── AttackCancerViewModel+HandInteraction.swift
│   │   ├── AttackCancerViewModel+Notifications.swift
│   │   ├── AttackCancerViewModel+Pool.swift
│   │   ├── AttackCancerViewModel+SceneSetup.swift
│   │   ├── AttackCancerViewModel+Spawning.swift
│   │   └── AttackCancerViewModel+UI.swift
│   ├── IntroViewModel
│   │   └── IntroViewModel.swift
│   ├── LabViewModel
│   │   └── LabViewModel.swift
│   └── OutroViewModel
│       └── OutroViewModel.swift
├── Views
│   ├── Effects
│   │   └── ButtonHoverEffects.swift
│   ├── ADCBuilderViewerButton.swift
│   ├── AttackCancerInstructionsView.swift
│   ├── AttackCancerView.swift
│   ├── AttackCancerViewerButton.swift
│   ├── CompletedView.swift
│   ├── ContentView.swift
│   ├── ErrorView.swift
│   ├── GradientNavigationButtonStyle.swift
│   ├── HitCounterView.swift
│   ├── HopeMeterUtilityView.swift
│   ├── HopeMeterView.swift
│   ├── IntroView.swift
│   ├── IntroWindowView.swift
│   ├── LabView.swift
│   ├── LabViewerButton.swift
│   ├── LibraryView.swift
│   ├── LibraryWindow.swift
│   ├── LoadingView.swift
│   ├── NavigationButton.swift
│   ├── NavigationView.swift
│   ├── NavToggleView.swift
│   ├── OutdoCancer.swift
│   ├── OutroView.swift
│   ├── Screen.swift
│   ├── StartButton.swift
│   └── StartView.swift
├── Info.plist
└── PfizerOutdoCancerApp.swift



<Complete Definitions>
Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/ECS/ADCBillboardSystem.swift

---
Classes:
  Class: ADCBillboardComponent
    Properties:
      - var offset: SIMD3<Float> = .zero
      - var axisToFollow: SIMD3<Int> = .zero
      - var initializePositionOnlyOnce: Bool = false
      - var isBillboardEnabled: Bool = false
      - var isPositionInitialized: Bool = false
  Class: ADCBillboardSystem
    Properties:
      - static var dependencies: [SystemDependency] = [.before(ADCCameraSystem.self)]
    Methods:
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/ECS/ADCCameraSystem.swift

---
Classes:
  Class: ADCCameraComponent
  Class: ADCCameraSystem
    Properties:
      - static let query = EntityQuery(where: .has(ADCCameraComponent.self))
      - private let arkitSession = ARKitSession()
      - private let worldTrackingProvider = WorldTrackingProvider()
    Methods:
      - func setUpSession() {
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/ECS/ADCGestureComponent.swift

---
Classes:
  Class: ADCEntityGestureState
    Properties:
      - var targetedEntity: Entity?
      - var dragStartPosition: SIMD3<Float> = .zero
      - var isDragging = false
      - var pivotEntity: Entity?
      - var initialOrientation: simd_quatf?
      - var startScale: SIMD3<Float> = .one
      - var isScaling = false
      - var startOrientation = Rotation3D.identity
      - var isRotating = false
      - @MainActor static let shared = ADCEntityGestureState()
  Class: ADCGestureComponent
    Properties:
      - public var canDrag: Bool = true
      - public var pivotOnDrag: Bool = true
      - public var preserveOrientationOnPivotDrag: Bool = true
      - public var canScale: Bool = true
      - public var canRotate: Bool = true
      - public var onDragStarted: ((Entity?) -> Void)? = nil
      - public var onDragEnded: ((Entity?) -> Void)? = nil
      - public var onRotateStarted: ((Entity?) -> Void)? = nil
      - public var onRotateEnded: ((Entity?) -> Void)? = nil
    Methods:
      - mutating func onChanged(value: EntityTargetValue<DragGesture.Value>) {
      - mutating private func handlePivotDrag(value: EntityTargetValue<DragGesture.Value>) {
      - mutating private func handleFixedDrag(value: EntityTargetValue<DragGesture.Value>) {
      - mutating func onEnded(value: EntityTargetValue<DragGesture.Value>) {
      - mutating func onChanged(value: EntityTargetValue<MagnifyGesture.Value>) {
      - mutating func onEnded(value: EntityTargetValue<MagnifyGesture.Value>) {
      - mutating func onChanged(value: EntityTargetValue<RotateGesture3D.Value>) {
      - mutating func onEnded(value: EntityTargetValue<RotateGesture3D.Value>) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/ECS/ADCProximitySystem.swift

---
Classes:
  Class: ADCProximityComponent
    Properties:
      - let minScale: Float
      - let maxScale: Float
      - let minProximity: Float
      - let maxProximity: Float
  Class: ADCProximitySourceComponent
  Class: ADCProximitySystem
    Properties:
      - static let proxymityQuery = EntityQuery(where: .has(ADCProximityComponent.self))
      - static let proxymitySourceQuery = EntityQuery(where: .has(ADCProximitySourceComponent.self))
    Methods:
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/ECS/ADCSimpleBillboardSystem.swift

---
Classes:
  Class: ADCSimpleBillboardComponent
  Class: ADCSimpleBillboardSystem
    Properties:
      - static var dependencies: [SystemDependency] = [.before(ADCCameraSystem.self)]
    Methods:
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Extensions/Gestures/ADCEntityExtensions.swift

---
Classes:
  Class: ADCEntityExtensions
    Properties:
      - var adcGestureComponent: ADCGestureComponent? {
      - var scenePosition: SIMD3<Float> {
      - var sceneOrientation: simd_quatf {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Extensions/Gestures/ADCGestureExtensions.swift

---
Classes:
  Class: ADCGestureExtensions
    Methods:
      - func useADCGestureComponent() -> some Gesture {
      - func useADCGestureComponent() -> some Gesture {
      - func useADCGestureComponent() -> some Gesture {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Extensions/Gestures/ADCRealityViewExtensions.swift

---
Classes:
  Class: ADCRealityViewExtensions
    Properties:
      - var dragGesture: some Gesture {
      - var magnifyGesture: some Gesture {
      - var rotateGesture: some Gesture {
    Methods:
      - func installGestures() -> some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Extensions/ADCColor+Extensions.swift

---
Classes:
  Class: ADCColor+Extensions
    Properties:
      - static var adcDarkBlue: Color {
      - static var adcLightBlue: Color {
      - static var adcYellow: Color {
      - static var adcWhite: Color {
      - static var adcDarkBlueEmissive: Color {
      - static var adcLightBlueEmissive: Color {
      - static var adcYellowEmissive: Color {
      - static var adcWhiteEmissive: Color {
      - static var adc: [Color] {
      - static var adcEmissive: [Color] {
      - var toUIColor: UIColor {
      - static var adcDarkBlue: UIColor {
      - static var adcLightBlue: UIColor {
      - static var adcYellow: UIColor {
      - static var adcWhite: UIColor {
      - static var adcDarkBlueEmissive: UIColor {
      - static var adcLightBlueEmissive: UIColor {
      - static var adcYellowEmissive: UIColor {
      - static var adcWhiteEmissive: UIColor {
      - static var adc: [UIColor] {
      - static var adcEmissive: [UIColor] {
      - var hex: Int {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Extensions/ADCEntity+Extensions.swift

---
Classes:
  Class: ADCEntity+Extensions
    Methods:
      - public func updateMaterial(name: String?, _ update: (inout Material) -> Void) {
      - public func updateMaterials(_ update: (inout Material) -> Void) {
      - func findModelEntity(named name: String, in entity: Entity? = nil) -> ModelEntity? {
      - func findModelEntity(named name: String, from ancestor: String, in entity: Entity? = nil, foundAncestor: Bool = false) -> ModelEntity? {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Extensions/ADCMaterialUtility.swift

---
Classes:
  Class: ADCMaterialUtility
    Methods:
      - func applyADCColor(_ colorIndex: Int) {
      - func applyPayloadColor(_ colorIndex: Int, isInner: Bool) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Extensions/ADCMath+Extensions.swift

---
Classes:
  Class: ADCMath+Extensions
    Properties:
      - var printed: String {
      - var adcNormalized: SIMD3 {
      - static let x: Self = .init(1, 0, 0)
      - static let up: Self = .init(0, 1, 0)
      - static let z: Self = .init(0, 0, 1)
    Methods:
      - func distance(from other: SIMD3<Float>) -> Float {
      - static func magnitude(pointA: SIMD3<Float>, pointB: SIMD3<Float>) -> Float {
      - func normalize(to other: SIMD3<Float>) -> SIMD3<Float> {
      - func findCollinearPoint(to other: SIMD3<Float>, distance: Float) -> SIMD3<Float> {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Extensions/ADCModelEntity+Extensions.swift

---
Classes:
  Class: ADCModelEntity+Extensions
    Methods:
      - func updatePBRDiffuseColor(_ color: UIColor) {
      - func updatePBREmissiveColor(_ color: UIColor) {
      - func updateShaderGraphColor(parameterName: String, color: UIColor) {
      - func updateShaderGraphValue(parameterName: String, value: Float) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Extensions/ADCView+Extensions.swift

---
Classes:
  Class: SizePreferenceKey
    Properties:
      - static var defaultValue: CGSize = .zero
    Methods:
      - static func reduce(value: inout CGSize, nextValue: () -> CGSize) {
      - func getSizeOfView(_ getSize: @escaping ((CGSize) -> Void)) -> some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Models/ADCDataModel.swift

---
Classes:
  Class: ADCDataModel
    Properties:
      - var isRootSetupComplete = false
      - var isEnvironmentSetupComplete = false
      - var isHeadTrackingRootReady = false
      - var shouldUpdateHeadPosition = false
      - var isPositioningComplete = false
      - var isReadyForInteraction: Bool {
  Class: StepState
    Properties:
      - var colorSelected: Bool = false
      - var checkmarkClicked: Bool = false
      - var voPlayed: Bool = false
      - var stepStates: [StepState] = [
 StepState(), // Antibody StepState(), // Linker StepState(), // Payload
      - var selectedADCAntibody: Int? = nil
      - public var selectedADCLinker: Int? = nil
      - public var selectedADCPayload: Int? = nil
      - var selectedLinkerType: Int? = nil
      - var selectedPayloadType: Int? = nil
      - public var linkersWorkingIndex: Int = 0
      - public var payloadsWorkingIndex: Int = 0
      - public var adcBuildStep = 0
      - var placedLinkerCount: Int = 0
      - var placedPayloadCount: Int = 0
      - public var isVOPlaying = false
      - public var hasInitialVOCompleted = false
      - public var antibodyVOCompleted = false
      - public var antibodyStepCompleted = false
      - public var showSelector = false
      - public var manualStepTransition: Bool = false
      - public var voiceOverProgress: Double = 0.0
      - let voiceOverDurations: [Int: TimeInterval] = [
 0: 18.0,  // VO1 1: 22.0,  // VO2 2: 28.0,  // VO3 3: 16.0   // VO4
      - var canMoveForward: Bool {
      - var canMoveBack: Bool {
      - var isCurrentStepComplete: Bool {
    Methods:
      - func markVOCompleted(for step: Int) {
      - func shouldPlayVO(for step: Int) -> Bool {
      - func fillAllLinkers() {
      - func fillAllPayloads() {
      - func getADCImageName() -> String {
      - func getLinkerImageName() -> String {
      - func getPayloadImageName() -> String {
      - func cleanup() {
      - func setupRoot() -> Entity {
  Class: ADCUIAttachments

Enums:
  - ADCUIAttachments
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive.swift

---
Classes:
  Class: ADCEntityType
  Class: ADCOptimizedImmersive
    Properties:
      - @Environment(AppModel.self) var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - @State internal var bubblePopSound = false
      - @State var mainEntity: Entity?
      - @State var mainViewEntity = Entity()
      - @State var antibodyRootEntity: Entity?
      - @State var antibodyEntity: ModelEntity?
      - @State var popAudioEntity: Entity?  // Audio source entity for pop sound
      - @State var voiceOverAudioEntity: Entity?  // Audio source entity for voice-overs
      - @State var linkerEntity: Entity?
      - @State var payloadEntity: Entity?
      - @State var workingLinker: ModelEntity?
      - @State var workingPayloadInner: ModelEntity?
      - @State var workingPayloadOuter: ModelEntity?
      - @State var adcSortGroup: ModelSortGroup?
      - @State var adcLinkers: [ModelEntity] = .init()
      - @State var adcPayloadsInner: [ModelEntity] = .init()
      - @State var adcPayloadsOuter: [ModelEntity] = .init()
      - @State var adcAttachmentEntity: ViewAttachmentEntity?
      - @State var linkerAttachmentEntity: ViewAttachmentEntity?
      - @State var payloadAttachmentEntity: ViewAttachmentEntity?
      - @State var shouldAddADCAttachment: Bool = false
      - @State var shouldAddLinkerAttachment: Bool = false
      - @State var shouldAddPayloadAttachment: Bool = false
      - @State var shouldAddMainViewAttachment: Bool = false
      - @State var refreshFlag = false
      - @State var popAudioFileResource: AudioFileResource?
      - @State var audioEntity: Entity = Entity()
      - @State var currentVOController: AudioPlaybackController?
      - @State var popAudioPlaybackController: AudioPlaybackController?
      - @State var vo1Audio: AudioFileResource?
      - @State var vo2Audio: AudioFileResource?
      - @State var vo3Audio: AudioFileResource?
      - @State var vo4Audio: AudioFileResource?
      - @State var completionAudio: AudioFileResource?
      - @State var niceJobAudio: AudioFileResource?
      - @State var timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
      - @State var isCameraInitialized = false
      - @State var useChannelAudioForVO: Bool = true
      - let linkerAttachmentOffset: SIMD3<Float> = SIMD3(0.25, 0, 0)
      - let payloadAttachmentOffset: SIMD3<Float> = SIMD3(0.35, 0, 0)
      - let defaultZPosition: Float = -1.0
      - let antibodyRootOffset: SIMD3<Float> = SIMD3(0, 0, 0)
      - @Environment(\.dismissWindow) private var dismissWindow
      - @Environment(\.openWindow) private var openWindow
      - @State var originalLinkerMaterial: ShaderGraphMaterial?
      - @State var originalPayloadInnerMaterial: PhysicallyBasedMaterial?
      - @State var originalPayloadOuterMaterial: ShaderGraphMaterial?
      - @State var initialLinkerPosition: SIMD3<Float>?
      - @State var initialPayloadPosition: SIMD3<Float>?
      - @State var outlineMaterial: ShaderGraphMaterial?
      - @State var originalAntibodyMaterial: ShaderGraphMaterial?
      - @State var targetLinkerEntity: Entity?
      - @State var targetPayloadEntity: Entity?
      - var body: some View {
    Methods:
      - private func checkAndAdvanceStep() async {
      - private func handleAntibodyColorChange(newValue: Int?) {
      - private func updateAttachmentEntities() {
      - private func setupEntitiesAndMaterials(in root: Entity) async {

Enums:
  - ADCEntityType
    Cases:
      - linker
      - payload
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Attachments.swift

---
Classes:
  Class: ADCOptimizedImmersive+Attachments
    Methods:
      - func calculateTargetLinkerPosition() -> SIMD3<Float> {
      - func calculateTargetPayloadsPosition() -> SIMD3<Float> {
      - func setAntibodyAttachmentPosition() {
      - func setLinkerAttachmentPosition() {
      - func updateADC() {
      - func setupAttachments(attachments: RealityViewAttachments) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Audio.swift

---

---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Entities.swift

---
Classes:
  Class: ADCOptimizedImmersive+Entities
    Methods:
      - func prepareAntibodyEntities() {
      - func prepareLinkerEntities() async {
      - func preparePayloadEntities() async {
      - func prepareTargetEntities(antibodyScene: Entity) {
      - func cleanup() {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Gestures.swift

---
Classes:
  Class: ADCOptimizedImmersive+Gestures
    Methods:
      - func createGestureComponent() -> ADCGestureComponent {
      - func createLinkerGestureComponent(linkerEntity: Entity, linkerTarget: Entity) -> ADCGestureComponent {
      - func handleFinalEntityPlacement(entityType: ADCEntityType,
                                  workingEntity: Entity?,
                                  savedPosition: SIMD3<Float>?,
                                  nextStep: Int) async {
      - func createPayloadGestureComponent(payloadEntity: Entity, payloadTarget: Entity) -> ADCGestureComponent {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCBuilderView.swift

---
Classes:
  Class: ADCBuilderView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - @Environment(\.openWindow) private var openWindow
      - @Environment(\.dismissWindow) private var dismissWindow
      - @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
      - @FocusState private var isFocused: Bool
      - let titles = ["Antibodies", "Linker", "Payload", "ADC Ready"]
      - let descriptions = [
 "First, the journey begins with creating monoclonal antibodies in cell cultures. These antibodies are like precision-guided missiles designed to seek out and bind to cancer cells. They are the key to ensuring that the treatment targets only the cancer cells, leaving healthy cells unharmed.", "Next, a special chemical linker is attached to the antibodies. This linker acts as a smart bridge, ensuring that the powerful cancer-fighting drug is only released when the antibody reaches the cancer cell. This step is crucial for delivering the treatment directly to the cancer cells, minimizing side effects.", "Finally, the cytotoxic drug, which is designed to kill cancer cells, is chemically linked to the antibodies through a process called conjugation. This creates the antibody-drug conjugate (ADC). The ADC is then purified and rigorously tested to ensure it is effective and safe. Once it passes all tests, it is formulated, sterilized, and packaged into vials or syringes.", "When administered to patients, the ADC travels through the bloodstream, finds the cancer cells, and releases the drug to destroy them. This targeted approach helps to outdo cancer by attacking it directly while sparing healthy cells."
      - var body: some View {
  Class: GlowingModifier
    Properties:
      - var isGlowing: Bool
      - var color: Color = .blue
      - var baseBlur: CGFloat = 20
      - var blurVariation: CGFloat = 10
      - var glowBlur: CGFloat = 20
      - var glowScale: CGFloat = 1.2
      - var baseOpacity: Double = 0.0
      - var opacityVariation: Double = 1.0
      - var glowIntensity: Double = 1.0
      - @State private var pulsate = false
    Methods:
      - func body(content: Content) -> some View {
      - func glowing(if condition: Bool, color: Color = .blue, glowBlur: CGFloat = 20, glowScale: CGFloat = 1.2, glowIntensity: Double = 1.0) -> some View {
      - func glowing(if condition: Bool, color: Color = .blue) -> some View {
  Class: VOProgressBar
    Properties:
      - let progress: Double
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCButtonSquareWithOutline.swift

---
Classes:
  Class: ADCButtonSquareWithOutline
    Properties:
      - @Environment(AppModel.self) var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - let imageName: String
      - let outlineColor: Color
      - let description: String
      - let index: Int
      - let isSelected: () -> Bool
      - let action: () -> Void
      - let buttonSize: CGFloat = 110.0
      - let cornerRadius: CGFloat = 12.0
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCCheckmarkButton.swift

---
Classes:
  Class: ADCCheckmarkButton
    Properties:
      - let action: () -> Void
      - let isEnabled: Bool
      - @State private var pulseScale: CGFloat = 1.0
      - var body: some View {
    Methods:
      - private func startPulsing() {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCLinkerSelectorView.swift

---
Classes:
  Class: ADCLinkerSelectorView
    Properties:
      - @Environment(AppModel.self) var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - var noButton: Bool = true
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCPayloadSelectorView.swift

---
Classes:
  Class: ADCPayloadSelectorView
    Properties:
      - @Environment(AppModel.self) var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - var noButton: Bool = true
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCSelectorView.swift

---
Classes:
  Class: ADCSelectorView
    Properties:
      - @Environment(AppModel.self) var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - var noButton: Bool = false
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ADC/Views/ADCBuilder/ADCView.swift

---
Classes:
  Class: ADCView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
      - @Environment(\.openImmersiveSpace) private var openImmersiveSpace
      - @Environment(\.openWindow) private var openWindow
      - @Environment(\.dismissWindow) private var dismissWindow
      - var body: some View {
      - static var moveAndFade: AnyTransition {
    Methods:
      - private func instructionSection(title: String, description: String, systemImage: String) -> some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/AssetManagement/AssetLoadingManager.swift

---
Classes:
  Class: LoadResult
  Class: FailedAsset
    Properties:
      - let key: String
      - let category: AssetCategory
      - let error: Error
  Class: AssetCategory
  Class: LoadingState
    Methods:
      - static func ==(lhs: LoadingState, rhs: LoadingState) -> Bool {
  Class: AssetError
  Class: AssetLoadingManager
    Properties:
      - static let shared = AssetLoadingManager()
      - internal var entityTemplates: [String: Entity] = [:]
      - private var audioControllers: [Entity.ID: AudioPlaybackController] = [:]
      - private var failedAssets: [FailedAsset] = []
      - var loadingFailures: [FailedAsset] {
      - internal let labObjectsPath = "Assets/Lab/Objects"
      - var loadingState: LoadingState = .notStarted
      - var state: LoadingState {
      - private let assetNameMappings: [String: String] = [
 "intro_environment": "IntroEnvironment", "intro_warp": "IntroWarp", "title_card": "outdoCancer", "lab_environment": "LabEnvironment", "lab_vo": "LabVO", "lab_audio": "LabAudio", "antibody_scene": "antibodyScene", "attack_cancer_environment": "AttackCancerEnvironment", "adc": "ADC-spawn",  // ADC asset name "cancer_cell": "CancerCell-spawn",  // Cancer cell asset name "game_start_vo": "AttackCancerGameStart_VO",  // Tutorial/game start VO "test_fire_cell": "TestFireCell",  // Test fire cell asset name "outro_environment": "OutroEnvironment"  // Outro environment asset // add further mappings as needed
    Methods:
      - func releaseIntroEnvironment() async {
      - func releaseEntity(_ entity: Entity) {
      - func releaseLabEnvironment() async {
      - func releaseOutroEnvironment() async {
      - func releaseAttackCancerEnvironment() async {
      - func loadingProgress() -> Float {
      - func instantiateEntity(_ key: String) async -> Entity? {
      - internal func processLoadedAsset(_ result: LoadResult) {
      - func cleanupForPlayingPhase() async {
      - func handleMemoryWarning() {
      - internal func validateTemplate(_ entity: Entity, category: AssetCategory) async {
      - public func inspectEntityHierarchy(_ entity: Entity, level: Int = 0, showComponents: Bool = true) {
      - func loadEntity(named name: String) async throws -> Entity {
      - private func actualAssetName(for key: String, category: AssetCategory) -> String {
      - func loadAsset(withName name: String, category: AssetCategory) async throws -> Entity {
      - func instantiateAsset(withName name: String, category: AssetCategory) async throws -> Entity {
      - func trackAudioController(_ controller: AudioPlaybackController, for entity: Entity) {

Enums:
  - LoadResult
    Cases:
      - success
      - failure
  - AssetCategory
    Cases:
      - introEnvironment
      - outroEnvironment
      - labEnvironment
      - labEquipment
      - buildADCEnvironment
      - attackCancerEnvironment
      - cancerCell
      - adc
  - LoadingState
    Cases:
      - notStarted
      - loading
      - completed
      - error
  - AssetError
    Cases:
      - resourceNotFound
      - criticalAssetsMissing
      - materialNotFound
      - protobufError
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/AssetManagement/AssetLoadingManager+Lab.swift

---
Classes:
  Class: AssetLoadingManager+Lab
    Methods:
      - internal func loadLabEquipmentAssets(group: inout ThrowingTaskGroup<LoadResult, Error>, taskCount: inout Int) {
      - func loadPopulatedLabScene() async throws -> Entity {
      - private func loadLabAsset(named assetName: String) async throws -> Entity {
      - private func findEmptyTransforms(in scene: Entity) -> ([Entity], Int) {
      - func traverse(entity: Entity) {
      - private func extractAssetName(from name: String) -> String? {
      - private func configureLabInstance(_ instance: Entity, for empty: Entity) {
      - func loadAssembledLab() async throws -> Entity {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/Entity+Animation.swift

---
Classes:
  Class: Entity+Animation
    Methods:
      - func cancelPendingAnimations() {
      - func animateXScale(from start: Float? = nil,
                      to end: Float,
                      duration: TimeInterval,
                      delay: TimeInterval = 0,
                      timing: RealityKit.AnimationTimingFunction = .easeInOut,
                      waitForCompletion: Bool = false) async {
      - func animateScale(from start: Float? = nil,
                     to end: Float,
                     duration: TimeInterval,
                     delay: TimeInterval = 0,
                     timing: RealityKit.AnimationTimingFunction = .cubicBezier(controlPoint1: SIMD2<Float>(1.0, 0), controlPoint2: SIMD2<Float>(0.6, 1)),
                     waitForCompletion: Bool = false) async {
      - func animateZPosition(to relativeZ: Float,
                         duration: TimeInterval,
                         delay: TimeInterval = 0,
                         timing: RealityKit.AnimationTimingFunction = .easeInOut,
                         waitForCompletion: Bool = false) async {
      - func animatePosition(to targetPosition: SIMD3<Float>,
                        duration: TimeInterval,
                        delay: TimeInterval = 0,
                        timing: RealityKit.AnimationTimingFunction = .easeInOut,
                        waitForCompletion: Bool = false) async {
      - func animateYRotation(to targetDegrees: Float,
                         duration: TimeInterval,
                         delay: TimeInterval = 0,
                         timing: RealityKit.AnimationTimingFunction = .easeInOut,
                         waitForCompletion: Bool = false) async {
      - func hitScaleAnimation(intensity: Float = 0.9,
                         duration: TimeInterval = 0.3,
                         scaleReduction: Float = 0.1,
                         waitForCompletion: Bool = false) async {
      - func animatePositionAndRotation(position: SIMD3<Float>,
                                  rotation: Float,
                                  duration: TimeInterval,
                                  delay: TimeInterval = 0,
                                  timing: RealityKit.AnimationTimingFunction = .easeInOut,
                                  waitForCompletion: Bool = false) async {
      - func startContinuousRotation(speed: Float = 1.0, axis: RotationAxis = .yAxis) {
      - func startContinuousYRotation(speed: Float = 1.0) {
      - func stopRotation() {
      - func animateAbsolutePositionAndScale(to targetPosition: SIMD3<Float> = SIMD3<Float>(0, 0, 0),
                                           scale targetScale: SIMD3<Float> = SIMD3<Float>(1, 1, 1),
                                           duration: TimeInterval,
                                           delay: TimeInterval = 0,
                                           timing: RealityKit.AnimationTimingFunction = .easeInOut,
                                           waitForCompletion: Bool = false) async {
      - func animateAbsolutePosition(to targetPosition: SIMD3<Float>,
                                duration: TimeInterval,
                                delay: TimeInterval = 0,
                                timing: RealityKit.AnimationTimingFunction = .easeInOut,
                                waitForCompletion: Bool = false) async {
      - func checkHeadPosition(animated: Bool = false, duration: TimeInterval = 0.5) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/Entity+Audio.swift

---
Classes:
  Class: Entity+Audio
    Methods:
      - func enableLargeRoomReverb() {
      - func disableReverb() {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/Entity+AudioSystem.swift

---
Classes:
  Class: EntityAudioSystem
    Properties:
      - let entity: Entity
      - var spatialAudioEnabled: Bool
      - var gain: Float
      - var focus: Float
      - var positionOffset: SIMD3<Float> = .zero
      - var rotationOffset: simd_quatf = simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0))  // Identity rotation
      - private var audioAnchor: Entity
      - var loadedAudioResources: [String: AudioFileResource] = [:]
      - var currentAudioPlayback: AudioPlaybackController?
      - var currentAudioName: String?
      - var isPlaying: Bool = false
      - var playbackProgress: Double = 0.0
    Methods:
      - func loadAudio(named audioName: String, from source: String, in bundle: Bundle) async throws {
      - func play(audioNamed audioName: String, duration: Double? = nil) async throws {
      - func stop() {
      - func updateGain(newGain: Float) {
      - func updateFocus(newFocus: Float) {
      - func updatePositionOffset(newOffset: SIMD3<Float>) {
      - func updateRotationOffset(newRotation: simd_quatf) {
      - private func updateAudioAnchorTransform() {
      - func cleanup() {
      - func attachAudioSystem(spatial: Bool = true, gain: Float = 1.0, focus: Float = 1.0) -> EntityAudioSystem {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/Entity+Find.swift

---
Classes:
  Class: Entity+Find
    Methods:
      - func findComponent<T>(ofType type: T.Type) -> T? where T: Component {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/Entity+Opacity.swift

---
Classes:
  Class: Entity+Opacity
    Properties:
      - var opacity: Float {
    Methods:
      - func fadeOpacity(to targetOpacity: Float,
                    duration: TimeInterval = 1.0,
                    delay: TimeInterval = 0,
                    timing: RealityKit.AnimationTimingFunction = .easeInOut,
                    waitForCompletion: Bool = false) async {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/Entity+Trace.swift

---
Classes:
  Class: Entity+Trace
    Methods:
      - func resetTrace(recursive: Bool = false) {
      - func updateTrace(
        anchor: Entity,
        width: Float,
        isVisible: Bool,
        isPaused: Bool
    ) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/EnvironmentResource.swift

---

---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/Transitions.swift

---
Classes:
  Class: Appear
    Methods:
      - func body(content: Content, phase: TransitionPhase) -> some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/View+SelectorAnimation.swift

---
Classes:
  Class: View+SelectorAnimation
    Methods:
      - func selectorAnimation(isVisible: Bool) -> some View {
  Class: SelectorAnimationModifier
    Properties:
      - let isVisible: Bool
      - @State private var scale: CGFloat = 0.8
      - @State private var opacity: Double = 0
    Methods:
      - func body(content: Content) -> some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/View+WordAnimation.swift

---

---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Extensions/WordByWordTransition.swift

---
Classes:
  Class: WordByWordTransition
    Properties:
      - var totalDuration: Double = 0.9
      - var elementDuration: Double = 0.4
      - var extraBounce: Double = 0.2
      - static var properties: TransitionProperties {
      - var flattenedRuns: some RandomAccessCollection<Text.Layout.Run> {
      - var flattenedRunSlices: some RandomAccessCollection<Text.Layout.RunSlice> {
    Methods:
      - func body(content: Content, phase: TransitionPhase) -> some View {
  Class: WordAnimationRenderer
    Properties:
      - var elapsedTime: TimeInterval
      - var elementDuration: TimeInterval
      - var totalDuration: TimeInterval
      - var extraBounce: Double
      - var spring: Spring {
      - var animatableData: Double {
    Methods:
      - func draw(layout: Text.Layout, in context: inout GraphicsContext) {
      - func draw(_ slice: Text.Layout.RunSlice, at time: TimeInterval, in context: inout GraphicsContext) {
      - func elementDelay(count: Int) -> TimeInterval {
  Class: EmphasisAttribute
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/FollowSystemAndComponent/FollowComponent.swift

---
Classes:
  Class: FollowComponent
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/FollowSystemAndComponent/FollowSystem.swift

---
Classes:
  Class: FollowSystem
    Properties:
      - static let query = EntityQuery(where: .has(FollowComponent.self))
      - private let arkitSession = ARKitSession()
      - private let worldTrackingProvider = WorldTrackingProvider()
    Methods:
      - func runSession() {
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/FollowSystemAndComponent/HeadPositionTracker.swift

---
Classes:
  Class: WorldTrackingError
  Class: HeadPositionTracker
    Properties:
      - let arSession = ARKitSession()
      - let worldTracking = WorldTrackingProvider()
      - private var isInitialized = false
    Methods:
      - func ensureInitialized() async throws {
      - func originFromDeviceTransform() -> simd_float4x4? {
      - func positionEntityRelativeToUser(_ entity: Entity?, offset: SIMD3<Float> = [0, 0, -1]) {
      - func positionEntityInFrontOfUser(_ entity: Entity?, distance: Float = -1.0) {

Enums:
  - WorldTrackingError
    Cases:
      - trackingFailed
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/FollowSystemAndComponent/PositioningComponent.swift

---
Classes:
  Class: PositioningComponent
    Properties:
      - var offsetX: Float
      - var offsetY: Float
      - var offsetZ: Float
      - var needsPositioning: Bool
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/FollowSystemAndComponent/PositioningSystem.swift

---
Classes:
  Class: PositioningSystem
    Properties:
      - static let query = EntityQuery(where: .has(PositioningComponent.self))
      - private static var sharedAppModel: AppModel?
      - private let systemId = UUID()
    Methods:
      - static func setAppModel(_ appModel: AppModel) {
      - public func update(context: SceneUpdateContext) {
      - private func tryPositionEntity(entity: Entity, component: inout PositioningComponent, deviceAnchor: DeviceAnchor) async -> Bool {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Managers/HandTrackingManager.swift

---
Classes:
  Class: HandTrackingManager
    Properties:
      - private weak var trackingManager: TrackingSessionManager?
      - private var contentEntity = Entity()
      - private(set) var leftHandAnchor: HandAnchor?
      - private(set) var rightHandAnchor: HandAnchor?
      - private let fingerEntities: [HandAnchor.Chirality: ModelEntity] = [
 .left: .createFingertip(), .right: .createFingertip()
    Methods:
      - func configure(with trackingManager: TrackingSessionManager) {
      - func setupContentEntity() -> Entity {
      - func getFingerPosition(_ chirality: HandAnchor.Chirality) -> SIMD3<Float>? {
      - func getPinchDistance(_ chirality: HandAnchor.Chirality) -> Float? {
      - private func distance(_ a: SIMD3<Float>, _ b: SIMD3<Float>) -> Float {
      - func updateHandAnchors(left: HandAnchor?, right: HandAnchor?) {
      - static func createFingertip() -> ModelEntity {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Managers/TrackingSessionManager.swift

---
Classes:
  Class: TrackingSessionManager
    Properties:
      - let arkitSession = ARKitSession()
      - var worldTrackingProvider = WorldTrackingProvider()
      - var handTrackingProvider: HandTrackingProvider!
      - private(set) var providersStoppedWithError = false
      - private(set) var worldSensingAuthorizationStatus = ARKitSession.AuthorizationStatus.notDetermined
      - private var isTracking = false
      - private(set) var currentState: DataProviderState = .initialized
      - private(set) var leftHandAnchor: HandAnchor?
      - private(set) var rightHandAnchor: HandAnchor?
      - var shouldProcessHandTracking: Bool = false
      - let handTrackingManager: HandTrackingManager
      - weak var appModel: AppModel?
    Methods:
      - func startTracking(needsHandTracking: Bool = false) async throws {
      - func stopTracking() {
      - func processWorldTrackingUpdates() async {
      - func processHandTrackingUpdates() async {
      - func monitorTrackingEvents() async {
      - func requestWorldSensingAuthorization() async {
  Class: TrackingError
    Methods:
      - func logTrackingState(context: String) async {
      - func logTransition(from: String, to: String) async {

Enums:
  - TrackingError
    Cases:
      - capabilitiesUnavailable
      - providerError
      - authorizationDenied
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/ADCSystem.swift

---
Classes:
  Class: ADCSystem
    Properties:
      - static let query = EntityQuery(where: .has(ADCComponent.self))
    Methods:
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/AntigenSystem.swift

---
Classes:
  Class: AntigenSystem
    Properties:
      - static let query = EntityQuery(where: .has(AntigenComponent.self))
      - static let retractionSpeed: Float = 0.25  // Units per second
    Methods:
      - public func update(context: SceneUpdateContext) {
      - private static func mix(_ a: Float, _ b: Float, t: Float) -> Float {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/AttachmentSystem.swift

---
Classes:
  Class: AttachmentSystem
    Properties:
      - let attachmentQuery = EntityQuery(where: .has(AttachmentPoint.self))
      - let cancerCellQuery = EntityQuery(where: .has(CancerCellStateComponent.self))
    Methods:
      - @MainActor
    public func update(context: SceneUpdateContext) {
      - @MainActor
    public static func getAvailablePoint(
        in scene: RealityKit.Scene,
        forCellID cellID: Int,
        approachPosition: SIMD3<Float>? = nil
    ) -> Entity? {
      - @MainActor
    public static func markPointAsOccupied(_ point: Entity) {
      - @MainActor
    public static func markPointAsAvailable(_ entity: Entity) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/BreathingSystem.swift

---
Classes:
  Class: BreathingSystem
    Properties:
      - static let query = EntityQuery(where: .has(BreathingComponent.self))
      - public nonisolated static var dependencies: [SystemDependency] {
    Methods:
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/RotationAxis.swift

---
Classes:
  Class: RotationAxis

Enums:
  - RotationAxis
    Cases:
      - xAxis
      - yAxis
      - zAxis
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/RotationSystem.swift

---
Classes:
  Class: RotationComponent
    Properties:
      - public var rotationAxis: RotationAxis = .yAxis
      - public var speed: Float = 1.0
      - public var axis: SIMD3<Float> {
  Class: RotationSystem
    Properties:
      - static let query = EntityQuery(where: .has(RotationComponent.self))
    Methods:
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/SwirlingSystem.swift

---
Classes:
  Class: SwirlingComponent
  Class: SwirlingSystem
    Properties:
      - static let query = EntityQuery(where: .has(SwirlingComponent.self))
    Methods:
      - public func update(context: SceneUpdateContext) {
      - private func updateEntityPosition(_ entity: Entity, deltaTime: Float) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/TraceComponent.swift

---
Classes:
  Class: TraceComponent
    Properties:
      - var accumulatedTime: TimeInterval = 0
      - var mesh: TraceMesh
      - var isPaused: Bool = false
      - weak var anchor: Entity?
      - var model: ModelEntity?
  Class: TraceSystem
    Properties:
      - static let query = EntityQuery(where: .has(TraceComponent.self))
    Methods:
      - func update(context: SceneUpdateContext) {
  Class: TraceMesh
    Properties:
      - var positions: [SIMD3<Float>] = []
      - var uvs: [SIMD2<Float>] = []
      - var width: Float = 5
      - static let maxIndexCount: UInt32 = 400
      - static let triangleIndices = Self.generateIndices()
      - var meshContents: MeshResource.Contents {
    Methods:
      - mutating func addPosition(of entity: Entity, relativeTo referenceEntity: Entity) {
      - static func generateIndices() -> [UInt32] {
      - static func makeTraceModel(with contents: MeshResource.Contents) throws -> ModelEntity {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/UIAttachmentSystem.swift

---
Classes:
  Class: UIAttachmentSystem
    Properties:
      - static let query = EntityQuery(where: .has(CancerCellComponent.self) && .has(CancerCellStateComponent.self) && .has(UIAttachmentComponent.self))
    Methods:
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/UIStabilizerSystem.swift

---
Classes:
  Class: UIStabilizerSystem
    Properties:
      - static let query = EntityQuery(where: .has(UIAttachmentComponent.self))
    Methods:
      - public func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Systems/UIStateSyncSystem.swift

---
Classes:
  Class: UIStateSyncSystem
    Properties:
      - static let query = EntityQuery(where: .has(CancerCellStateComponent.self))
    Methods:
      - func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/ClosureComponent.swift

---
Classes:
  Class: ClosureComponent
    Properties:
      - let closure: (TimeInterval) -> Void
  Class: ClosureSystem
    Properties:
      - static let query = EntityQuery(where: .has(ClosureComponent.self))
    Methods:
      - func update(context: SceneUpdateContext) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/CollisionGroups.swift

---
Classes:
  Class: CollisionGroups
    Properties:
      - static let cancerCell = CollisionGroup(rawValue: 1 << 0)
      - static let adc = CollisionGroup(rawValue: 1 << 1)
      - static let microscope = CollisionGroup(rawValue: 1 << 5)
      - static let headTracking = CollisionGroup(rawValue: 1 << 6)
      - static let actualEarthGravity = CollisionGroup(rawValue: 100 << 0)
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/Floats.swift

---
Classes:
  Class: Floats
    Methods:
      - func length() -> Float {
      - func normalized() -> Float3 {
      - func toFloat3() -> Float3 {
      - func translation() -> Float3 {
      - func forward() -> Float3 {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/Gravity.swift

---
Classes:
  Class: Gravity
    Properties:
      - var parameterTypes: PhysicsBodyParameterTypes {
      - var forceMode: ForceMode {
      - var gravityMagnitude: Float = 0.1
      - var minimumDistance: Float = 0.2
    Methods:
      - func update(parameters: inout ForceEffectParameters) {
      - func computeForce(position: SIMD3<Float>, distance: Float) -> SIMD3<Float> {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/HeadTracker.swift

---
Classes:
  Class: HeadTracker
    Properties:
      - let arSession = ARKitSession()
      - let worldTracking = WorldTrackingProvider()
  Class: Configuration
    Properties:
      - var heightOffset: Float = 0.0
      - var collisionRadius: Float = 0.1
      - var config = Configuration()
      - private var headCollisionEntity: ModelEntity?
      - @Published var isTracking: Bool = false
    Methods:
      - func getInitialHeadAnchor() -> AnchorEntity {
      - func setupCollisionTracking() -> ModelEntity {
      - func startTracking() async {
      - func stopTracking() {
      - func updateHeadPosition() {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/IBLUtility.swift

---
Classes:
  Class: IBLUtility
    Methods:
      - static func addImageBasedLighting(
        to root: Entity,
        imageName: String,
        intensity: Float = 1.0
    ) async throws {

Enums:
  - IBLUtility
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/Logger.swift

---
Classes:
  Class: Logger
    Properties:
      - private static let subsystem = Bundle.main.bundleIdentifier ?? "com.PfizerOutdoCancer.app"
    Methods:
      - public static func info(_ message: String) {
      - public static func debug(_ message: String) {
      - public static func error(_ message: String) {
      - public static func fault(_ message: String) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/PortalManager.swift

---
Classes:
  Class: PortalManager
    Methods:
      - static func createPortal(appModel: AppModel, environment: Entity, portalPlaneName: String) async -> Entity {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/RotationHelpers.swift

---
Classes:
  Class: RotationHelpers
    Methods:
      - func toEulerAngles() -> SIMD3<Float> {
      - func onlyYaw() -> simd_quatf {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Utility/UnorderedPair.swift

---
Classes:
  Class: UnorderedPair
    Properties:
      - let itemA: T
      - let itemB: T
    Methods:
      - static func == (lhs: Self, rhs: Self) -> Bool {
      - func hash(into hasher: inout Hasher) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ViewModels/IntroViewModel/IntroViewModel.swift

---
Classes:
  Class: IntroViewModel
    Properties:
      - var introRootEntity: Entity?
      - var scene: RealityKit.Scene?
      - var shouldUseSky = true  // New flag to control sky animation
      - var skyDarkness: Float = 0.98
      - private var animationTask: Task<Void, Never>?
      - private var portal: Entity?
      - private var skyDome: Entity?
      - private var logo: Entity?
      - private var titleRoot: Entity?
      - private var material: ShaderGraphMaterial?
      - private var assembledLab: Entity?
      - var introEnvironment: Entity?
      - var titleEntity: Entity?
      - var navToggleEntity: Entity?
      - var showTitleText = false
      - var shouldDimSurroundings = false
      - var isSetupComplete = false
      - var environmentLoaded = false
      - var appModel: AppModel!
      - var isRootSetupComplete = false
      - var isEnvironmentSetupComplete = false
      - var isHeadTrackingRootReady = false
      - var shouldUpdateHeadPosition = false
      - var isPositioningComplete = false
      - var isPositioningInProgress = false  // Add positioning progress flag
      - var isReadyForInteraction: Bool {
    Methods:
      - func setupRoot() -> Entity {
      - func setupEnvironment(in root: Entity) async {
      - func setupAttachments(in environment: Entity, for portal: Entity, titleEntity: Entity, labViewerEntity: Entity? = nil) {
      - private func setupSkyDome(in environment: Entity) {
      - private func setupPortal(in root: Entity) async {
      - private func refreshPosition() async {
      - func runAnimationSequence() async {
      - @MainActor
            func ensureValidEntity(_ entity: Entity?, with name: String) -> Bool {
      - func getPortal() -> Entity? {
      - func cleanup() {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ViewModels/LabViewModel/LabViewModel.swift

---
Classes:
  Class: LabViewModel
    Properties:
      - var mainEntity: Entity?
      - var scene: RealityKit.Scene?
      - private var labAudioEntity: Entity?
      - var adcBuilderViewerButtonEntity: Entity?
      - var attackCancerViewerButtonEntity: Entity?
      - var adcTemplate: Entity?
      - var isSetupComplete = false
      - var isLibraryOpen = false
      - var shouldShowADCButton = false
      - var appModel: AppModel!
    Methods:
      - func setupRoot() -> Entity {
      - func setupADCPlacer(in root: Entity) {
      - func setupInitialLabEnvironment(in root: Entity, isIntro: Bool? = nil) async throws {
      - func setupLabEnvironment(in root: Entity, isIntro: Bool? = nil) async throws {
      - func setupAttachments(attachments: RealityViewAttachments) {
      - private func findInteractiveDevices(in root: Entity) -> [(entity: Entity, meshEntity: Entity)] {
      - private func configureInteractiveDevices(in entity: Entity) {
      - func handleTap(on entity: Entity) {
      - func cleanup() {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/ViewModels/OutroViewModel/OutroViewModel.swift

---
Classes:
  Class: OutroViewModel
    Properties:
      - var outroRootEntity: Entity?
      - var scene: RealityKit.Scene?
      - private var outroEnvironmentEntity: Entity?
      - var isSetupComplete = false
      - var appModel: AppModel!
      - var shouldUseSky = true
      - var skyDarkness: Float = 0.98  // Same value as intro
      - private var skyDome: Entity?
    Methods:
      - func setupOutroRoot() -> Entity {
      - func setupEnvironment(in root: Entity) async {
      - private func setupSkyDome(in environment: Entity) {
      - func startSkyAnimation() async {
      - func cleanup() {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/Effects/ButtonHoverEffects.swift

---
Classes:
  Class: FadeEffect
    Properties:
      - var opacityFrom: Double = 0
      - var opacityTo: Double = 1
    Methods:
      - func body(content: Content) -> some CustomHoverEffect {
  Class: GlowingOutlineEffect
    Methods:
      - func body(content: Content) -> some CustomHoverEffect {
  Class: GradientBorderEffect
    Methods:
      - func body(content: Content) -> some CustomHoverEffect {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/ADCBuilderViewerButton.swift

---
Classes:
  Class: ADCBuilderViewerButton
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(\.openWindow) private var openWindow
      - @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
      - @State private var rotation: CGFloat = 0.0
      - @State private var currentTheme: GradientTheme = .lightBlue
      - var scaleEffect: CGFloat = 1.2
      - var width: CGFloat = 400
      - var height: CGFloat = 250
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/AttackCancerInstructionsView.swift

---
Classes:
  Class: AttackCancerInstructionsView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - @Environment(\.dismiss) private var dismiss
      - @Environment(\.openWindow) private var openWindow
      - @State private var opacity: Double = 0  // Add state for opacity
      - var body: some View {
    Methods:
      - private func instructionSection(title: String, description: String, systemImage: String) -> some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/AttackCancerView.swift

---
Classes:
  Class: AttackCancerView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(\.scenePhase) private var scenePhase
      - @Environment(\.dismissWindow) private var dismissWindow
      - @Environment(\.realityKitScene) private var scene
      - @Environment(\.openWindow) private var openWindow
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/AttackCancerViewerButton.swift

---
Classes:
  Class: GradientTheme
  Class: AttackCancerViewerButton
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - @Environment(\.openWindow) private var openWindow
      - @State private var rotation: CGFloat = 0.0
      - @State private var currentTheme: GradientTheme = .lightMustard
      - var scaleEffect: CGFloat = 1.2
      - var width: CGFloat = 450
      - var height: CGFloat = 350
      - private let isDebugMode = false
      - private let isDebugMode = false
      - private var shouldShowButton: Bool {
      - var body: some View {
    Methods:
      - private func cycleTheme() {

Enums:
  - GradientTheme
    Cases:
      - darkRed
      - lightRed
      - lightGreen
      - lightMustard
      - lightBlue
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/CompletedView.swift

---
Classes:
  Class: CompletedView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - @Environment(\.openWindow) private var openWindow
      - @Environment(\.dismissWindow) private var dismissWindow
      - @State private var animateStats = false
      - @State private var opacity: Double = 0  // Add state for opacity
      - private var stats: (destroyed: Int, deployed: Int, score: Int) {
      - var body: some View {
    Methods:
      - private func statRow(_ title: String, value: Int, icon: String) -> some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/ContentView.swift

---
Classes:
  Class: ContentView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) var adcDataModel
      - @Environment(\.dismissWindow) private var dismissWindow
      - @Environment(\.openWindow) private var openWindow
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/ErrorView.swift

---
Classes:
  Class: ErrorView
    Properties:
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/GradientNavigationButtonStyle.swift

---
Classes:
  Class: GradientNavigationButtonStyle
    Properties:
      - let theme: GradientTheme
      - let width: CGFloat
      - let height: CGFloat
      - let buttonWidth: CGFloat
      - let buttonHeight: CGFloat
      - @State private var rotation: CGFloat = 0.0
    Methods:
      - func makeBody(configuration: Configuration) -> some View {
      - func gradientNavigationButtonStyle(theme: GradientTheme, width: CGFloat, height: CGFloat, buttonWidth: CGFloat, buttonHeight: CGFloat = 60) -> some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/HitCounterView.swift

---
Classes:
  Class: HitCounterView
    Properties:
      - @Environment(AppModel.self) private var appModel: AppModel
      - let hits: Int
      - let requiredHits: Int
      - let isDestroyed: Bool
      - private let lineWidth: CGFloat = 12
      - private let fontSize: CGFloat = 75
      - @State private var isPulsing = false
      - @State private var isHit = false
      - var progress: CGFloat {
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/HopeMeterUtilityView.swift

---
Classes:
  Class: HopeMeterUtilityView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - private let height: CGFloat = 30
      - private let fontSize: CGFloat = 20
      - @State private var progressOpacity: Double = 0
      - var progress: CGFloat {
      - var percentage: Int {
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/HopeMeterView.swift

---
Classes:
  Class: HopeMeterView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - private let lineWidth: CGFloat = 12
      - private let fontSize: CGFloat = 65
      - var progress: CGFloat {
      - var percentage: Int {
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/IntroView.swift

---
Classes:
  Class: IntroView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - @Environment(\.dismissWindow) private var dismissWindow
      - @Environment(\.openWindow) private var openWindow
      - @State private var introTintIntensity: Double = 0.2 {
      - @State private var showNavToggle: Bool = true
      - var surroundingsEffect: SurroundingsEffect? {
      - @State var handTrackedEntity: Entity = {
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/IntroWindowView.swift

---
Classes:
  Class: IntroWindowView
    Properties:
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/LabView.swift

---
Classes:
  Class: LabView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(\.openWindow) private var openWindow
      - @Environment(\.dismissWindow) private var dismissWindow
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/LabViewerButton.swift

---
Classes:
  Class: LabViewerButton
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - @Environment(\.openWindow) private var openWindow
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/LibraryView.swift

---
Classes:
  Class: LibraryView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(\.pushWindow) private var pushWindow
      - @Environment(\.openWindow) private var openWindow
      - @Environment(\.dismissWindow) private var dismissWindow
      - var body: some View {
  Class: WebView
    Properties:
      - let url: URL
    Methods:
      - func makeUIView(context: Context) -> WKWebView {
      - func updateUIView(_ uiView: WKWebView, context: Context) {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/LibraryWindow.swift

---
Classes:
  Class: LibraryWindow
    Properties:
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/LoadingView.swift

---
Classes:
  Class: LoadingView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(\.dismissWindow) private var dismissWindow
      - @State private var showTitle = false
      - @State private var viewOpacity: Double = 1.0
      - @Namespace private var logoNamespace
      - var body: some View {
  Class: LoadingBlock
    Properties:
      - @Environment(AppModel.self) private var appModel
      - let namespace: Namespace.ID
      - var body: some View {
  Class: CompletedBlock
    Properties:
      - @Environment(AppModel.self) private var appModel
      - let namespace: Namespace.ID
      - @State private var showTitle = false
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/NavigationButton.swift

---
Classes:
  Class: VisionNavigationButtonStyle
    Properties:
      - var font: Font = .body
      - var width: CGFloat?
      - var scaleEffect: CGFloat = AppModel.UIConstants.buttonExpandScale
      - var theme: GradientTheme?
      - var gradientWidth: CGFloat?
      - var gradientHeight: CGFloat?
      - @State private var rotation: CGFloat = 0.0
    Methods:
      - func makeBody(configuration: Configuration) -> some View {
  Class: NavigationButton
    Properties:
      - @Environment(AppModel.self) private var appModel
      - let title: String
      - let action: () async -> Void
      - var font: Font = .body
      - var scaleEffect: CGFloat = AppModel.UIConstants.buttonExpandScale
      - var width: CGFloat? = nil
      - var theme: GradientTheme? = nil
      - var gradientWidth: CGFloat? = nil
      - var gradientHeight: CGFloat? = nil
      - var body: some View {
  Class: ScalableButtonStyle
    Properties:
      - var scaleFactor: CGFloat = AppModel.UIConstants.buttonExpandScale
    Methods:
      - func makeBody(configuration: Configuration) -> some View {
  Class: ScalableGlassButtonStyle
    Properties:
      - var scaleFactor: CGFloat = AppModel.UIConstants.buttonExpandScale
      - var cornerRadius: CGFloat = AppModel.UIConstants.buttonCornerRadius
    Methods:
      - func makeBody(configuration: Configuration) -> some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/NavigationView.swift

---
Classes:
  Class: NavigationView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) private var dataModel
      - @Environment(\.openWindow) private var openWindow
      - @Environment(\.scenePhase) private var scenePhase
      - private let buttonTitles = ["Lab", "Building", "Attack", "Outro"]
      - var body: some View {
    Methods:
      - private func handleNavigation(for title: String) async {
      - private func phaseFor(_ title: String) -> AppPhase {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/NavToggleView.swift

---
Classes:
  Class: NavToggleView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(\.openWindow) private var openWindow
      - private let size: CGFloat = 60
      - private let iconSize: CGFloat = 24
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/OutdoCancer.swift

---
Classes:
  Class: OutdoCancer
    Properties:
      - @Binding var showTitle: Bool
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/OutroView.swift

---
Classes:
  Class: OutroView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(\.dismissWindow) private var dismissWindow
      - @Environment(\.openWindow) private var openWindow
      - @State private var outroTintIntensity: Double = 0.02
      - var surroundingsEffect: SurroundingsEffect? {
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/Screen.swift

---
Classes:
  Class: Screen
    Properties:
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/StartButton.swift

---
Classes:
  Class: StartButton
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(ADCDataModel.self) var dataModel
      - @Environment(\.openWindow) private var openWindow
      - @Environment(\.dismissWindow) private var dismissWindow
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/Views/StartView.swift

---
Classes:
  Class: StartView
    Properties:
      - @Environment(AppModel.self) private var appModel
      - @Environment(\.dismissWindow) private var dismissWindow
      - @State private var showTitle = false
      - var body: some View {
---


Path: /Users/dalecarman/Groove Jones Dropbox/Groove Jones Production/Pfizer/Lets Outdo Cancer AVP/Creative/dev/PfizerOutdoCancer/PfizerOutdoCancer/PfizerOutdoCancerApp.swift

---
Classes:
  Class: PfizerOutdoCancerApp
    Properties:
      - @State private var appModel = AppModel()
      - @State private var adcDataModel = ADCDataModel()
      - @Environment(\.openImmersiveSpace) private var openImmersiveSpace
      - @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
      - @Environment(\.openWindow) private var openWindow
      - @Environment(\.dismissWindow) private var dismissWindow
      - @Environment(\.scenePhase) private var scenePhase
      - @State private var immersionStyle: ImmersionStyle =
 .progressive(0.0...1.0, initialAmount: 0.5)
      - var body: some Scene {
    Methods:
      - @MainActor
    private func handleWindowsForPhase(_ phase: AppPhase) async {
      - private func cleanupAppState() async {
      - private func handleScenePhaseChange(to newPhase: ScenePhase) async {
---

</Complete Definitions>
</file_map>

<file_contents>
File: AppModel/AppModel.swift
```swift
//
//  AppModel.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman
//

import SwiftUI
import RealityKit
import RealityKitContent
import ARKit
import os

// MARK: - App Constants
extension AppModel {
    nonisolated static let mainWindowId = "main"
    nonisolated static let introWindowId = "intro"
    nonisolated static let libraryWindowId = "library"
    nonisolated static let builderWindowId = "builder"
    nonisolated static let navWindowId = "DebugNavigation"
    nonisolated static let gameCompletedWindowId = "Completed"
    nonisolated static let hopeMeterUtilityWindowId = "HopeMeterUtility"
    
    nonisolated static let introSpaceId = "IntroSpace"
    nonisolated static let outroSpaceId = "OutroSpace"
    nonisolated static let labSpaceId = "LabSpace"
    nonisolated static let buildingSpaceId = "BuildingSpace"
    nonisolated static let attackSpaceId = "AttackSpace"
    
    enum PositioningDefaults {
        case intro
        case building
        case playing
        
        var position: SIMD3<Float> {
            switch self {
            case .intro:    return SIMD3<Float>(0.0, -1.5, -1.0)
            case .building: return SIMD3<Float>(0.0, 1.2, -1.0)
            case .playing:  return SIMD3<Float>(0.0, 1.5, -1.0)
            }
        }
    }
    
    // MARK: - Global UI Settings
    enum UIConstants {
        // Button Dimensions
        static let buttonCornerRadius: CGFloat = 16
        static let buttonPaddingHorizontal: CGFloat = 24
        static let buttonPaddingVertical: CGFloat = 16
        static let buttonExpandScale: CGFloat = 1.1
        static let buttonPressScale: CGFloat = 0.85
        
        // Animation Durations
        static let buttonHoverDuration: CGFloat = 0.2
        static let buttonPressDuration: CGFloat = 0.3
    }
}

enum AppPhase: String, CaseIterable, Codable, Sendable, Equatable {
    case loading
    case ready
    case intro
    case lab
    case building
    case playing
    case completed
    case outro
    case error
    
    var needsImmersiveSpace: Bool {
        return self != .loading && self != .error && self != .building 
    }
    
    var needsHandTracking: Bool {
        switch self {
        case .intro, .lab, .building, .playing, .ready:
            return true
        case .loading, .completed, .outro, .error:
            return false
        }
    }
    
    var shouldKeepPreviousSpace: Bool {
        if self == .completed { return true }
        return false
    }
    
    var spaceId: String {
        switch self {
        case .intro: return AppModel.introSpaceId
        case .lab: return AppModel.labSpaceId
        case .building: return AppModel.buildingSpaceId
        case .playing, .completed: return AppModel.attackSpaceId
        case .outro: return AppModel.outroSpaceId
        case .ready: return AppModel.introSpaceId
        case .loading, .error: return ""
        }
    }
    
    var windowId: String {
        switch self {
        case .loading, .ready, .completed: return AppModel.mainWindowId
        case .intro: return AppModel.introWindowId
        case .lab: return AppModel.libraryWindowId
        case .building: return AppModel.builderWindowId
        case .playing, .outro, .error: return ""
        }
    }
    
    var instructionsWindowId: String? {
        switch self {
        case .playing: return AppModel.mainWindowId // Use main window for instructions
        default: return nil
        }
    }
}

@Observable
@MainActor
final class AppModel {
    // MARK: - Properties
    let trackingManager = TrackingSessionManager()
    
    var shouldDimSurroundings: Bool = false
    var hasBuiltADC: Bool = false
    
    /// Current phase of the app
    var currentPhase: AppPhase = .loading
    
    // MARK: - Immersive Space Management
    enum ImmersiveSpaceState {
        case closed
        case inTransition
        case open
    }
    
    enum DismissReason {
        case manual    // Our code dismissed it
        case system    // Digital Crown or system dismissed it
    }
    
    var immersiveSpaceState: ImmersiveSpaceState = .closed
    var immersiveSpaceDismissReason: DismissReason?
    var triggerImmersiveSpace = false
    
    var gameState: AttackCancerViewModel
    var introState: IntroViewModel
    var labState: LabViewModel
    var outroState: OutroViewModel
    var isNavWindowOpen = false
    var isHopeMeterUtilityWindowOpen = false
    var isLibraryWindowOpen = false
    var isIntroWindowOpen = false
    var isMainWindowOpen = false
    var isBuilderInstructionsOpen = false
    var isBuilderWindowOpen = false
    var isLoadingWindowOpen = false
    var readyToStartLab: Bool = false

    // MARK: - Immersion Style
    var introStyle: ImmersionStyle = .mixed
    var outroStyle: ImmersionStyle = .mixed
    var labStyle: ImmersionStyle = .full
    var buildingStyle: ImmersionStyle = .mixed
    var attackStyle: ImmersionStyle = .progressive(
        0.1...1.0,
        initialAmount: 0.85
    )

    // MARK: - Asset Management
    let assetLoadingManager = AssetLoadingManager.shared
    var loadingProgress: Float {
        switch assetLoadingManager.loadingState {
        case .notStarted:
            return 0
        case .loading(let progress):
            return progress
        case .completed:
            return 1
        case .error:
            return 0 // Or handle errors differently
        }
    }
    var displayedProgress: Float = 0.0 // Displayed progress for animation
    
    func toggleLibrary() {
        // Single source of truth for library state
        labState.isLibraryOpen.toggle()
    }
    
    func updateLibraryWindowState(isOpen: Bool) {
        isLibraryWindowOpen = isOpen
    }
    
    // MARK: - Space Management
    var currentImmersiveSpace: String?
    @ObservationIgnored private(set) var isTransitioning = false
    
    var hasImmersiveSpace: Bool {
        return currentImmersiveSpace != nil
    }
    
    // MARK: Start the Attack Cancer Game
    
    
    var shouldStartGame: Bool {
        gameState.tutorialComplete && gameState.isHopeMeterRunning
    }
    
    func startAttackCancerGame() {
        Logger.debug("🎮 Starting Attack Cancer Game (startAttackCancerGame called)")
        Logger.debug("Starting Hope Meter")
        startHopeMeter()
    }
    
    // MARK: - Hope Meter Management
    @ObservationIgnored private var hopeMeterTimer: Timer?
    
    func startHopeMeter() {
        Logger.debug("🕒 Starting Hope Meter (startHopeMeter called)")
        stopHopeMeter() // Ensure any existing timer is cleaned up
        
        gameState.hopeMeterTimeLeft = gameState.hopeMeterDuration // Reset timer
        gameState.isHopeMeterRunning = true
        
        // Create a task to trigger the ending sequence at 19 seconds
        Task { @MainActor in
            // Wait until 19 seconds remain (hopeMeterDuration - 19 seconds)
            try? await Task.sleep(for: .seconds(gameState.hopeMeterDuration - 19))
            
            // Check if we're still running before playing
            if gameState.isHopeMeterRunning {
                Logger.debug("playingEndingSequence audio")
                await gameState.playEndingSequence()
            }
        }
        
        hopeMeterTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            
            Task { @MainActor in
                if self.gameState.hopeMeterTimeLeft > 0 {
                    self.gameState.hopeMeterTimeLeft -= 1
                } else {
                    self.stopHopeMeter()
                    await self.gameState.hopeMeterDidRunOut()
                    // wait a second for the sound and then transition
                    try? await Task.sleep(for: .milliseconds(2000))
                    await self.transitionToPhase(.completed)
                }
            }
        }
    }
    
    func stopHopeMeter() {
        Logger.debug("🛑 Stopping Hope Meter")
        hopeMeterTimer?.invalidate()
        hopeMeterTimer = nil
        gameState.isHopeMeterRunning = false
    }
    
    @MainActor
    func accelerateHopeMeterToCompletion() async {
        Logger.debug("🚀 Accelerating hope meter to completion")
        
        // Stop the normal timer
        hopeMeterTimer?.invalidate()
        hopeMeterTimer = nil
        
        // Animate the hope meter to completion using SwiftUI's withAnimation over 2 seconds.
        // This assumes that the UI is bound to gameState.hopeMeterTimeLeft.
        await MainActor.run {
            withAnimation(.easeInOut(duration: 2.0)) {
                gameState.hopeMeterTimeLeft = 0
            }
        }
        
        // Wait for 2 seconds after the animation completes.
        try? await Task.sleep(nanoseconds: 2_000_000_000)
        
        // Mark the hope meter as finished.
        await MainActor.run {
            gameState.isHopeMeterRunning = false
        }
    }
    
    deinit {
        // Since we're on MainActor, we can directly invalidate the timer
        hopeMeterTimer?.invalidate()
        hopeMeterTimer = nil
    }
    
    // MARK: - Initialization
    init() {
        self.gameState = AttackCancerViewModel()
        self.introState = IntroViewModel()
        self.labState = LabViewModel()
        self.outroState = OutroViewModel()
        
        // Set up dependencies
        self.gameState.appModel = self
        self.introState.appModel = self
        self.labState.appModel = self
        self.outroState.appModel = self
        self.gameState.handTracking = self.trackingManager.handTrackingManager
        self.trackingManager.appModel = self  // Set the reference to AppModel
        Logger.debug("AppModel init() - Instance: \(ObjectIdentifier(self))")
    }
    
    // MARK: - Phase Management
    @MainActor
    func transitionToPhase(_ newPhase: AppPhase, adcDataModel: ADCDataModel? = nil) async {
        Logger.info("""
        
        🔄 === PHASE TRANSITION START ===
        ├─ From: \(currentPhase)
        ├─ To: \(newPhase)
        ├─ Current Tracking State: \(trackingManager.worldTrackingProvider.state)
        ├─ Has Hand Tracking: \(currentPhase.needsHandTracking)
        └─ Will Need Hand Tracking: \(newPhase.needsHandTracking)
        """)
        
        Logger.debug("🔄 Phase transition: \(currentPhase) -> \(newPhase)")
        Logger.debug("🔍 isTransitioning: \(isTransitioning)")
        Logger.debug("🔍 immersiveSpaceState: \(immersiveSpaceState)")
        guard !isTransitioning else {
            Logger.debug("⚠️ Already transitioning, skipping")
            return
        }
        isTransitioning = true
        defer { 
            isTransitioning = false 
            Logger.debug("✅ Phase transition completed: \(newPhase)")
        }

        // 1. Stop tracking if we're in a phase that uses it
        if currentPhase.needsHandTracking {
            Logger.info("🛑 Stopping tracking for phase transition")
            await trackingManager.stopTracking()
            
            do {
                // Wait for tracking to fully stop with verification
                try await trackingManager.waitForCleanup()
                if !trackingManager.verifyProviderState(expectRunning: false) {
                    Logger.error("❌ Tracking cleanup verification failed")
                    // Continue with transition but log the error
                }
            } catch {
                Logger.error("❌ Tracking cleanup failed: \(error)")
                // Continue with transition but log the error
            }
            
            Logger.info("📊 Post-Stop Tracking State: \(trackingManager.worldTrackingProvider.state)")
        }

        // 2. Pre-load assets for the new phase before cleanup
        await preloadAssets(for: newPhase, adcDataModel: adcDataModel)

        if newPhase == .playing {
            gameState.resetCleanupForNewSession()
        }

        // 3. Clean up current phase
        await cleanupCurrentPhase(for: newPhase)

        // 4. Set the new phase before starting tracking
        currentPhase = newPhase

        // 5. Start tracking if needed with retry logic
        if newPhase.needsHandTracking {
            await startTrackingWithRetry(for: newPhase)
        }
    }

    /// Attempts to start tracking with retry logic
    private func startTrackingWithRetry(for phase: AppPhase) async {
        let maxRetries = 3
        var trackingStarted = false
        
        for attempt in 1...maxRetries {
            do {
                // Add a small delay between attempts
                if attempt > 1 {
                    try await Task.sleep(for: .milliseconds(100))
                }
                
                try await trackingManager.startTracking(needsHandTracking: phase.needsHandTracking)
                
                // Verify tracking state
                if trackingManager.verifyProviderState(expectRunning: true) {
                    trackingStarted = true
                    Logger.info("✅ Tracking started successfully on attempt \(attempt)")
                    break
                } else {
                    Logger.error("❌ Provider state verification failed on attempt \(attempt)")
                }
            } catch {
                Logger.error("""
                
                ❌ Tracking start failed (Attempt \(attempt)/\(maxRetries))
                ├─ Error: \(error)
                ├─ Phase: \(phase)
                └─ Provider State: \(trackingManager.worldTrackingProvider.state)
                """)
                
                if attempt == maxRetries {
                    Logger.error("❌ All tracking start attempts failed")
                }
            }
        }
        
        if !trackingStarted {
            Logger.error("❌ Failed to start tracking after \(maxRetries) attempts")
            // Consider transitioning to error state or implementing recovery logic
        }
    }

    private func preloadAssets(for phase: AppPhase, adcDataModel: ADCDataModel?) async {
        if phase == .intro || phase == .playing {
            Logger.debug("\n=== Preparing ADC for intro and playing ===")
            if let adcDataModel = adcDataModel {
                do {
                    // Load and configure ADC template
                    Logger.debug("🎯 Loading ADC template...")
                    let adcEntity = try await assetLoadingManager.instantiateAsset(
                        withName: "adc",
                        category: .adc
                    )
                    Logger.debug("✅ ADC entity loaded, applying colors...")
                    gameState.setADCTemplate(adcEntity, dataModel: adcDataModel)
                    Logger.debug("✅ ADC template configured with colors")
                    
                    // Pass template to lab state if we have built an ADC
                    labState.adcTemplate = gameState.adcTemplate
                    Logger.debug("✅ ADC template passed to lab state")
                    

                } catch {
                    Logger.debug("❌ Failed to load playing phase assets: \(error)")
                }
            } else {
                Logger.debug("❌ No ADCDataModel available for playing phase")
            }
        }
        if phase == .playing {
            Logger.debug("\n=== Pre-loading Playing Phase Assets ===")
            Logger.debug("📱 Pre-loading required assets for playing phase...")
            if adcDataModel != nil {
                do {
                    
                    // Ensure tutorial asset is loaded and cached
                    Logger.debug("🎯 Loading tutorial assets...")
                    _ = try await assetLoadingManager.instantiateAsset(
                        withName: "game_start_vo",
                        category: .attackCancerEnvironment
                    )
                    Logger.debug("✅ Tutorial assets cached")

                    // ADDED: Load and cache attack_cancer_environment
                    Logger.debug("🎯 Loading attack_cancer_environment...")
                    _ = try await assetLoadingManager.instantiateAsset(
                        withName: "attack_cancer_environment",
                        category: .attackCancerEnvironment
                    )
                    Logger.debug("✅ attack_cancer_environment cached")
                    try? await Task.sleep(for: .milliseconds(100)) // Small delay
                    Logger.debug("✅✅✅ Playing Phase Assets Ready (with delay) ===\n") // More emphatic message

                } catch {
                    Logger.debug("❌ Failed to load playing phase assets: \(error)")
                }
            } else {
                Logger.debug("❌ No ADCDataModel available for playing phase")
            }
        } else if phase == .outro {
            Logger.debug("\n=== Pre-loading Outro Phase Assets ===")
            Logger.debug("📱 Pre-loading outro environment...")
            do {
                _ = try await assetLoadingManager.instantiateAsset(
                    withName: "outro_environment",
                    category: .outroEnvironment
                )
                Logger.debug("✅ Outro environment cached")
                Logger.debug("=== Outro Phase Assets Ready ===\n")
            } catch {
                Logger.debug("❌ Failed to pre-load outro environment: \(error)")
            }
        } else if phase == .building {
            os_log(.debug, "AppModel: Preloading Building Phase Assets...")
            // Optionally trigger a preloading for building assets if needed (for example, loading "antibody_scene" here)
            do {
                let scene = try await assetLoadingManager.instantiateAsset(
                    withName: "antibody_scene",
                    category: .buildADCEnvironment
                )
                os_log(.debug, "AppModel: Preloaded antibody_scene for Building Phase: %@", String(describing: scene))
            } catch {
                os_log(.error, "AppModel: Failed to preload Building Phase asset 'antibody_scene': %@", error.localizedDescription)
            }
        }
    }


    private func cleanupCurrentPhase(for newPhase: AppPhase) async {
        switch currentPhase {
        case .intro:
            // now that intro and lab are combined, we need to cleanup both
            introState.cleanup()
            await assetLoadingManager.releaseIntroEnvironment()
            labState.cleanup()
            await assetLoadingManager.releaseLabEnvironment()
        case .lab:
            labState.cleanup()
            await assetLoadingManager.releaseLabEnvironment()
        case .playing:
            if newPhase != .completed {
                Logger.debug("I am in the playing phase and I am not transitioning to completed so I am cleaning up")
                await gameState.cleanup()
                await assetLoadingManager.releaseAttackCancerEnvironment()
            } else {
                Logger.debug("I am in the playing phase and transitioning to completed, so preserving immersive assets")
            }
        case .completed:
            if newPhase == .outro {
                await gameState.fadeOutScene()
                try? await Task.sleep(for: .seconds(0.5))
                // Note: We're already preserving assets for outro transition
            } else {
                Logger.debug("I am in the completed phase and transitioning to \(newPhase); cleaning up normally.")
                await gameState.cleanup()
                await assetLoadingManager.releaseAttackCancerEnvironment()
            }
        case .outro:
            outroState.cleanup()
            await assetLoadingManager.releaseOutroEnvironment()
        case .ready, .loading, .building, .error:
            break // No cleanup needed.
        }
    }
    
    var isTutorialStarted: Bool = false
    
    // Track instruction window state
    var isInstructionsWindowOpen = false
    
    func startTutorial() {
        isTutorialStarted = true
        
    }
}

```

File: AppModel/AppModel+AssetLoading.swift
```swift
//
//  AppModel+AssetLoading.swift
//  SpawnAndAttrack
//
//  Created by Dale Carman on 12/10/24.
//

import SwiftUI

// Define a generic error to use
enum AppError: Error {
    case genericLoadingError
}

extension AppModel {
    // MARK: - Asset Loading
    
    var isLoadingAssets: Bool {
        if case .loading = assetLoadingManager.state {
            return true
        }
        return false
    }
    
    var assetsLoaded: Bool {
        if case .completed = assetLoadingManager.state {
            return true
        }
        return false
    }
    
    struct AssetToLoad {
        let name: String
        let category: AssetCategory
        let weight: Float  // Relative weight for progress calculation
    }
    
    func startLoading(adcDataModel: ADCDataModel) async {
        print("\n=== Starting Initial Asset Loading ===")
        print("🔍 Current phase: \(currentPhase)")
        print("🔍 Loading state: \(assetLoadingManager.loadingState)")
        
        // Reset the asset loading manager
        // assetLoadingManager.reset()
        
        print("🔄 Starting prepareIntroPhase...")
        await prepareIntroPhase()
        print("✅ prepareIntroPhase completed")
        print("🔄 Transitioning to .intro...")
        await transitionToPhase(.intro, adcDataModel: adcDataModel)
        print("✅ Transition to .intro completed")
    }
    
    func prepareIntroPhase() async {
        print("\n=== Preparing Intro Phase ===")
        print("🔍 Current phase before loading: \(currentPhase)")
        print("🔍 Loading state: \(assetLoadingManager.loadingState)")
        
        var introAssets: [String] = []
        introAssets.append(contentsOf: [
            "intro_environment",
            "intro_warp",
        ])
        
        var attackAssets: [String] = []
        attackAssets.append(contentsOf: [
            "attack_cancer_environment",
            "adc",
            "cancer_cell"
        ])
        
        var labAssets: [String] = []
        labAssets.append(contentsOf: [
            "assembled_lab"
        ])
        
        let allAssets = introAssets + attackAssets + labAssets
        
        var completedAssets = 0
        
        // Load intro environment assets
        for key in allAssets {
            print("📱 Loading asset: \(key)")
            
            let category: AssetCategory
            if introAssets.contains(key) {
                category = .introEnvironment
            } else if attackAssets.contains(key) {
                category = .attackCancerEnvironment
            } else if labAssets.contains(key) {
                category = .labEnvironment
            } else {
                // Default case, should not happen
                print("⚠️ Unknown asset category for key: \(key)")
                continue
            }
            
            do {
                _ = try await assetLoadingManager.loadAsset(withName: key, category: category)
                completedAssets += 1
                let progress = Float(completedAssets) / Float(allAssets.count)
                print("✅ Loaded \(key) - Progress: \(progress)")
            } catch {
                print("❌ Failed to load \(key): \(error)")
                // Use the generic error here
                assetLoadingManager.loadingState = .error(AppError.genericLoadingError)
                return // Exit the function on error
            }
        }
        print("✅ prepareIntroPhase completed")
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+ADC.swift
```swift
//
//  AttackCancerViewModel+ADC.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 05.02.25.
//

import SwiftUI
import RealityKit
import RealityKitContent

extension AttackCancerViewModel {
    // MARK: - ADC Setup
    func setADCTemplate(_ template: Entity, dataModel: ADCDataModel) {
        print("\n🎯 Setting up ADC Template")
        print("- Template entity: \(template.name)")
        print("- Antibody Color: \(String(describing: dataModel.selectedADCAntibody ?? -1))")
        print("- Linker Color: \(String(describing: dataModel.selectedLinkerType ?? -1))")
        print("- Payload Color: \(String(describing: dataModel.selectedPayloadType ?? -1))")
        
        // Find and apply antibody color
        if let antibody = template.findModelEntity(named: "ADC_complex") {
            if let antibodyColor = dataModel.selectedADCAntibody,
               let modelComponent = antibody.components[ModelComponent.self] {
                if modelComponent.materials.first is ShaderGraphMaterial {
                    antibody.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[antibodyColor])
                    #if DEBUG
                    print("✅ Applied antibody color: \(antibodyColor)")
                    #endif
                }
            }
        }
        
        // Find and apply linker colors (all 4)
        for i in 1...4 {
            let offsetName = "linker0\(i)_offset"
            if let linker = template.findModelEntity(named: "linker", from: offsetName) {
                if let linkerColor = dataModel.selectedLinkerType {
                    // old PBR shader
                    linker.updatePBRDiffuseColor(.adc[linkerColor])
                    // new shaderGraph material
                    linker.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[linkerColor])
                    #if DEBUG
                    print("✅ Applied linker color \(linkerColor) to \(offsetName)")
                    #endif
                }
            }
        }
        
        // Find and apply payload colors (all 4 sets of inner/outer)
        for i in 1...4 {
            let offsetName = "linker0\(i)_offset"
            if let inner = template.findModelEntity(named: "InnerSphere", from: offsetName),
               let outer = template.findModelEntity(named: "OuterSphere", from: offsetName) {
                if let payloadColor = dataModel.selectedPayloadType {
                    inner.updatePBREmissiveColor(.adcEmissive[payloadColor])
                    outer.updateShaderGraphColor(parameterName: "glowColor", color: .adc[payloadColor])
                    #if DEBUG
                    print("✅ Applied payload color \(payloadColor) to \(offsetName)")
                    #endif
                }
            }
        }
        
        adcTemplate = template
        print("✅ ADC template stored in gameState")
    }
    
    // MARK: - ADC Spawning
    func spawnADC(from position: SIMD3<Float>, targetPoint: Entity, forCellID cellID: Int) async {
        guard let template = adcTemplate,
              let root = rootEntity else {
            return
        }
        
        totalADCsDeployed += 1
        #if DEBUG
        print("\n=== Spawning Natural ADC ===")
        print("Start World Position: \(position)")
        print("Target World Position: \(targetPoint.position(relativeTo: nil))")
        print("Target Cell ID: \(cellID)")
        print("✅ ADC #\(totalADCsDeployed) Launched (Total Taps: \(totalTaps))")
        #endif
        
        // Set the flag for first ADC fired
        if !hasFirstADCBeenFired {
            hasFirstADCBeenFired = true
        }
        
        // Clone the template (colors will be cloned with it)
        let adc = template.clone(recursive: true)
        
        // Set up collision so that the ADC is recognized as 'adc' by cancer cells
        let shape = ShapeResource.generateSphere(radius: 0.069)
        let collision = CollisionComponent(
            shapes: [shape],
            filter: .init(group: .adc, mask: .cancerCell)
        )
        adc.components.set(collision)

        // New: Add a PhysicsBodyComponent so the ADC gets picked up by the physics simulation
        // let physicsBody = PhysicsBodyComponent(shapes: [shape], mass: 0.0, mode: .kinematic)
        // adc.components.set(physicsBody)
        
        // Update ADCComponent properties
        guard var adcComponent = adc.components[ADCComponent.self] else { return }
        adcComponent.targetCellID = cellID
        adcComponent.startWorldPosition = position  // Use the hand position
        adcComponent.proteinSpinSpeed = Float.random(in: 8.0...10.0)  // Set random spin speed per instance
        adc.components[ADCComponent.self] = adcComponent
        
        // Set initial position
        adc.position = position
        
        // Add to scene
        root.addChild(adc)
        
        // Start movement
        ADCMovementSystem.startMovement(entity: adc, from: position, to: targetPoint)
    }
    
    /// Spawns an ADC without a specific target, moving in the direction the user is looking
    func spawnUntargetedADC(from position: SIMD3<Float>) async {
        guard let template = adcTemplate,
              let root = rootEntity else {
            print("❌ Failed to spawn untargeted ADC: missing template or root")
            return
        }
        
        // Create headPosition entity with random positioning
        let headPosition = Entity()
        headPosition.name = "headPosition"
        
        // Random offsets
        let randomX = Float.random(in: -2.0...2.0)
        let randomY = Float.random(in: 1.0...2.5)
        let randomZ = Float.random(in: -7.0...(-6.5))

        // Compensate for root entity's Z offset
        let adjustedZ = randomZ + 1.0  // Add 1.0 to compensate for headTrackingRoot's -1.0 offset

        // Set position with compensation for root offset
        headPosition.position = SIMD3<Float>(randomX, randomY, adjustedZ)
        
        // Create positioning component
        // let positioning = PositioningComponent(
        //     offsetX: randomX,
        //     offsetY: randomY,
        //     offsetZ: randomZ
        // )
        
        // Create attachment point and mark as occupied
        var attachPoint = AttachmentPoint()
        attachPoint.isOccupied = true
        attachPoint.isUntargeted = true
        
        // Add components using proper lifecycle management
        
        // try await headPosition.components.set(positioning)
        headPosition.components.set(attachPoint)
       
        // Add headPosition to the scene's root to avoid ADC root offset
        print("DEBUG: Root entity details:")
        print("- Name: \(root.name)")
        print("- World position: \(root.position(relativeTo: nil))")
        print("- Local position: \(root.position)")
        
        root.addChild(headPosition)
        
        print("DEBUG: HeadPosition target details:")
        print("- Local position set: \(headPosition.position)")
        print("- World position after add: \(headPosition.position(relativeTo: nil))")
        print("- Parent entity: \(headPosition.parent?.name ?? "none")")
        
        totalADCsDeployed += 1
        #if DEBUG
        print("\n=== Spawning Untargeted ADC ===")
        print("Start World Position: \(position)")
        print("Target World Position: \(headPosition.position(relativeTo: nil))")
        print("✅ ADC #\(totalADCsDeployed) Launched (Total Taps: \(totalTaps))")
        #endif
        
        // Set the flag for first ADC fired
        if !hasFirstADCBeenFired {
            hasFirstADCBeenFired = true
        }
        
        // Clone the template (colors will be cloned with it)
        let adc = template.clone(recursive: true)
        
        // Create ADC components
        let shape = ShapeResource.generateSphere(radius: 0.069)
        let collision = CollisionComponent(
            shapes: [shape],
            filter: .init(group: .adc, mask: .cancerCell)
        )
        
        // Set up ADC component
        guard var adcComponent = adc.components[ADCComponent.self] else { return }
        adcComponent.state = .moving  // Use moving state instead of seeking
        adcComponent.startWorldPosition = position
        adcComponent.proteinSpinSpeed = Float.random(in: 8.0...10.0)
        adcComponent.speedFactor = Float.random(in: ADCMovementSystem.speedRange)
        adcComponent.arcHeightFactor = Float.random(in: ADCMovementSystem.arcHeightRange)
        
        // Add components using proper lifecycle management
        
        adc.components.set(collision)
        adc.components.set(adcComponent)
     
        
        // Set initial position
        adc.position = position
        
        // Add to scene
        root.addChild(adc)
        
        // Start movement using headPosition entity as target
        ADCMovementSystem.startMovement(entity: adc, from: position, to: headPosition)
        
        print("✅ Untargeted ADC spawned successfully")
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+Audio.swift
```swift
import SwiftUI
import RealityKitContent
import RealityKit

// MARK: - Audio Sequence Types
enum AudioSequenceType {
    case ending
    case victory
}

extension AttackCancerViewModel {
    // MARK: - Audio Setup
    
    /// Toggles the visibility of the audio debug cone
    func toggleAudioDebugVisuals() {
        isAudioDebugVisible.toggle()
        audioDebugCone?.isEnabled = isAudioDebugVisible
        Logger.audio("Audio debug visuals: \(isAudioDebugVisible ? "shown" : "hidden")")
    }
    
    /// Creates a debug cone to visualize the audio source direction
    func createAudioDebugCone() -> ModelEntity {
        // Create a cone mesh with specified dimensions
        let cone = MeshResource.generateCone(height: 0.2, radius: 0.1)
        
        // Create a red material
        var material = PhysicallyBasedMaterial()
        material.baseColor = .init(tint: .red, texture: nil)
        material.roughness = 0.8
        material.metallic = 0.0
        
        // Create the model entity
        let debugCone = ModelEntity(mesh: cone, materials: [material])
        
        // Set transform
        debugCone.transform = Transform(
            scale: .one,
            rotation: simd_quatf(angle: .pi / 2, axis: [1, 0, 0]) * // -90 degrees around X
                     simd_quatf(angle: .pi, axis: [0, 1, 0]),      // 180 degrees around Y
            translation: [0, 0, -0.1]
        )
        
        // Initially disabled
        debugCone.isEnabled = false
        
        return debugCone
    }
    
    func prepareEndGameAudio() async {
        Logger.audio("\n=== Preparing end game audio ===\n")
        
        // First verify we can find our root entities
        guard let root = appModel.gameState.rootEntity else {
            Logger.error("❌ Cannot prepare end game audio - root entity not found")
            return
        }
        Logger.audio("✅ Found root entity: \(root.name)")
        
        guard let headTrackingRoot = root.findEntity(named: "headTrackingRoot") else {
            Logger.error("❌ Cannot prepare end game audio - headTrackingRoot not found")
            return
        }
        Logger.audio("✅ Found headTrackingRoot at position: \(headTrackingRoot.position)")
        
        // Create ending sequence source
        let endingSource = Entity()
        endingSource.name = "EndingSequenceSource"
        endingSource.position = SIMD3<Float>(0, 0, 0.75)
        endingSource.components.set(SpatialAudioComponent(gain: 1.0, directivity: .beam(focus: 1.0)))
        
        // Create and add debug cone for ending sequence
        let endingDebugCone = createAudioDebugCone()
        endingSource.addChild(endingDebugCone)
        self.audioDebugCone = endingDebugCone
        Logger.audio("Added debug cone to ending sequence source")
        
        headTrackingRoot.addChild(endingSource)
        self.endingSequenceAudioSource = endingSource
        Logger.audio("✅ Created ending sequence source")
        
        // Create victory sequence source
        let victorySource = Entity()
        victorySource.name = "VictorySequenceSource"
        victorySource.position = SIMD3<Float>(0.5, 0, 0.75)  // Offset to the right
        victorySource.components.set(SpatialAudioComponent(gain: 1.0, directivity: .beam(focus: 1.0)))
        headTrackingRoot.addChild(victorySource)
        self.victorySequenceAudioSource = victorySource
        Logger.audio("✅ Created victory sequence source")
        
        // Load all audio resources
        do {
            // Load tone_cross
            Logger.audio("Attempting to load tone_cross_wav...")
            let toneCrossResource = try await AudioFileResource(named: "/Root/tone_cross_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["tone_cross"] = toneCrossResource
            Logger.audio("✅ Successfully loaded tone_cross")
            
            // Load heartbeat
            let heartbeatResource = try await AudioFileResource(named: "/Root/heartbeat_progressive_slow_to_fast_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["heartbeat"] = heartbeatResource
            Logger.audio("✅ Successfully loaded heartbeat")
            
            // Load smashed
            let smashedResource = try await AudioFileResource(named: "/Root/smashed_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["smashed"] = smashedResource
            Logger.audio("✅ Successfully loaded smashed")
            
            // Load magic_zing
            let magicZingResource = try await AudioFileResource(named: "/Root/magic_zing_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["magic_zing"] = magicZingResource
            Logger.audio("✅ Successfully loaded magic_zing")
            
            // Load hope meter restored
            let hopeRestoredResource = try await AudioFileResource(named: "/Root/Hope_Meter_Restored_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["hope_restored"] = hopeRestoredResource
            Logger.audio("✅ Successfully loaded hope_restored")
            
            Logger.audio("✅ End game audio fully prepared with \(loadedAudioResources.count) sounds")
        } catch {
            Logger.error("❌ Failed to load audio resources: \(error.localizedDescription)")
            Logger.error("Error details: \(error)")
        }
    }
    
    // MARK: - Audio Playback
    func playEndSound(_ soundName: String, forSequence sequenceType: AudioSequenceType) async {
        Logger.audio("\n=== Playing sound: \(soundName) for sequence: \(sequenceType) ===\n")
        
        let (audioSource, controller) = switch sequenceType {
        case .ending:
            (endingSequenceAudioSource, endingSequenceController)
        case .victory:
            (victorySequenceAudioSource, victorySequenceController)
        }
        
        guard let source = audioSource,
              let resource = loadedAudioResources[soundName] else {
            Logger.error("❌ Required resources not found for \(soundName)")
            return
        }
        
        // Stop current controller if it exists
        controller?.stop()
        
        // Create new controller and store it
        let newController = source.prepareAudio(resource)
        newController.play()
        
        // Store the controller in the appropriate property
        switch sequenceType {
        case .ending:
            endingSequenceController = newController
        case .victory:
            victorySequenceController = newController
        }
        
        Logger.audio("✅ Started playing \(soundName) for \(sequenceType)")
    }
    
    /// Plays a sequence of audio elements with specified pauses between them
    /// - Parameters:
    ///   - sequence: Array of tuples containing the sound name and the pause duration
    ///   - type: The type of sequence being played (ending or victory)
    func playAudioSequence(_ sequence: [(sound: String, pauseAfter: TimeInterval)], type: AudioSequenceType) async {
        Logger.audio("\n=== Starting \(type) sequence with \(sequence.count) elements ===\n")
        
        for (index, element) in sequence.enumerated() {
            await playEndSound(element.sound, forSequence: type)
            
            if element.pauseAfter > 0 {
                Logger.audio("Pausing for \(element.pauseAfter) seconds after sound \(element.sound)")
                try? await Task.sleep(for: .seconds(element.pauseAfter))
            }
            
            Logger.audio("Completed playing sequence element \(index + 1)/\(sequence.count)")
        }
        
        Logger.audio("✅ Audio sequence completed")
    }
    
    /// Play hope_restored, wait 2 seconds, then play tone_cross
    func playVictorySequence() async {
        await playAudioSequence([
            ("hope_restored", 2.0),
            ("tone_cross", 0.0)
        ], type: .victory)
    }
    
    /// Play heartbeat, wait 19 seconds, then play magic_zing
    func playEndingSequence() async {
        await playAudioSequence([
            ("heartbeat", 19.0),
            ("magic_zing", 0.0)
        ], type: .ending)
    }
}
```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import Combine

@Observable
@MainActor
final class AttackCancerViewModel {
    // MARK: - State Tracking
    var isRootSetupComplete: Bool = false
    var isEnvironmentSetupComplete: Bool = false
    var shouldUpdateHeadPosition: Bool = false
    var isHeadTrackingRootReady: Bool = false
    var isPositioningComplete: Bool = false
    
    // Track when we're fully ready for interactions
    var isReadyForInteraction: Bool {
        isRootSetupComplete && 
        isEnvironmentSetupComplete && 
        isHeadTrackingRootReady
    }
    
    // MARK: - Collision Filters
    static var adcFilter: CollisionFilter {
        let adcMask = CollisionGroup.all.subtracting(adcGroup)
        return CollisionFilter(group: adcGroup, mask: adcMask)
    }
    
    static var cancerCellFilter: CollisionFilter {
        let cellMask = CollisionGroup.all.subtracting(cancerCellGroup)
        return CollisionFilter(group: cancerCellGroup, mask: cellMask)
    }
    
    static var microscopeFilter: CollisionFilter {
        let microscopeMask = CollisionGroup.all
        return CollisionFilter(group: microscopeGroup, mask: microscopeMask)
    }

    // MARK: - Collision Groups
    static let adcGroup = CollisionGroup(rawValue: 1 << 0)
    static let cancerCellGroup = CollisionGroup(rawValue: 1 << 1)
    static let microscopeGroup = CollisionGroup(rawValue: 1 << 2)
    
    // MARK: - Collision Properties
    var debounce: [UnorderedPair<Entity>: TimeInterval] = [:]
    let debounceThreshold: TimeInterval = 0.1
    
    // MARK: - Properties
    var storedAttachments: RealityViewAttachments?
    var rootEntity: Entity?
    var scene: RealityKit.Scene?
    var handTrackedEntity: Entity?
    var isSetupComplete = false
    var environmentLoaded = false
    var tutorialCancerCell: Entity?
    var testFireCell: Entity?
    var tutorialComplete = false
    var isTestFireActive = false
    var testFireComplete = false
    var readyToStartGame = false

    // MARK: - Audio Debug Properties
    var audioDebugCone: ModelEntity?
    var isAudioDebugVisible: Bool = false

    var shouldPlayStartButtonVO: Bool {
        readyToStartGame && tutorialComplete
    }

    // MARK: - Properties for Audio
    var endGameAudioSource: Entity?
    var endGameAudioResource: AudioFileResource?
    var endGameAudioController: AudioPlaybackController?
    var loadedAudioResources: [String: AudioFileResource] = [:]
    
    // MARK: - Sequence-specific Audio Properties
    var endingSequenceAudioSource: Entity?
    var victorySequenceAudioSource: Entity?
    var endingSequenceController: AudioPlaybackController?
    var victorySequenceController: AudioPlaybackController?
    
    // MARK: - Transition Properties
    var isTransitioningOut = false
    var transitionOpacity: Float = 1.0
    
    // Store subscription to prevent deallocation
    internal var subscription: Cancellable?
    
    // Dependencies
    var appModel: AppModel!
    var handTracking: HandTrackingManager!
    
    // MARK: - Game Stats
    var hitProbability: Double = 0.3
    var maxCancerCells: Int = 25
    var cellsDestroyed: Int = 0
    var totalADCsDeployed: Int = 0
    var totalTaps: Int = 0
    var totalHits: Int = 0
    
    // MARK: - Hope Meter
    let hopeMeterDuration: TimeInterval = 30
    var hopeMeterTimeLeft: TimeInterval
    var isHopeMeterRunning = false
    
    var isGameActive: Bool {
        // Only consider the game active if both tutorial is complete AND hope meter is running
        tutorialComplete && testFireComplete && isHopeMeterRunning
    }
    
    // MARK: CELL PROPERTIES
    // ADC Properties
    var adcTemplate: Entity?
    var hasFirstADCBeenFired = false
    
    // Cell State Properties
    var cellParameters: [CancerCellParameters] = []
    
    // Pool Properties
    var availableCells: [Entity] = []
    var activeCells: [Entity] = []
    
    // Add after other private properties
    let tutorialADCDelays: [TimeInterval] = [
        2.0,  // First ADC at 2s
        1.9,  // Second ADC at 3.9s
        1.9,  // Third ADC at 5.8s
        1.9,  // Fourth ADC at 7.7s
        1.9,  // Fifth ADC at 9.6s
        1.9,  // Sixth ADC at 11.5s
        1.9,  // Seventh ADC at 13.4s
        1.9,  // Eighth ADC at 15.3s
        1.9,  // Ninth ADC at 17.2s
        1.8   // Tenth ADC at 19s
    ]
    
    // Root entity for the instructions view
    var instructionsRootEntity: Entity?
    
    // NEW: Store a reference to the CancerCellSystem.
    var cancerCellSystem: CancerCellSystem?
    
    // MARK: - Initialization
    init() {
        // Initialize handTrackedEntity
        self.handTrackedEntity = {
            let handAnchor = AnchorEntity(.hand(.left, location: .aboveHand))
            return handAnchor
        }()
        
        // Initialize hopeMeterTimeLeft
        self.hopeMeterTimeLeft = hopeMeterDuration
    }
    
    // MARK: - Cleanup and Reset Functions
    
    /// Tracks the current state of cleanup operations
    enum CleanupState {
        case none        // No cleanup in progress
        case gameOnly    // tearDownGame() in progress/complete
        case complete    // full cleanup() in progress/complete
    }
    
    /// Current cleanup state
    var cleanupState: CleanupState = .none
    
    /// Flag to prevent concurrent cleanup operations
    private var isCleaningUp = false

    /// Tears down the current game session's content while preserving the core system.
    /// Use this for cleaning up game-specific content without full system shutdown.
    ///
    /// Responsibilities:
    /// - Removes game entities (cells, ADCs)
    /// - Cleans up VO content
    /// - Resets positioning components
    /// - Cancels game-specific subscriptions
    /// - Does NOT clear core system references
    /// - Does NOT remove root entities
    /// - Does NOT affect app model connections
    ///
    /// Call this when:
    /// - Transitioning between game phases
    /// - Ending a game session
    /// - Preparing for a new game session
    func tearDownGame() async {
        // Prevent duplicate teardown
        guard cleanupState == .none else {
            Logger.debug("⚠️ Tear down already in progress or completed: \(cleanupState)")
            return
        }
        
        cleanupState = .gameOnly
        print("\n=== Tearing Down Game [Detailed] ===")
        print("📊 Initial State:")
        print("  - Hope Meter Running: \(isHopeMeterRunning)")
        print("  - Tutorial Started: \(appModel.isTutorialStarted)")
        print("  - Current Phase: \(appModel.currentPhase)")
        print("  - Test Fire Active: \(isTestFireActive)")
        
        // Stop systems first
        appModel.stopHopeMeter()
        subscription?.cancel()
        subscription = nil
        
        // Stop any playing audio
        Logger.audio("Stopping end game audio playback...")
        endGameAudioController?.stop()
        endGameAudioController = nil
        if let audioSource = endGameAudioSource {
            audioSource.removeFromParent()
            Logger.audio("Removed audio source from parent")
        }
        
        // Clear gameplay state
        cellParameters.removeAll()
        
        // Clear debounce dictionary
        debounce.removeAll()

        // Remove gameplay entities
        if let root = rootEntity {
            print("\n🔍 Examining root entity: \(root.name)")
            
            // Remove cancer cells
            var removedCells = 0
            for i in 0..<maxCancerCells {
                if let cell = root.findEntity(named: "cancer_cell_\(i)") {
                    cell.removeFromParent()
                    removedCells += 1
                }
            }
            // Remove test fire cell if it exists
            if let testFireCell = root.findEntity(named: "cancer_cell_555") {
                testFireCell.removeFromParent()
                removedCells += 1
            }
            print("🗑️ Removed cancer cells: \(removedCells)")
            
            // Remove ADCs
            if let scene = root.scene {
                let adcQuery = EntityQuery(where: .has(ADCComponent.self))
                scene.performQuery(adcQuery).forEach { entity in
                    entity.removeFromParent()
                }
            }
            
            // Remove any VO entities from headTrackingRoot
            if let VO_parent = root.findEntity(named: "headTrackingRoot") {
                Logger.info("\n🎯 Cleaning up head tracking root")
                // Remove all child entities
                VO_parent.children.forEach { child in
                    child.removeFromParent()
                }
                
                // Reset positioning component to clean state
                if var positioningComponent = VO_parent.components[PositioningComponent.self] {
                    Logger.info("├─ Resetting PositioningComponent state")
                    positioningComponent.needsPositioning = false
                    positioningComponent.shouldAnimate = false
                    positioningComponent.animationDuration = 0.0
                    VO_parent.components[PositioningComponent.self] = positioningComponent
                }
                
                Logger.info("└─ Head tracking cleanup complete")
            }
        }
        
        print("✅ Game tear down complete\n")
    }

    /// Performs complete system cleanup and shutdown.
    /// Use this for full system teardown when leaving the game entirely.
    ///
    /// Responsibilities:
    /// - Performs game teardown first
    /// - Removes all entities including root
    /// - Clears all system references
    /// - Resets all flags to initial state
    /// - Prepares system for complete shutdown
    ///
    /// Call this when:
    /// - Exiting the game completely
    /// - Transitioning to a different app section
    /// - Requiring complete system reset
    func cleanup() async {
        guard !isCleaningUp else {
            Logger.debug("⚠️ Cleanup already in progress")
            return
        }
        guard cleanupState != .complete else {
            print("⚠️ Cleanup already completed")
            return
        }
        
        isCleaningUp = true
        print("\n=== Starting AttackCancerViewModel Cleanup ===")
        print("Current Phase: \(appModel.currentPhase)")
        print("Is Transitioning: \(appModel.isTransitioning)")
        
        // First tear down the game if not already done
        if cleanupState != .gameOnly {
            await tearDownGame()
        }
        
        // Clear entity references
        if let root = rootEntity {
            print("🗑️ Removing root entity")
            root.removeFromParent()
        }
        
        // Clear all references
        rootEntity = nil
        scene = nil
        tutorialCancerCell = nil
        instructionsRootEntity = nil
        adcTemplate = nil
        
        // Clear audio system references
        Logger.audio("Clearing audio system references...")
        endGameAudioSource = nil
        endGameAudioResource = nil
        endGameAudioController = nil
        
        // Reset flags
        isSetupComplete = false
        hasFirstADCBeenFired = false
        environmentLoaded = false
        isPositioningComplete = false
        
        cleanupState = .complete
        isCleaningUp = false
        print("✅ Completed AttackCancerViewModel cleanup\n")
    }

    // NEW: Reset function to be called at the start of a new game session.
    func resetCleanupForNewSession() {
        // Reset cleanup flags and other related state if needed.
        cleanupState = .none
        isCleaningUp = false
        // Optionally, reinitialize other game state if necessary.
        // For example, you might want to clear cell parameters and reset counters—
        // however, ensure that this reset does not conflict with the
        // app's intended state management.
        print("🔄 AttackCancerViewModel: Cleanup state has been reset for new session.")
    }

    func findCancerCell(withID id: Int) -> Entity? {
        // First check if ID is valid
        guard id >= 0 && id < cellParameters.count else { return nil }
        
        guard let root = rootEntity else { return nil }
        
        // Find the cell entity
        if let cell = root.findEntity(named: "cancer_cell_\(id)") {
            // Validate it has correct state component
            guard let stateComponent = cell.components[CancerCellStateComponent.self],
                  stateComponent.parameters.cellID == id else {
                print("⚠️ Found cell \(id) but state component mismatch")
                return nil
            }
            return cell
        }
        
        print("⚠️ Could not find cancer cell with ID: \(id)")
        return nil
    }

    // MARK: FADE OUT SCENE
    /// Fades out the entire scene gracefully
    /// - Returns: Void
    @MainActor
    func fadeOutScene() async {
        Logger.info("🎬 Starting scene fade out")
        
        guard let root = rootEntity else {
            Logger.debug("⚠️ No root entity found for fade out")
            return
        }
        
        await root.fadeOpacity(
            to: 0.0,
            duration: 2.0,
            timing: .easeInOut,
            waitForCompletion: true
        )
        
        Logger.info("✨ Scene fade out complete")
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+GameStats.swift
```swift
import SwiftUI
import RealityKitContent
import RealityKit

extension AttackCancerViewModel {
    // MARK: - Game Methods

    /// Resets game state variables to their initial values without affecting entities or scene content.
    /// Use this when you want to restart the game state while keeping the current scene setup.
    ///
    /// Responsibilities:
    /// - Resets game statistics (scores, counters)
    /// - Resets state flags (tutorial state, game phase)
    /// - Resets head positioning state
    /// - Does NOT modify any entities or scene content
    /// - Does NOT affect system connections or subscriptions
    ///
    /// Call this when:
    /// - Starting a new game session
    /// - Restarting after game over
    /// - Resetting tutorial state
    func resetGameState() {
        Logger.debug("""
        
        🔄 Resetting Game State
        ├─ Cells Destroyed: \(cellsDestroyed) → 0
        ├─ Total ADCs: \(totalADCsDeployed) → 0
        ├─ Total Taps: \(totalTaps) → 0
        ├─ Total Hits: \(totalHits) → 0
        └─ Head Positioning: Resetting tracking state
        """)

        cellsDestroyed = 0
        totalADCsDeployed = 0
        totalTaps = 0
        totalHits = 0
        
        hopeMeterTimeLeft = hopeMeterDuration
        isHopeMeterRunning = false
        hasFirstADCBeenFired = false

        // Reset all cell parameters
        for i in 0..<cellParameters.count {
            cellParameters[i].hitCount = 0
            cellParameters[i].isDestroyed = false
        }
        
        // Reset head positioning state
        isRootSetupComplete = false
        isEnvironmentSetupComplete = false
        isHeadTrackingRootReady = false
        shouldUpdateHeadPosition = false
        
        Logger.debug("""
        
        🎯 Head Positioning Reset Complete
        ├─ Root Setup: \(isRootSetupComplete ? "✅" : "❌")
        ├─ Environment: \(isEnvironmentSetupComplete ? "✅" : "❌")
        ├─ Head Tracking: \(isHeadTrackingRootReady ? "✅" : "❌")
        └─ Update Pending: \(shouldUpdateHeadPosition ? "✅" : "❌")
        """)
        
        // Reset hope meter
        hopeMeterTimeLeft = hopeMeterDuration
        isHopeMeterRunning = false
        
        // Reset tutorial state to match first play
        tutorialComplete = false
        appModel.isTutorialStarted = false  // This will trigger the tutorial sequence
        isTestFireActive = false
        testFireComplete = false
        readyToStartGame = false
        isSetupComplete = false
        
        appModel.currentPhase = .playing
        appModel.isInstructionsWindowOpen = true
        appModel.isHopeMeterUtilityWindowOpen = false  // Let the tutorial sequence open this at 24s

        print("🔄 Reset tutorial state: isTutorialStarted: \(appModel.isTutorialStarted), tutorialComplete: \(tutorialComplete), isTestFireActive: \(isTestFireActive), readyToStartGame: \(readyToStartGame)")

    }
    
    // MARK: - ADC Tracking
    func incrementADCsDeployed() {
        totalADCsDeployed += 1
    }
    
    var score: Int {
        // Base score from destroyed cells
        let baseScore = cellsDestroyed * 100
        
        // Efficiency penalty based on ADCs used
        let efficiency = totalADCsDeployed > 0 ? Float(cellsDestroyed) / Float(totalADCsDeployed) : 0
        let efficiencyBonus = Int(efficiency * 50)
        
        return baseScore + efficiencyBonus
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+HandInteraction.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

extension AttackCancerViewModel {
    // MARK: - Tap Handling
    func handleTap(on entity: Entity, location: SIMD3<Float>, in scene: RealityKit.Scene?) async {
        print("\n=== Tapped Entity ===")
        print("Entity name: \(entity.name)")
//        appModel.assetLoadingManager.inspectEntityHierarchy(entity)
        
        // Get pinch distances for both hands to determine which hand tapped
        let leftPinchDistance = handTracking.getPinchDistance(.left) ?? Float.infinity
        let rightPinchDistance = handTracking.getPinchDistance(.right) ?? Float.infinity
        
        // Determine which hand's position to use
        let handPosition: SIMD3<Float>?
        if leftPinchDistance < rightPinchDistance {
            handPosition = handTracking.getFingerPosition(.left)
            print("Left hand tap detected")
        } else {
            handPosition = handTracking.getFingerPosition(.right)
            print("Right hand tap detected")
        }
        
        // Ensure we have a valid scene
        guard let scene = scene else {
            print("No scene available")
            return
        }
        
        // Use hand position if available, otherwise use provided location
        let spawnPosition = handPosition ?? location
        
        // Check if we can target a cancer cell
        if let stateComponent = entity.components[CancerCellStateComponent.self],
           let cellID = stateComponent.parameters.cellID {
            print("Found cancer cell with ID: \(cellID)")
            
            // Use the new approach-aware getAvailablePoint
            if let attachPoint = AttachmentSystem.getAvailablePoint(in: scene, forCellID: cellID, approachPosition: spawnPosition) {
                print("Found attach point: \(attachPoint.name)")
                AttachmentSystem.markPointAsOccupied(attachPoint)
                await spawnADC(from: spawnPosition, targetPoint: attachPoint, forCellID: cellID)
            } else {
                print("No available attach point found")
                await spawnUntargetedADC(from: spawnPosition)
            }
        } else {
            // No valid cancer cell target - spawn untargeted ADC
        if Double.random(in: 0..<1) < hitProbability {
            print("Spawning untargeted ADC based on random chance")
            await spawnUntargetedADC(from: spawnPosition)
        } else {
            print("Skipping untargeted ADC spawn due to random chance")
        }
        }
    }

    func setupHandTracking(in content: RealityViewContent, attachments: RealityViewAttachments? = nil) {
        // Add the hand tracking content entity which includes the debug spheres
        content.add(appModel.trackingManager.handTrackingManager.setupContentEntity())
        
        // Create a separate anchor for the HopeMeter UI
//        let uiAnchor = AnchorEntity(.hand(.left, location: .aboveHand))
//        content.add(uiAnchor)
        
        // if let attachmentEntity = attachments.entity(for: "HopeMeter") {
        //     attachmentEntity.components[BillboardComponent.self] = BillboardComponent()
        //     attachmentEntity.scale *= 0.6
        //     attachmentEntity.position.z -= 0.02
        //     uiAnchor.addChild(attachmentEntity)
        // }
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+Collisions.swift
```swift
//
//  AttackCancerViewModel+Collisions.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 05.02.25.
//

import SwiftUI
import RealityKit
import RealityKitContent
import Combine

extension AttackCancerViewModel {
    // MARK: - Collision Setup
    func setupCollisions(in entity: Entity) {
        print("setting up collisions in \(entity.name)")
        // Cancel any existing subscription first
        subscription?.cancel()
        subscription = nil
        
        if let scene = entity.scene {
            let query = EntityQuery(where: .has(BloodVesselWallComponent.self))
            let objectsToModify = scene.performQuery(query)
            
            for object in objectsToModify {
                if var collision = object.components[CollisionComponent.self] {
                    collision.filter.group = .cancerCell
                    collision.filter.mask = .cancerCell
                    object.components[CollisionComponent.self] = collision
                }
            }
            setupCollisionSubscription(with: scene)
        }
    }
    
    // MARK: - Collision Subscription
    func setupCollisionSubscription(with scene: RealityKit.Scene) {
        print("🎯 Setting up collision subscription")
        // Store the SceneEventSubscription
        subscription = scene.subscribe(to: CollisionEvents.Began.self) { [weak self] event in
        //    print("💥 Collision event received")
            guard let self = self else { return }
            self.handleCollisionBegan(event)
        }
        print("✅ Collision subscription set up")
    }
    
    // MARK: - Collision Handling
    func handleCollisionBegan(_ event: CollisionEvents.Began) {

        guard shouldHandleCollision(event) else { return }
        
        // Check for head-microscope collision - only play sound, no transition
        if hasHeadCollision(event) && hasMicroscopeCollision(event) {
            print("Head collision with microscope detected")
            Task {
                await appModel.transitionToPhase(.building)
            }
            return
        }
        
        let entities = UnorderedPair(event.entityA, event.entityB)
        
        // Handle ADC-to-cell collisions
        if let _ = entities.itemA.components[ADCComponent.self],
           let _ = entities.itemB.components[CancerCellStateComponent.self] {
            handleADCToCellCollision(adc: entities.itemA, cell: entities.itemB, collision: event)
        } else if let _ = entities.itemB.components[ADCComponent.self],
                  let _ = entities.itemA.components[CancerCellStateComponent.self] {
            handleADCToCellCollision(adc: entities.itemB, cell: entities.itemA, collision: event)
        }
    }
    
    @MainActor
    func handleADCToCellCollision(adc: Entity, cell: Entity, collision: CollisionEvents.Began) {
        print("\n=== ADC-Cell Collision ===")
        print("ADC: \(adc.name)")
        print("Cell: \(cell.name)")
        
        guard let stateComponent = cell.components[CancerCellStateComponent.self],
              let cellID = stateComponent.parameters.cellID,
              let parameters = cellParameters.first(where: { $0.cellID == cellID }) else {
            print("❌ Failed to handle collision - missing state component or parameters")
            return
        }
        
        // Check if this ADC is targeting this cell
        if let adcComponent = adc.components[ADCComponent.self],
           adcComponent.targetCellID == cellID {
            // Set the collision flag
            var updatedComponent = adcComponent
            updatedComponent.hasCollided = true
            adc.components[ADCComponent.self] = updatedComponent
            print("✅ ADC collision flag set for target cell \(cellID)")
        }
        
        print("💥 ADC hit cell \(cellID)")
        print("Current hit count: cellParameters \(parameters.hitCount)")
        print("Current hit count: StateComponent \(stateComponent.parameters.hitCount)")
        
        // Apply scaled physics impact if enabled
        if parameters.physicsEnabled {
            // Scale the collision impulse based on the cell's impact scale, then reduce to 10%
            let scaledImpulse = collision.impulse * parameters.impactScale * 0.1
            
            // Store impact values in parameters for reference (logging, analytics, etc.)
            parameters.linearVelocity = collision.impulseDirection * scaledImpulse
            
            // Calculate angular velocity based on impulse
            let randomRotation = SIMD3<Float>(
                Float.random(in: -1...1),
                Float.random(in: -1...1),
                Float.random(in: -1...1)
            )
            parameters.angularVelocity = normalize(randomRotation) * (scaledImpulse * 2.0)
            
            // NEW: actually apply the impulse to the cell's PhysicsMotionComponent
            var motion = cell.components[PhysicsMotionComponent.self] ?? PhysicsMotionComponent()
            motion.linearVelocity += collision.impulseDirection * scaledImpulse
            motion.angularVelocity += normalize(randomRotation) * (scaledImpulse * 2.0)
            cell.components.set(motion)
            
            if parameters.isTutorialCell {
                print("Tutorial cell impact - using scale: \(parameters.impactScale), impulse: \(scaledImpulse)")
            }
        }
    }
    
    private func shouldHandleCollision(_ collision: CollisionEvents.Began) -> Bool {
        // let entities = UnorderedPair(collision.entityA, collision.entityB)
        // let currentTime = Date().timeIntervalSinceReferenceDate
        
        // if let lastCollisionTime = debounce[entities] {
        //     if currentTime - lastCollisionTime < debounceThreshold {
        //         return false
        //     }
        // }
        
        // debounce[entities] = currentTime
        return true
    }
    
    private func hasHeadCollision(_ collision: CollisionEvents.Began) -> Bool {
        let entityA = collision.entityA
        let entityB = collision.entityB
        
        return entityA.name == "head" || entityB.name == "head"
    }
    
    private func hasMicroscopeCollision(_ collision: CollisionEvents.Began) -> Bool {
        let entityA = collision.entityA
        let entityB = collision.entityB
        
        let hasCollision = entityA.components[CollisionComponent.self]?.filter.group == .microscope ||
                          entityB.components[CollisionComponent.self]?.filter.group == .microscope
        
        return hasCollision
    }

    // @MainActor
    // func handleADCToCellCollision(adcEntity: Entity, cellEntity: Entity) async {
    //     guard let complexCell = cellEntity.findEntity(named: "cancerCell_complex"),
    //           let stateComponent = complexCell.components[CancerCellStateComponent.self],
    //           let cellID = stateComponent.parameters.cellID,
    //           let cellParams = cellParameters.first(where: { $0.cellID == cellID }),
    //           !cellParams.isDestroyed else {
    //         return
    //     }
        
    //     // Update hit count and check for destruction
    //     stateComponent.parameters.currentHits += 1
        
    //     if stateComponent.parameters.currentHits >= stateComponent.parameters.requiredHits {
    //         // Cell is destroyed
    //         cellParams.isDestroyed = true
    //         appModel.gameState.cellsDestroyed += 1
            
    //         // Recycle the cell back to the pool
    //         if let pool = cancerCellPool {
    //             await pool.recycleCell(cellEntity)
    //         }
            
    //         // Play destruction effects
    //         await playDestructionEffects(for: complexCell)
            
    //         Logger.info("🎯 Cell \(cellID) destroyed - Total destroyed: \(appModel.gameState.cellsDestroyed)")
    //     } else {
    //         // Cell was hit but not destroyed
    //         await playHitEffects(for: complexCell)
    //         Logger.info("🎯 Cell \(cellID) hit - Current hits: \(stateComponent.parameters.currentHits)/\(stateComponent.parameters.requiredHits)")
    //     }
    // }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+Notifications.swift
```swift
import SwiftUI
import RealityKitContent
import RealityKit

extension AttackCancerViewModel {

    // MARK: - Notification Setup (This is now just for the timeline)
    func handleTimelineNotification(for entity: Entity) {
        // Add debug logging
        print("📢 Timeline notification received from \(entity.name)")
        
        // Main thread execution for UI updates
        DispatchQueue.main.async {
            print("🎯 Opening hope meter utility window")
            if !self.appModel.isHopeMeterUtilityWindowOpen {
                self.appModel.isHopeMeterUtilityWindowOpen = true
            }
        }
    }

    // No longer needed: setupNotifications, handleCancerCellUpdate, notifyCellStateChanged, notifyGameStateChanged, notifyScoreChanged

    func checkGameConditions() {
        // Instead, use the global cellsDestroyed counter updated by the CancerCellSystem.
        let totalGameCells = cellParameters.filter { !$0.isTutorialCell }.count
        #if DEBUG
        print("\n=== Game Completion Check ===")
        print("  - Total game cells: \(totalGameCells)")
        print("  - Global destroyed cells: \(cellsDestroyed)")
        #endif
        
        if totalGameCells > 0, cellsDestroyed >= totalGameCells {
            print("✅✅✅ ALL GAME CELLS DESTROYED! Condition met!")
            Task { @MainActor in
                // Play the end game tone using our new function
                await self.playEndSound("magic_zing", forSequence: .victory) // Added forSequence parameter
                
                // Delay a second to give the user a moment to look forward
                try? await Task.sleep(for: .milliseconds(1000))
                print("🎯 All game cells destroyed - accelerating hope meter")
                await appModel.accelerateHopeMeterToCompletion()
                // Wait for an additional 2 seconds after accelerateHopeMeterToCompletion finishes.
                try? await Task.sleep(for: .milliseconds(2000))
                await appModel.transitionToPhase(.completed)
            }
        }
    }

    // Optionally, if there's an area where the hope meter runs out, add a call there as well:
    func hopeMeterDidRunOut() async {
        Task { @MainActor in
            // Play the end game tone when hope meter runs out
            Logger.audio("\n=== playing end sound ===\n")
            await self.playVictorySequence() // self.playEndSound("heartbeat") // Example of playing a different sound
            // Additional actions can be added here
        }
    }
    
    /// Monitor hope meter time and trigger events at specific thresholds
    func checkHopeMeterThresholds() {
        // Only check if the game is active
        guard isGameActive else { return }
        
        // Check for 19 seconds remaining
        if hopeMeterTimeLeft <= 19 && hopeMeterTimeLeft > 18 {
            Logger.audio("Hope meter at 19 seconds - triggering ending sequence")
            Task { @MainActor in
                await playEndingSequence()
            }
        }
    }
    
    /// Update hope meter time and check thresholds
    func updateHopeMeter() {
        guard isHopeMeterRunning else { return }
        
        // Update time left
        hopeMeterTimeLeft = max(0, hopeMeterTimeLeft - 1/60)  // Assuming 60fps updates
        
        // Check for specific time thresholds
        checkHopeMeterThresholds()
        
        // Check for hope meter running out
        if hopeMeterTimeLeft <= 0 {
            isHopeMeterRunning = false
            Task { @MainActor in
                await hopeMeterDidRunOut()
            }
        }
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+Pool.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

extension AttackCancerViewModel {
    // MARK: - Pool Management
    
    /// Initialize pool of cancer cells
    @MainActor
    func initializePool(in root: Entity, template: Entity) async -> Int {
        Logger.info("\n=== Initializing Cancer Cell Pool ===")
        
        for i in 0..<maxCancerCells {
            Logger.info("\n=== Pre-creating Cancer Cell \(i) ===")
            
            let cell = template.clone(recursive: true)
            cell.name = "cancer_cell_\(i)"
            
            if let complexCell = cell.findEntity(named: "cancerCell_complex") {
                complexCell.opacity = 0
                
                // Setup all the physical aspects first
                configureCellPosition(complexCell, preferFront: false)
                configureCellPhysics(complexCell)
                configureCellMovement(complexCell)
                setupCellIdentification(complexCell, cellID: i)
                
                // Create parameters on-demand
                let parameters = CancerCellParameters(cellID: i)
                Logger.info("Creating parameters for cell \(i)")
                Logger.info("Required hits: \(parameters.requiredHits)")
                cellParameters.append(parameters)
                Logger.info("Total parameters after append: \(cellParameters.count)")
                
                // Add state component with reference to parameters
                cell.components.set(CancerCellStateComponent(parameters: parameters))
                Logger.info("Added CancerCellStateComponent with parameters")
                
                // Add to root and setup attachment points
                cell.isEnabled = false  // Pool-specific: start disabled
                root.addChild(cell)
                setupAttachmentPoints(for: cell, complexCell: complexCell, cellID: i)

                Logger.info("\n=== Cancer Cell Pool \(i) Hierarchy ===")
                appModel.assetLoadingManager.inspectEntityHierarchy(cell)
                
                // Pool-specific: add to available cells
                availableCells.append(cell)
                Logger.info("✅ Successfully pre-created cell \(i)")
                Logger.info("📦 Stored in pool: Entity named '\(complexCell.name)' with parent '\(complexCell.parent?.name ?? "none")'")
            }
        }
        
        Logger.info("=== Pool Initialization Complete ===")
        Logger.info("Total cells pre-created: \(availableCells.count)")
        Logger.info("Total parameters created: \(cellParameters.count)")
        return availableCells.count
    }
    
    /// Get next available cell from pool
    @MainActor
    func acquireCell(preferFront: Bool = false) -> Entity? {
        guard let cell = availableCells.popLast() else { return nil }
        
        if let complexCell = cell.findEntity(named: "cancerCell_complex") {
            configureCellPosition(complexCell, preferFront: preferFront)
        }
        
        cell.isEnabled = true
        activeCells.append(cell)
        return cell
    }
    
    /// Reset pool to initial state
    @MainActor
    func resetPool() {
        // Move all active cells back to available
        activeCells.forEach { cell in
            cell.isEnabled = false
            if let complexCell = cell.findEntity(named: "cancerCell_complex") {
                complexCell.opacity = 0
            }
            availableCells.append(cell)
        }
        activeCells.removeAll()
        
        Logger.debug("Pool reset. All cells returned to available state")
    }
} 
```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+SceneSetup.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

extension AttackCancerViewModel {
    // MARK: - Setup Functions
    func setupRoot() -> Entity {
        // Reset the cleanup state for a new game session.
        cleanupState = .none
        
        // Reset state tracking
        isRootSetupComplete = false
        isEnvironmentSetupComplete = false
        isHeadTrackingRootReady = false
        isPositioningComplete = false
        
        Logger.info("🔄 Starting new game session: cleanupState and tracking states reset")
        Logger.info("📱 AttackCancerViewModel: Setting up root")
        
        let root = Entity()
        root.name = "AttackCancerRoot"
        // root.enableLargeRoomReverb()
        // root.position = AppModel.PositioningDefaults.playing.position
        
        // Keep headTrackingRoot setup - needed for AttackCancer functionality
        let headTrackingRoot = Entity()
        headTrackingRoot.position = AppModel.PositioningDefaults.playing.position
        headTrackingRoot.name = "headTrackingRoot"
        headTrackingRoot.components.set(PositioningComponent(
            offsetX: 0,
            offsetY: 0,
            offsetZ: -1.0,
            needsPositioning: false,
            shouldAnimate: false,
            animationDuration: 0.0
        ))
        root.addChild(headTrackingRoot)
        
        Logger.info("""
        
        ✅ Root Setup Complete
        ├─ Root Entity: \(root.name)
        ├─ HeadTracking Root: Added
        ├─ Position: \(headTrackingRoot.position(relativeTo: nil))
        └─ Positioning: Ready for explicit updates
        """)
        
        rootEntity = root
        isRootSetupComplete = true
        isHeadTrackingRootReady = true
        return root
    }
    
    func setupEnvironment(in root: Entity, attachments: RealityViewAttachments? = nil) async {
        Logger.info("\n🎯 Setting up AttackCancerView environment...")
        
        // prepare audio
        await prepareEndGameAudio()
        
        // IBL
        do {
            try await IBLUtility.addImageBasedLighting(to: root, imageName: "metro_noord_2k", intensity: 0.5)
        } catch {
            Logger.error("Failed to setup IBL: \(error)")
            isEnvironmentSetupComplete = false
            return
        }
        
        // Environment
        do {
            let environment = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "attack_cancer_environment",
                category: .attackCancerEnvironment
            )
            
            root.addChild(environment)
            
            Logger.info("setting up collisions")
            setupCollisions(in: environment)
            
            // Set up the scene
            scene = root.scene
            
            // Initialize cancer cell pool early
            do {
                Logger.info("🎯 Pre-initializing cancer cell pool...")
                let cancerCellTemplate = try await appModel.assetLoadingManager.instantiateAsset(
                    withName: "cancer_cell",
                    category: .cancerCell
                )
                
                let createdCount = await initializePool(in: root, template: cancerCellTemplate)
                Logger.info("✅ Pool pre-initialized with \(createdCount) cells")
            } catch {
                Logger.error("❌ Failed to pre-initialize cancer cell pool: \(error)")
            }

            // prepare audio
            await prepareEndGameAudio()
            
            Logger.info("""
            
            ✅ Environment Setup Complete
            ├─ IBL: Configured
            ├─ Environment: Loaded
            ├─ Collisions: Setup
            ├─ Cell Pool: Pre-initialized
            └─ End Game Audio: Loaded
            """)
            
            environmentLoaded = true
            isEnvironmentSetupComplete = true
        } catch {
            Logger.error("❌ Error setting up AttackCancerView environment: \(error)")
            environmentLoaded = false
            isEnvironmentSetupComplete = false
        }
        
        // NEW: Retrieve the shared CancerCellSystem (set via automatic registration)
        if let cancerSystem = CancerCellSystem.shared {
            self.cancerCellSystem = cancerSystem
            // Assign the onCellDestroyed closure.
            cancerSystem.onCellDestroyed = { [weak self] cellID in
                guard let self = self else { return }
                self.cellsDestroyed += 1
                Logger.info("Incremented cellsDestroyed to \(self.cellsDestroyed)")
                
                // Check if this was the test fire cell (ID 555)
                if cellID == 555 {
                    Logger.info("\nTest fire cell (ID 555) was destroyed")
                    testFireComplete = true
                    Logger.info(">>> Test fire complete - opening hope meter window...\n")

                    readyToStartGame = true
                    Logger.info(">>> Setting readyToStartGame to true...\n")

                    isTestFireActive = false
                    Logger.info(">>> Setting isTestFireActive to false...\n")
                } else {
                    // For other cells, check game conditions
                    self.checkGameConditions()
                }
            }
        }
    }
    
    // convenience function for Instructions screen
    func setupIBL(in root: Entity) async {
        do {
            try await IBLUtility.addImageBasedLighting(to: root, imageName: "metro_noord_2k", intensity: 0.5)
        } catch {
            Logger.error("Failed to setup IBL: \(error)")
        }
    }
    
    func startTutorial(in root: Entity, attachments: RealityViewAttachments? = nil) async {
        Logger.info("\n=== Starting Tutorial Sequence ===")
        
        // Ensure we have the scene reference
        scene = root.scene
        
        do {
            Logger.info("📱 Tutorial: Loading game start VO")
            let gameStartVO = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "game_start_vo",
                category: .attackCancerEnvironment
            )
            Logger.info("✅ Tutorial: Retrieved game start VO")
            
            if let VO_parent = root.findEntity(named: "headTrackingRoot") {
                Logger.info("🎯 Tutorial: Found VO parent")
                VO_parent.addChild(gameStartVO)
                root.addChild(VO_parent)
                Logger.info("✅ Tutorial: Added VO to scene")
                
                // Find tutorial cancer cell using existing pattern
                if let cell = gameStartVO.findEntity(named: "CancerCell_spawn") {
                    Logger.info("✅ Tutorial: Found tutorial cancer cell")
                    tutorialCancerCell = cell
                    
                    // Set up tutorial cell using ViewModel
                    setupTutorialCancerCell(cell)
                    Logger.info("✅ Tutorial: Cancer cell setup complete")
                    
                    // Start ADC firing sequence
                    Task {
                        await fireTutorialADCs(in: root)
                    }
                    Logger.info("✅ Tutorial: ADC sequence initiated")
                    isSetupComplete = true
                } else {
                    Logger.error("❌ Tutorial: Could not find CancerCell_spawn")
                }
            } else {
                Logger.error("❌ Tutorial: Could not find headTrackingRoot entity")
            }
        } catch {
            Logger.error("❌ Tutorial: Failed to load game start VO: \(error)")
        }
    }
    
    internal func playStartButtonVO(in root: Entity) async {
        Logger.info("\n=== Playing Start Button VO ===")
        do {
            let startButtonVO = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "PressStart_VO",
                category: .attackCancerEnvironment
            )
            Logger.info("✅ Retrieved start button VO")
            
            if let VO_parent = root.findEntity(named: "headTrackingRoot") {
                Logger.info("🎯 Found VO parent")
                VO_parent.addChild(startButtonVO)
                Logger.info("✅ Added start button VO to scene")
            } else {
                Logger.error("❌ Could not find headTrackingRoot entity")
            }
        } catch {
            Logger.error("❌ Failed to load start button VO: \(error)")
        }
    }
    
    private func fireTutorialADCs(in root: Entity, attachments: RealityViewAttachments? = nil) async {
        Logger.info("\n=== Starting Tutorial ADC Sequence ===")
        
        // Launch position is slightly offset to the right and above
        _ = SIMD3<Float>(0.25, 0.5, -0.25)
        
        // Calculate approach vector that points towards the cell from slightly in front
        // This ensures ADCs prefer antigens facing the player's view
        let approachPosition = SIMD3<Float>(0, 0.5, -1.0)  // Position in front of the cell

        // Find the cancerCell_complex within the tutorial cell
        guard let complexCell = tutorialCancerCell?.findEntity(named: "cancerCell_complex") else {
            Logger.error("❌ Could not find cancerCell_complex in tutorial cell")
            return
        }
        
        for (index, delay) in tutorialADCDelays.enumerated() {
            try? await Task.sleep(for: .seconds(delay))
            Logger.info("🚀 Firing tutorial ADC \(index + 1)/10")
            await handleTap(
                on: complexCell,
                location: approachPosition,  // Use approach position for targeting
                in: scene
            )
        }
        Logger.info("✅ Tutorial ADC sequence complete")
        
        Logger.info("⏱️ small delay before the test fire cell is spawned")
        try? await Task.sleep(for: .seconds(4.2))  
        
        // MARK: SPAWN TEST FIRE CELL
        Logger.info("\n🎯 Starting test fire sequence...\n")
        Task { @MainActor in
            await spawnTestFireCell(in: root)
        }

        // add a small delay to set readyToStartGame to true
        try? await Task.sleep(for: .seconds(8))
        
        appModel.gameState.tutorialComplete = true
        Logger.info("✅ Set tutorial complete to true")
        
        // set tutorial complete as a check so that the press start audio doesn't start too soon
        
        // set readyToStartGame to true in closure that checks for test fire completion
        
        // Test fire sequence active – deferring full game cell spawning until test fire is completed.
        // The full game setup will be triggered later (e.g., via UI when the start game button is pressed).
    }
    
    func handleGameStart(in root: Entity) async {
        // Fade out tutorial
        if let tutorialContent = root.findEntity(named: "headTrackingRoot") {
            await tutorialContent.fadeOpacity(to: 0, duration: 1)
        }
    }

    @MainActor
    func setupGameContentPool(in root: Entity, attachments: RealityViewAttachments? = nil) async {
        Logger.info("\n=== Initializing Game Content ===")
        
        // Reset game state before starting main game
        appModel.gameState.cellsDestroyed = 0
        cellParameters.removeAll()
        
        // Reset pool to ensure clean state
        Logger.info("Resetting cell pool to clean state...")
        resetPool()
        
        // Use pooled spawning
        await spawnCancerCellsFromPool()
        
        // Verify and initialize each cell's state
        for i in 0..<maxCancerCells {
            if let cell = root.findEntity(named: "cancer_cell_\(i)")?.findEntity(named: "cancerCell_complex") {
                if let stateComponent = cell.components[CancerCellStateComponent.self] {
                    Logger.info("🎯 Cell \(i) initialized - Required hits: \(stateComponent.parameters.requiredHits)")
                }
            }
        }
        
        Logger.info("Cell Parameters after setup:")
        for (index, params) in cellParameters.enumerated() {
            Logger.info("  Cell \(index): isTutorialCell=\(params.isTutorialCell), isDestroyed=\(params.isDestroyed)")
        }
    }

    @MainActor
    func setupGameContent(in root: Entity, attachments: RealityViewAttachments? = nil) async {
        Logger.info("\n=== Initializing Cell States ===")
        
        // Reset game state before starting main game
        appModel.gameState.cellsDestroyed = 0
        cellParameters.removeAll()
        
        // ADC template is already set up during phase transition
        
        do {
            let cancerCellTemplate = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "cancer_cell",
                category: .cancerCell
            )
            let maxCells = maxCancerCells
            await spawnCancerCells(in: root, from: cancerCellTemplate, count: maxCells)
            
            // Update required hits and setup hit tracking
            for i in 0..<maxCells {
                if let cell = root.findEntity(named: "cancer_cell_\(i)")?.findEntity(named: "cancerCell_complex") {
                    // Set initial required hits
                    if let stateComponent = cell.components[CancerCellStateComponent.self] {
                        Logger.info("🎯 Cell \(i) initialized - Required hits: \(stateComponent.parameters.requiredHits)")
                    }
                }
            }

            Logger.info("Cell Parameters after setup:")
            for (index, params) in cellParameters.enumerated() {
                Logger.info("  Cell \(index): isTutorialCell=\(params.isTutorialCell), isDestroyed=\(params.isDestroyed)")
            }

        } catch {
            Logger.error("❌ Failed to load cancer cell template: \(error)")
        }
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+Spawning.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

extension AttackCancerViewModel {
    // MARK: REGULAR SPAWN
    func spawnCancerCells(in root: Entity, from template: Entity, count: Int) async {
        Logger.info("\n=== Starting Cancer Cell Spawning ===")
        Logger.info("Target count: \(count)")
        
        // Create force entity with central gravity
        let forceEntity = createForceEntity()
        root.addChild(forceEntity)
        
        // Track front vs back spawns to ensure good distribution
        var frontSpawnCount = 0
        
        // Spawn cells sequentially
        for i in 0..<count {
            // Prefer front until we have enough there (50% in front)
            let preferFront = frontSpawnCount < Int(Double(count) * 0.5)
            
            // Spawn single cell
            if await spawnSingleCancerCell(in: root, from: template, index: i, preferFront: preferFront) != nil {
                // Track if this was a front spawn
                if preferFront {
                    frontSpawnCount += 1
                }
                
                // Small delay between spawns
                try? await Task.sleep(for: .seconds(0.2))
            }
        }
        
        Logger.info("=== Finished Spawning ===")
        Logger.info("Total parameters created: \(cellParameters.count)")
        Logger.info("Initial cellsDestroyed count: \(appModel.gameState.cellsDestroyed)")
    }
    
    // MARK: SPAWN SINGLE CELL
    private func spawnSingleCancerCell(in root: Entity, from template: Entity, index: Int, preferFront: Bool) async -> Entity? {
        Logger.info("\n=== Spawning Cancer Cell \(index) ===")
        
        let cell = template.clone(recursive: true)
        cell.name = "cancer_cell_\(index)"
        
        if let complexCell = cell.findEntity(named: "cancerCell_complex") {
            // Start with zero scale instead of zero opacity
            // complexCell.transform.scale = .init(repeating: 0)
            complexCell.opacity = 0
            
            // Setup all the physical aspects first
            configureCellPosition(complexCell, preferFront: preferFront)
            configureCellPhysics(complexCell)
            configureCellMovement(complexCell)
            setupCellIdentification(complexCell, cellID: index)
            
            // Create parameters on-demand
            let parameters = CancerCellParameters(cellID: index)
            Logger.info("Creating parameters for cell \(index)")
            Logger.info("Required hits: \(parameters.requiredHits)")
            cellParameters.append(parameters)
            Logger.info("Total parameters after append: \(cellParameters.count)")
            
            // Add state component with reference to parameters
            cell.components.set(CancerCellStateComponent(parameters: parameters))
            Logger.info("Added CancerCellStateComponent with parameters")
            
            root.addChild(cell)
            setupAttachmentPoints(for: cell, complexCell: complexCell, cellID: index)

            Logger.info("\n=== Cancer Cell Single Spawn \(index) Hierarchy ===")
            appModel.assetLoadingManager.inspectEntityHierarchy(cell)

            // Fade in after setup
            await complexCell.fadeOpacity(to: 1.0, duration: 0.5)
            Logger.info("✅ Successfully spawned cell \(index)")
            return cell
        } else {
            Logger.error("❌ Warning: Could not find cancerCell_complex entity")
            return nil
        }
    }
    
    private func createForceEntity() -> Entity {
        let forceEntity = Entity()
        // REF: Planet is positioned at [0, 0.5, -2] relative to device in reference project
        forceEntity.position = [0, 1.5, 0]  // Center point where we want gravity
        
        // REF: gravityMagnitude = 0.1 in reference Gravity.swift
        let gravityMagnitude: Float = 0.1
        // REF: minimumDistance = 0.2 in reference Gravity.swift
        let gravity = Gravity(gravityMagnitude: gravityMagnitude, minimumDistance: 0.2)
        // REF: mask = .all.subtracting(.actualEarthGravity) in reference Entity+Planet.swift
        let forceEffect = ForceEffect(
            effect: gravity,
            mask: .all.subtracting(.actualEarthGravity)
        )
        forceEntity.components.set(ForceEffectComponent(effects: [forceEffect]))
        return forceEntity
    }
    
    func configureCellPosition(_ cell: Entity, preferFront: Bool) {
        // Generate random orbit parameters
        let radius = Float.random(in: 2.0...5.0)  // Increased radius range for more spread
        let height = Float.random(in: 0.0...3.5)  // Increased height range, starting from ground level
        
        // If preferring front, use angle range favoring right side (-30° to +60°)
        let theta: Float
        if preferFront {
            theta = Float.random(in: -Float.pi/6...Float.pi/3)  // -30° to +60°
        } else {
            // For back spawns, favor right side (120° to 270°)
            theta = Float.random(in: 2*Float.pi/3...3*Float.pi/2)
        }
        
        // Place cell on orbit
        // Note: Using negative cos for Z to spawn in front (-Z)
        cell.position = [
            sin(theta) * radius,  // X position on circle
            height,
            -cos(theta) * radius  // Z position on circle (negative for front)
        ]
    }
    
    func configureCellPhysics(_ cell: Entity) {
        // REF: Planet uses radius = 0.12 or 0.25 in reference project
        let shape2 = ShapeResource.generateSphere(radius: 0.32)  // Cancer cell size
        let collisionComponent2 = CollisionComponent(
            shapes: [shape2],
            filter: .init(group: .cancerCell, mask: .all)
        )
        cell.components.set(collisionComponent2)
        
        // REF: Planet uses mass = 1.0 in reference project
        var physicsBody2 = PhysicsBodyComponent(shapes: [shape2], mass: 1.0, mode: .dynamic)
        // REF: isAffectedByGravity = false in reference project (uses custom gravity)
        physicsBody2.isAffectedByGravity = false
        // REF: linearDamping = 0 in reference project
        physicsBody2.linearDamping = 0
        // REF: angularDamping = 0 in reference project
        physicsBody2.angularDamping = 0
        cell.components[PhysicsBodyComponent.self] = physicsBody2
        
        // Add PhysicsMotionComponent for impulse application
        cell.components.set(PhysicsMotionComponent())
    }
    
    func configureCellMovement(_ cell: Entity) {
        // Calculate orbital parameters
        let radius = sqrt(cell.position.x * cell.position.x + cell.position.z * cell.position.z)
        let theta = atan2(cell.position.x, cell.position.z)
        
        // Calculate orbital velocity exactly like reference
        // REF: orbitSpeed = sqrt(gravityMagnitude / radius) in reference Entity+Planet.swift calculateVelocity()
        let gravityMagnitude: Float = 0.1
        let baseSpeed = sqrt(gravityMagnitude / radius) * 0.5
        let minSpeed: Float = 0.15 // or whatever feels right
        let orbitSpeed = max(baseSpeed, minSpeed)
        
        // REF: Direction calculation matches reference Entity+Planet.swift calculateVelocity()
        let orbitDirection = SIMD3<Float>(
            cos(theta),   // X component
            0,            // No vertical velocity
            -sin(theta)   // Z component
        )
        
        // REF: Angular velocity = [0, 1, 0] * 0.3 in reference Entity+Planet.swift
        let rx = Float.random(in: -1...1)
        let ry = Float.random(in: -1...1)
        let rz = Float.random(in: -1...1)
        var spin = SIMD3<Float>(rx, ry, rz)

        // If length is tiny, normalize to some minimum spin
        let minSpinMagnitude: Float = 0.5
        let spinLength = simd_length(spin)
        if spinLength < 0.001 {
            // re-randomize or just pick a default axis
            spin = SIMD3<Float>(0,1,0)
        } else if spinLength < minSpinMagnitude {
            spin = normalize(spin) * minSpinMagnitude
        }

        let motionComponent = PhysicsMotionComponent(
            linearVelocity: orbitDirection * orbitSpeed,
            angularVelocity: spin
        )
        cell.components.set(motionComponent)
        
        // NEW: Store the base velocity for later speed adjustments in the speed boost system.
        cell.components.set(CancerCellMovementData(baseLinearVelocity: orbitDirection * orbitSpeed))
    }
    
    func setupCellIdentification(_ cell: Entity, cellID: Int) {
        // Verify we have the marker component from RCP
        if cell.components.has(CancerCellComponent.self) {
            // Only add state component if it doesn't already exist
            if !cell.components.has(CancerCellStateComponent.self) {
                // Add our state component if not present
                let parameters = CancerCellParameters(cellID: cellID)
                let stateComponent = CancerCellStateComponent(parameters: parameters)
                cell.components.set(stateComponent)
            }
        }
    }
    
    func setupAttachmentPoints(for cell: Entity, complexCell: Entity, cellID: Int) {
        if let scene = cell.scene {
            let attachPointQuery = EntityQuery(where: .has(AttachmentPoint.self))
            for entity in scene.performQuery(attachPointQuery) {
                // Check if this attachment point is part of our cell's hierarchy
                var current = entity.parent
                while let parent = current {
                    if parent == complexCell {
                        var attachPoint = entity.components[AttachmentPoint.self]!
                        attachPoint.cellID = cellID
                        entity.components[AttachmentPoint.self] = attachPoint
                        // Logger.info("Set cellID \(cellID) for attachment point \(entity.name)")
                        break
                    }
                    current = parent.parent
                }
            }
        }
    }
    
    // MARK: POOL SPAWN
    // NEW: Pooled version of spawn
    @MainActor
    func spawnCancerCellsFromPool() async {
        Logger.info("\n=== Starting Cancer Cell Spawning (Pooled) ===")
        Logger.info("Target count: \(maxCancerCells)")
        
        guard let root = rootEntity else {
            Logger.error("❌ Cannot spawn cells - root entity not found")
            return
        }
        
        // Create force entity with central gravity - same as original
        let forceEntity = createForceEntity()
        root.addChild(forceEntity)
        
        // Track front vs back spawns to ensure good distribution
        var frontSpawnCount = 0
        
        // Spawn cells sequentially
        for i in 0..<maxCancerCells {
            // Prefer front until we have enough there (50% in front)
            let preferFront = frontSpawnCount < Int(Double(maxCancerCells) * 0.5)
            
            if let cell = await acquireCell(preferFront: preferFront) {
                // Track if this was a front spawn
                if preferFront {
                    frontSpawnCount += 1
                }
                
                // Fade in the cell
                if let complexCell = cell.findEntity(named: "cancerCell_complex") {
                    await complexCell.fadeOpacity(to: 1.0, duration: 0.5)
                }
                
                // Small delay between spawns
                try? await Task.sleep(for: .seconds(0.2))
            }
        }
        
        Logger.info("=== Finished Spawning ===")
        Logger.info("Total cells spawned: \(maxCancerCells)")
    }
    
    func setupTutorialCancerCell(_ cell: Entity) {
        Logger.info("\n=== Setting up Tutorial Cancer Cell ===")
        
        if let complexCell = cell.findEntity(named: "cancerCell_complex") {
            // Setup all the physical aspects first (minus position and movement)
            // configureCellPhysics(complexCell)
            configureTestCellPhysics(complexCell, physicsEnabled: false)
            
            // Create parameters before calling setupCellIdentification
            let parameters = CancerCellParameters(cellID: 777)
            parameters.isTutorialCell = true  // Mark as tutorial cell
            parameters.physicsEnabled = false  // Disable physics for tutorial cell
            parameters.impactScale = CancerCellParameters.tutorialImpactScale  // Use reduced impact
            parameters.requiredHits = 10  // Set required hits for tutorial
            cellParameters.append(parameters)
            
            // Create and set state component with our parameters
            let stateComponent = CancerCellStateComponent(parameters: parameters)
            complexCell.components.set(stateComponent)
            
            setupAttachmentPoints(for: cell, complexCell: complexCell, cellID: 777)
        }
    }
    
    // Modify spawnTestFireCell to use the new test configuration functions
    func spawnTestFireCell(in root: Entity) async {
         do {
            Logger.info("📱 Test Fire Cell: Loading test_fire_cell")
            let testFireScene = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "test_fire_cell",
                category: .attackCancerEnvironment
            )
            Logger.info("✅ Test Fire Cell: Retrieved test_fire_cell")
            Logger.info("\n=== Test Fire Cell Hierarchy ===")
            
             
             if let testFireCellParent = root.findEntity(named: "headTrackingRoot") {
                 testFireScene.position = testFireCellParent.position
             }

            root.addChild(testFireScene)
             
             let index = 555
             
             if let complexCell = testFireScene.findEntity(named: "cancerCell_complex") {
                 
                 complexCell.opacity = 0
                 
                 // Setup all the physical aspects first (minus position and movement)
                 // configureCellPhysics(complexCell)
                 configureTestCellPhysics(complexCell, physicsEnabled: false)
                 
                 // Create parameters before calling setupCellIdentification
                 let parameters = CancerCellParameters(cellID: index)
                 parameters.isTutorialCell = true  // Mark as tutorial cell
                 parameters.physicsEnabled = false  // Disable physics for tutorial cell
                 parameters.impactScale = CancerCellParameters.tutorialImpactScale  // Use reduced impact
                 parameters.requiredHits = 4  // Set required hits for tutorial
                 cellParameters.append(parameters)
                 
                 // Create and set state component with our parameters
                 let stateComponent = CancerCellStateComponent(parameters: parameters)
                 complexCell.components.set(stateComponent)
                 
                 setupAttachmentPoints(for: testFireScene, complexCell: complexCell, cellID: index)
                 
                  // Fade in after setup
                  await complexCell.fadeOpacity(to: 1.0, duration: 0.5)
                  Logger.info("✅ Successfully spawned cell \(index)")

                  appModel.assetLoadingManager.inspectEntityHierarchy(testFireScene)

                  // set isTestFireActive to true
                  appModel.gameState.isTestFireActive = true
             }
        } catch {
            Logger.error("❌ Test Fire: Failed to instantiate cancer cell template: \(error)")
        }
    }

    private func configureTestCellPhysics(_ cell: Entity, physicsEnabled: Bool = true) {
        let shape = ShapeResource.generateSphere(radius: 0.32)  // Cancer cell size
        let collisionComponent = CollisionComponent(
            shapes: [shape],
            filter: .init(group: .cancerCell, mask: .all)
        )
        cell.components.set(collisionComponent)
        
        // Only add the physics body and motion component if physics is enabled.
        if physicsEnabled {
            var physicsBody = PhysicsBodyComponent(shapes: [shape], mass: 1.0, mode: .dynamic)
            physicsBody.isAffectedByGravity = false
            physicsBody.linearDamping = 0
            physicsBody.angularDamping = 0
            cell.components[PhysicsBodyComponent.self] = physicsBody
            cell.components.set(PhysicsMotionComponent())
        }
    }
    
    private func configureTestCellMovement(_ cell: Entity) {
        // Set linear velocity to zero to avoid orbiting
        let linearVelocity = SIMD3<Float>(0, 0, 0)
        
        // Calculate a random spin vector and reduce its intensity
        let rx = Float.random(in: -1...1)
        let ry = Float.random(in: -1...1)
        let rz = Float.random(in: -1...1)
        var spin = SIMD3<Float>(rx, ry, rz)
        let minSpinMagnitude: Float = 0.5
        let spinLength = simd_length(spin)
        if spinLength < 0.001 {
            spin = SIMD3<Float>(0, 1, 0)
        } else if spinLength < minSpinMagnitude {
            spin = normalize(spin) * minSpinMagnitude
        }
        // Scale spin to 60% for a visible, yet slowed, rotation
        spin *= 0.6
        
        let motionComponent = PhysicsMotionComponent(
            linearVelocity: linearVelocity,
            angularVelocity: spin
        )
        cell.components.set(motionComponent)
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+UI.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

@Observable
@MainActor
class AttackCancerUIViewModel {
    var hitCounts: [Int] = []
    var requiredHits: [Int] = []
    var destroyedStates: [Bool] = []
    
    func setupUISync(for cell: Entity, index: Int) {
        cell.components.set(
            ClosureComponent { _ in
                guard let hitComponent = cell.components[HitCountComponent.self] else { return }
                
                // Ensure arrays are sized
                while self.hitCounts.count <= index {
                    self.hitCounts.append(0)
                    self.requiredHits.append(0)
                    self.destroyedStates.append(false)
                }
                
                // Update state
                self.hitCounts[index] = hitComponent.hitCount
                self.requiredHits[index] = hitComponent.requiredHits
                self.destroyedStates[index] = hitComponent.isDestroyed
            }
        )
    }

    func setupUIAttachments(in root: Entity, attachments: RealityViewAttachments, count: Int) {
        print("\n=== Setting up UI Attachments ===")
        print("Total attachments to create: \(count)")
        
        for i in 0..<count {
            print("Setting up attachment \(i)")
            if let meter = attachments.entity(for: "\(i)") {
                print("✅ Found meter entity for \(i)")
                if root.findEntity(named: "cancer_cell_\(i)") != nil {
                    print("✅ Found cancer cell \(i)")
                    root.addChild(meter)
                    meter.components[UIAttachmentComponent.self] = UIAttachmentComponent(attachmentID: i)
                    meter.components.set(BillboardComponent())
                    
                    print("✅ Added meter to cancer_cell_\(i) with components")
                } else {
                    print("❌ Could not find cancer cell \(i)")
                }
            } else {
                print("❌ Could not create meter entity for \(i)")
            }
        }
    }
} 

```

File: Systems/ADCMovementSystem.swift
```swift
// PfizerOutdoCancer/Systems/ADCMovementSystem.swift
// Revised ADCMovementSystem.swift

import RealityKit
import Foundation
import RealityKitContent

@MainActor
public class ADCMovementSystem: System {
    // MARK: - Queries and Constants
    
    /// Query for entities with an ADC component
    static let query = EntityQuery(where: .has(ADCComponent.self))
    
    // Movement parameters
    static let numSteps: Double = 120
    static let baseArcHeight: Float = 1.2
    static let arcHeightRange: ClosedRange<Float> = 0.6...1.2
    static let baseStepDuration: TimeInterval = 0.016  // ~60fps
    static let speedRange: ClosedRange<Float> = 1.2...3.0
    static let totalDuration: TimeInterval = numSteps * baseStepDuration
    static let minDistance: Float = 0.5
    static let maxDistance: Float = 3.0
    
    // Rotation parameters
    static let rotationSmoothingFactor: Float = 12.0
    static let maxBankAngle: Float = .pi / 8
    static let bankingSmoothingFactor: Float = 6.0
    
    // Acceleration parameters
    static let accelerationPhase: Float = 0.2
    static let decelerationPhase: Float = 0.2
    static let minSpeedMultiplier: Float = 0.4
    
    // Retargeting parameters
    private static let retargetDuration: Float = 0.5
    static let numLookupSamples: Int = 100
    
    // Target search parameters for orbiting ADCs
    static let orbitingTargetSearchInterval: Double = 1.0  // Check for targets every second
    
    // MARK: - Initialization
    required public init(scene: Scene) { }
    
    // MARK: - Update Loop
    public func update(context: SceneUpdateContext) {
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            guard var adcComponent = entity.components[ADCComponent.self] else { continue }

            if adcComponent.state == .moving {
                guard var adcComponent = entity.components[ADCComponent.self],
                      adcComponent.state == .moving,
                      let start = adcComponent.startWorldPosition,
                      let targetID = adcComponent.targetEntityID else { continue }
                
                // Find target entity by its ID.
                let query = EntityQuery(where: .has(AttachmentPoint.self))
                let entities = context.scene.performQuery(query)
                guard let targetEntity = entities.first(where: { $0.id == Entity.ID(targetID) }) else {
                    #if DEBUG
                    print("⚠️ Target entity not found - aborting ADC movement")
                    #endif
                    adcComponent.state = .idle
                    entity.components[ADCComponent.self] = adcComponent
                    continue
                }
                
                // Validate target before proceeding.
                if !Self.validateTarget(targetEntity, adcComponent, in: context.scene) {
                    #if DEBUG
                    print("⚠️ Target no longer valid - attempting to find new target")
                    #endif
                    if Self.retargetADC(entity, &adcComponent, currentPosition: entity.position(relativeTo: nil), in: context.scene) {
                        entity.components[ADCComponent.self] = adcComponent
                        continue
                    } else {
                        #if DEBUG
                        print("⚠️ No valid targets found - resetting ADC")
                        #endif
                        Self.resetADC(entity: entity, component: &adcComponent)
                        continue
                    }
                }
                
                // Get the target position, handling interpolation if needed
                var targetPosition = targetEntity.position(relativeTo: nil)
                
                // If we're interpolating between targets, blend the target position
                if let previousTarget = adcComponent.previousTargetPosition,
                   let newTarget = adcComponent.newTargetPosition {
                    // Update interpolation progress
                    adcComponent.targetInterpolationProgress += Float(context.deltaTime / ADCComponent.targetInterpolationDuration)
                    
                    // When interpolation is complete, update the path
                    if adcComponent.targetInterpolationProgress >= 1.0 {
                        adcComponent.targetInterpolationProgress = 1.0
                        
                        #if DEBUG
                        print("\n=== Path Update Before Recalculation ===")
                        print("Current Position: \(entity.position(relativeTo: nil))")
                        print("Start Position: \(start)")
                        print("Previous Target: \(previousTarget)")
                        print("New Target: \(newTarget)")
                        print("Current Traveled Distance: \(adcComponent.traveledDistance)")
                        print("Previous Path Length: \(adcComponent.pathLength)")
                        #endif
                        
                        // Calculate distances for scaling decision
                        let oldTargetDistance = length(previousTarget - start)
                        let newTargetDistance = length(newTarget - start)
                        
                        #if DEBUG
                        print("\n=== Distance Comparison ===")
                        print("Old target distance: \(oldTargetDistance)")
                        print("New target distance: \(newTargetDistance)")
                        #endif
                        
                        // Scale traveled distance if new target is closer
                        var newTraveledDistance = adcComponent.traveledDistance
                        if newTargetDistance < oldTargetDistance {
                            newTraveledDistance = (adcComponent.traveledDistance / oldTargetDistance) * newTargetDistance
                            #if DEBUG
                            print("Scaling traveled distance: \(adcComponent.traveledDistance) -> \(newTraveledDistance)")
                            #endif
                        } else {
                            #if DEBUG
                            print("New target is farther - preserving absolute traveled distance")
                            #endif
                        }
                        
                        // Calculate new path
                        let distance = length(newTarget - start)
                        let midPoint = Self.mix(start, newTarget, t: 0.5)
                        let arcHeightFactor = adcComponent.arcHeightFactor ?? 1.0
                        let heightOffset = distance * 0.5 * arcHeightFactor
                        let controlPoint = midPoint + SIMD3<Float>(0, heightOffset, 0)
                        
                        // Build new lookup table
                        let lookup = Self.buildLookupTableForQuadraticBezier(
                            start: start,
                            control: controlPoint,
                            end: newTarget,
                            samples: Self.numLookupSamples
                        )
                        
                        let newPathLength = lookup.last ?? 0.0
                        
                        #if DEBUG
                        print("\n=== Path Update After Recalculation ===")
                        print("New Path Length: \(newPathLength)")
                        print("Traveled Distance (updated): \(newTraveledDistance)")
                        print("New Progress: \(newTraveledDistance / newPathLength)")
                        print("Distance from start to target: \(distance)")
                        #endif
                        
                        // Verify the new path is valid
                        if newPathLength <= 0.0 {
                            #if DEBUG
                            print("⚠️ Invalid new path length!")
                            #endif
                            continue
                        }
                        
                        // Update component with new path data
                        adcComponent.lookupTable = lookup
                        adcComponent.pathLength = newPathLength
                        adcComponent.traveledDistance = newTraveledDistance
                        adcComponent.wasRetargeted = true
                        adcComponent.previousTargetPosition = nil
                        adcComponent.newTargetPosition = nil
                        
                        #if DEBUG
                        print("✅ Path update complete - ADC will continue to new target")
                        #endif
                    }
                    
                    // Interpolate target position for this frame
                    let t = Self.smoothstep(0, 1, adcComponent.targetInterpolationProgress)
                    targetPosition = Self.mix(previousTarget, newTarget, t: t)
                }
                
                // Calculate path parameters based on current target position
                let distance = length(targetPosition - start)
                let midPoint = Self.mix(start, targetPosition, t: 0.5)
                let arcHeightFactor = adcComponent.arcHeightFactor ?? 1.0
                let heightOffset = distance * 0.5 * arcHeightFactor
                let controlPoint = midPoint + SIMD3<Float>(0, heightOffset, 0)
                
                // Update lookup table if needed (first frame or after retargeting)
                if adcComponent.lookupTable == nil {
                    let lookup = Self.buildLookupTableForQuadraticBezier(start: start, control: controlPoint, end: targetPosition, samples: Self.numLookupSamples)
                    adcComponent.lookupTable = lookup
                    adcComponent.pathLength = lookup.last ?? 0.0
                    adcComponent.traveledDistance = 0.0
                }
                
                // Calculate effective speed and update traveled distance
                let speedFactor = adcComponent.speedFactor ?? 1.0
                let baseSpeed = adcComponent.pathLength / Float(Self.totalDuration)
                
                // Calculate speed multiplier based on acceleration/deceleration
                let normalizedProgress = (adcComponent.pathLength > 0) ? (adcComponent.traveledDistance / adcComponent.pathLength) : 0
                let speedMultiplier: Float
                if normalizedProgress < Self.accelerationPhase {
                    let t = normalizedProgress / Self.accelerationPhase
                    speedMultiplier = Self.mix(Self.minSpeedMultiplier, 1.0, t: Self.smoothstep(0, 1, t))
                } else if normalizedProgress > (1.0 - Self.decelerationPhase) {
                    let t = (normalizedProgress - (1.0 - Self.decelerationPhase)) / Self.decelerationPhase
                    speedMultiplier = Self.mix(1.0, Self.minSpeedMultiplier, t: Self.smoothstep(0, 1, t))
                } else {
                    speedMultiplier = 1.0
                }
                
                let effectiveSpeed = baseSpeed * speedFactor * speedMultiplier
                adcComponent.traveledDistance += effectiveSpeed * Float(context.deltaTime)
                adcComponent.traveledDistance = min(adcComponent.traveledDistance, adcComponent.pathLength)
                
                // Check for retargeting at 40% for untargeted ADCs
                let currentNormalizedProgress = (adcComponent.pathLength > 0) ? (adcComponent.traveledDistance / adcComponent.pathLength) : 0
                if currentNormalizedProgress >= 0.8 {
                    if let attachPoint = targetEntity.components[AttachmentPoint.self],
                       attachPoint.isUntargeted {
                        #if DEBUG
                        print("\n=== ADC at 80% - Converting from Untargeted to Seeking ===")
                        print("Current Progress: \(currentNormalizedProgress)")
                        print("ADC World Position: \(entity.position(relativeTo: nil))")
                        print("Target World Position: \(targetEntity.position(relativeTo: nil))")
                        #endif
                        
                        // Mark the attachment point as no longer untargeted
                        var updatedAttachPoint = attachPoint
                        updatedAttachPoint.isUntargeted = false
                        updatedAttachPoint.isOccupied = true
                        targetEntity.components[AttachmentPoint.self] = updatedAttachPoint
                        
                        #if DEBUG
                        print("🎯 ADC at 80% - attempting to find cancer cell target")
                        #endif
                        
                        if Self.retargetADC(entity, &adcComponent, currentPosition: entity.position(relativeTo: nil), in: context.scene) {
                            entity.components[ADCComponent.self] = adcComponent
                            // Remove the headPosition entity and its debug sphere.
                            targetEntity.removeFromParent()
                            #if DEBUG
                            print("✨ Removed headPosition entity after successful retarget")
                            #endif
                            continue
                        }
                        // If retargeting fails, just continue to the headPosition
                        #if DEBUG
                        print("⚠️ No suitable cancer cell targets found - continuing to headPosition")
                        #endif
                    }
                }
                
                // Calculate current position on the path
                let tMapped = Self.lookupParameter(forDistance: adcComponent.traveledDistance, lookup: adcComponent.lookupTable ?? [])
                
                // Break down quadratic Bézier calculation into steps
                let t1 = 1.0 - tMapped
                let t2 = tMapped
                
                // Calculate each term separately
                let term1 = start * (t1 * t1)
                let term2 = controlPoint * (2 * t1 * t2)
                let term3 = targetPosition * (t2 * t2)
                
                // Sum the terms to get final position
                let position = term1 + term2 + term3
                entity.position = position
                
                // Calculate tangent vector components separately
                let tangentStart = (controlPoint - start) * (1 - tMapped)
                let tangentEnd = (targetPosition - controlPoint) * tMapped
                let tangent = normalize(2 * (tangentStart + tangentEnd))
                
                // Update orientation
                let orientation = Self.calculateOrientation(
                    progress: tMapped,
                    direction: tangent,
                    deltaTime: context.deltaTime,
                    currentOrientation: entity.orientation,
                    entity: entity
                )
                entity.orientation = orientation
                
                // Save updated component
                entity.components[ADCComponent.self] = adcComponent
                
                // Handle completion
                if adcComponent.hasCollided {
                    #if DEBUG
                    print("\n=== ADC Path Completion ===")
                    print("Final Progress: \(tMapped)")
                    print("Total Distance Traveled: \(adcComponent.traveledDistance)")
                    print("Path Length: \(adcComponent.pathLength)")
                    print("Start Position: \(start)")
                    print("Final Position: \(position)")
                    print("Target Position: \(targetPosition)")
                    #endif
                    
                    // Trigger a hit-scale animation on the parent cancer cell
                    if let cancerCell = Self.findParentCancerCell(for: targetEntity, in: context.scene) {
                        #if DEBUG
                        print("✅ Found parent cancer cell - triggering hit animation")
                        #endif
                        Task { @MainActor in
                            await cancerCell.hitScaleAnimation(
                                intensity: 0.95,
                                duration: 0.2,
                                scaleReduction: 0.05
                            )
                        }
                    } else {
                        #if DEBUG
                        print("⚠️ Could not find parent cancer cell for hit animation")
                        #endif
                    }
                    
                    #if DEBUG
                    print("\n=== ADC Attachment Process ===")
                    // Remove ADC from its current parent and prepare for attachment
                    let previousParent = entity.parent?.name ?? "none"
                    #endif
                    
                    entity.removeFromParent()
                    
                    // Compute and validate landing transform
                    let landingTransform = Self.computeLandingTransform(for: entity, with: targetEntity)
                    if Self.validateLandingTransform(landingTransform) {
                        // Add as child with computed transform
                        targetEntity.addChild(entity)
                        entity.transform = landingTransform
                        
                        #if DEBUG
                        print("✅ Applied landing transform successfully")
                        #endif
                    } else {
                        // Fallback to simple attachment if transform is invalid
                        targetEntity.addChild(entity)
                        entity.position = SIMD3<Float>(0, -0.08, 0)
                        entity.orientation = targetEntity.orientation(relativeTo: nil)
                        #if DEBUG
                        print("⚠️ Using fallback attachment due to invalid landing transform")
                        #endif
                    }
                    
                    #if DEBUG
                    print("🔄 Reparented ADC:")
                    print("Previous Parent: \(previousParent)")
                    print("New Parent: \(targetEntity.name)")
                    #endif
                    
                    // Trigger antigen retraction
                    if let offsetEntity = targetEntity.parent {
                        if var antigenComponent = offsetEntity.components[AntigenComponent.self] {
                            antigenComponent.isRetracting = true
                            offsetEntity.components[AntigenComponent.self] = antigenComponent
                        }
                    }
                    
                    // Scale-up animation
                    var scaleUpTransform = entity.transform
                    scaleUpTransform.scale = SIMD3<Float>(repeating: 1.2)
                    entity.move(
                        to: scaleUpTransform,
                        relativeTo: entity.parent,
                        duration: 0.15,
                        timingFunction: .easeInOut
                    )
                    
                    Task {
                        try? await Task.sleep(for: .milliseconds(150))
                        var originalTransform = entity.transform
                        originalTransform.scale = SIMD3<Float>(repeating: 1.0)
                        entity.move(
                            to: originalTransform,
                            relativeTo: entity.parent,
                            duration: 0.15,
                            timingFunction: .easeInOut
                        )
                    }
                    
                    // Handle audio
                    entity.stopAllAudio()
                    if let audioComponent = entity.components[AudioLibraryComponent.self],
                       let attachSound = audioComponent.resources["ADC_Attach.wav"] {
                        if var spatialAudio = entity.components[SpatialAudioComponent.self] {
                            spatialAudio.directivity = .beam(focus: 1.0)
                            spatialAudio.gain = -6.0
                            entity.components[SpatialAudioComponent.self] = spatialAudio
                        }
                        entity.playAudio(attachSound)
                    }
                    
                    // Update ADC state
                    adcComponent.state = .attached
                    entity.components[ADCComponent.self] = adcComponent
                    #if DEBUG
                    print("✅ ADC state updated to attached")
                    #endif
                    
                    // Update cell hit count
                    if let cellID = adcComponent.targetCellID,
                       let cancerCell = Self.findParentCancerCell(for: targetEntity, in: context.scene),
                       let stateComponent = cancerCell.components[CancerCellStateComponent.self] {
                        let _ = stateComponent.parameters.hitCount
                        stateComponent.parameters.hitCount += 1
                        stateComponent.parameters.wasJustHit = true
                        
                        // Only log the critical hit count updates
                        print("📊 Cell \(cellID): \(stateComponent.parameters.hitCount)/\(stateComponent.parameters.requiredHits) hits")
                        
                        // Post notification for cell update
                        NotificationCenter.default.post(
                            name: Notification.Name("UpdateCancerCell"),
                            object: nil,
                            userInfo: ["entity": cancerCell]
                        )
                        #if DEBUG
                        print("📢 Posted UpdateCancerCell notification for cell \(cellID)")
                        print("\n=== ADC Path Completion ===")
                        print("Final Progress: \(tMapped)")
                        print("Total Distance Traveled: \(adcComponent.traveledDistance)")
                        print("Path Length: \(adcComponent.pathLength)")
                        print("Start Position: \(start)")
                        print("Final Position: \(position)")
                        print("Target Position: \(targetPosition)")
                        #endif
                    } else {
                        #if DEBUG
                        print("⚠️ Could not update hit count - missing required components")
                        #endif
                    }
                    
                    #if DEBUG
                    print("✅ ADC completion process finished successfully")
                    #endif
                    continue
                }
                
                // Set the initial orientation on the first frame.
                if adcComponent.traveledDistance <= 0.01 {
                    let direction = simd_normalize(targetPosition - start)
                    Self.setInitialRootOrientation(entity: entity, direction: direction)
                }
                
                // Update any additional per-frame behavior (like protein spin).
                Self.updateProteinSpin(entity: entity, deltaTime: context.deltaTime)
                
                // Save updated component.
                entity.components[ADCComponent.self] = adcComponent
                
                // MARK: ORBITING
            } else if adcComponent.state == .orbiting {
                // Get the orbit center from headTrackingRoot or use a fallback.
                let orbitCenter: SIMD3<Float>
                if let headTrackingRoot = entity.scene?.findEntity(named: "headTrackingRoot") {
                    orbitCenter = headTrackingRoot.position(relativeTo: nil)
                } else {
                    orbitCenter = [0, 1.5, 0]
                }
                
                // Accumulate time since last target search
                adcComponent.timeSinceLastTargetSearch += context.deltaTime
                
                // Check for new targets periodically
                if adcComponent.timeSinceLastTargetSearch >= Self.orbitingTargetSearchInterval {
                    // Reset the timer
                    adcComponent.timeSinceLastTargetSearch = 0
                    
                    // Try to find a new target
                    if Self.retargetADC(entity, &adcComponent, currentPosition: entity.position(relativeTo: nil), in: context.scene) {
                        // Valid target found, transition to moving state
                        adcComponent.state = .moving
                        adcComponent.lookupTable = nil
                        adcComponent.traveledDistance = 0.0
                        adcComponent.startWorldPosition = entity.position(relativeTo: nil)
                        entity.components[ADCComponent.self] = adcComponent
                        continue
                    }
                }
                
                // --- Update orbit angle in reverse (for counter-clockwise movement)
                // Use only orbitSpeed (no division by orbitRadius here unless you specifically want that effect).
                adcComponent.orbitTheta -= Float(context.deltaTime) * adcComponent.orbitSpeed
                
                // --- Organic Vertical Oscillation
                // Lower the amplitude by scaling it down (for example, multiply by 0.5).
                let verticalOscillation = (adcComponent.verticalOscillationAmplitude * 0.5) *
                    sin(adcComponent.orbitTheta * adcComponent.verticalOscillationFrequency + adcComponent.verticalOscillationPhase)
                
                // Lower the orbit height (again, scale down the stored value).
                let baseOrbitHeight = adcComponent.orbitHeight * 0.5
                
                // --- Calculate the target orbit position.
                let targetX = orbitCenter.x + adcComponent.orbitRadius * cos(adcComponent.orbitTheta)
                let targetZ = orbitCenter.z + adcComponent.orbitRadius * sin(adcComponent.orbitTheta)
                let targetY = orbitCenter.y + baseOrbitHeight + verticalOscillation
                let targetOrbitPosition = SIMD3<Float>(targetX, targetY, targetZ)
                
                // --- Smooth transition into orbiting.
                if adcComponent.orbitTransitionProgress < 1.0 {
                    adcComponent.orbitTransitionProgress += Float(context.deltaTime) / adcComponent.orbitTransitionDuration
                    let t = ADCMovementSystem.smoothstep(0, 1, adcComponent.orbitTransitionProgress)
                    entity.position = ADCMovementSystem.mix(adcComponent.orbitTransitionStartPosition, targetOrbitPosition, t: t)
                } else {
                    entity.position = targetOrbitPosition
                }
                
                // --- Tumbling Rotation
                // Update the tumble angle based on tumbleSpeed.
                adcComponent.tumbleAngle += Float(context.deltaTime) * adcComponent.tumbleSpeed
                // For tumbling, choose a fixed (or random per ADC) axis. Here we use a normalized axis [1, 1, 0].
                let tumbleAxis = simd_normalize(SIMD3<Float>(1, 1, 0))
                let tumbleRotation = simd_quatf(angle: adcComponent.tumbleAngle, axis: tumbleAxis)
                
                // --- Combine with Orbit Orientation
                // Compute the orbit tangent for facing direction. (For a circle, tangent = (-sinθ, 0, cosθ))
                let tangent = SIMD3<Float>(-sin(adcComponent.orbitTheta), 0, cos(adcComponent.orbitTheta))
                let orbitOrientation = simd_quatf(from: [0, 0, 1], to: tangent)
                // Apply the tumble rotation on top of the orbit-facing orientation.
                entity.orientation = tumbleRotation * orbitOrientation
                
                // Update any other per-frame behavior (like protein spin).
                ADCMovementSystem.updateProteinSpin(entity: entity, deltaTime: context.deltaTime)
                
                // Save the updated component.
                entity.components[ADCComponent.self] = adcComponent
            } else {
                #if DEBUG
//                print("⚠️ Unknown ADC state - skipping update")
                #endif
            }
        }
    }
    
    // MARK: - Helper Functions
    
    private static func setInitialRootOrientation(entity: Entity, direction: SIMD3<Float>) {
        let baseOrientation = simd_quatf(from: [0, 0, 1], to: direction)
        entity.orientation = baseOrientation
    }
    
    private static func updateProteinSpin(entity: Entity, deltaTime: TimeInterval) {
        if let proteinComplex = entity.findEntity(named: "antibodyProtein_complex"),
           let adcComponent = entity.components[ADCComponent.self] {
            let spinRotation = simd_quatf(angle: Float(deltaTime) * adcComponent.proteinSpinSpeed, axis: [-1, 0, 0])
            proteinComplex.orientation = proteinComplex.orientation * spinRotation
        }
    }
    
    /// Replaces the old `startMovement` method to initialize the lookup table and arc-length parameters.
    @MainActor
    public static func startMovement(entity: Entity, from start: SIMD3<Float>, to targetPoint: Entity) {
        guard var adcComponent = entity.components[ADCComponent.self] else {
            print("ERROR: No ADCComponent found on entity")
            return
        }
        
        adcComponent.state = .moving
        adcComponent.startWorldPosition = start
        adcComponent.traveledDistance = 0.0
        adcComponent.targetEntityID = UInt64(targetPoint.id)
        
        adcComponent.arcHeightFactor = Float.random(in: arcHeightRange)
        adcComponent.speedFactor = Float.random(in: speedRange)
        
        let target = targetPoint.position(relativeTo: nil)
        let distance = length(target - start)
        let midPoint = mix(start, target, t: 0.5)
        let heightOffset = distance * 0.5 * (adcComponent.arcHeightFactor ?? 1.0)
        let controlPoint = midPoint + SIMD3<Float>(0, heightOffset, 0)
        
        let lookup = Self.buildLookupTableForQuadraticBezier(start: start, control: controlPoint, end: target, samples: Self.numLookupSamples)
        adcComponent.lookupTable = lookup
        adcComponent.pathLength = lookup.last ?? 0.0
        
        entity.components[ADCComponent.self] = adcComponent
        entity.position = start
        
        // Start drone sound.
        if let audioComponent = entity.components[AudioLibraryComponent.self],
           let droneSound = audioComponent.resources["Drones_01.wav"] {
            if var spatialAudio = entity.components[SpatialAudioComponent.self] {
                spatialAudio.directivity = .beam(focus: 1.0)
                entity.components[SpatialAudioComponent.self] = spatialAudio
            }
            entity.playAudio(droneSound)
        }
    }
    
    // (The resetADC function is defined in its separate extension file.)
}

```

File: Systems/ADCMovementSystem+Utils.swift
```swift
//
//  ADCMovementSystem+Utils.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 2/3/25.
//

import RealityKit
import Foundation
import RealityKitContent

@MainActor
extension ADCMovementSystem {
    static func resetADC(entity: Entity, component: inout ADCComponent) {
        #if DEBUG
        print("\n=== Resetting ADC ===")
        print("Previous State: \(component.state)")
        print("Previous Target Cell ID: \(String(describing: component.targetCellID))")
        #endif
        
        // Reset ADC state and target information.
        component.state = .orbiting
        component.targetEntityID = nil
        component.targetCellID = nil
        component.startWorldPosition = nil
        component.targetWorldPosition = nil
        
        // Reset path tracking values.
        component.traveledDistance = 0
        component.pathLength = 0
        component.lookupTable = nil
        
        // Reset retargeting/interpolation values.
        component.previousTargetPosition = nil
        component.newTargetPosition = nil
        component.targetInterpolationProgress = 0
        component.previousPathLength = 0
        component.previousPathTangent = nil
        component.isRetargetedPath = false
        component.compositeProgress = 0
        
        // Stop any ongoing audio.
        entity.stopAllAudio()
        
        // --- NEW: Orbiting Setup ---
        // Set lower and more varied orbit parameters.
        let orbitRadius = Float.random(in: 2.0...3.0)       // Slightly lower orbit radius.
        let orbitHeight = Float.random(in: 0.5...1.0)         // Lower orbit height.
        let orbitSpeed = Float.random(in: 0.3...0.6)          // More variation in orbit speed.
        let orbitTheta = Float.random(in: 0...(2 * .pi))
        component.orbitRadius = orbitRadius
        component.orbitHeight = orbitHeight
        component.orbitSpeed = orbitSpeed
        component.orbitTheta = orbitTheta
        
        // Organic vertical oscillation parameters (with lower amplitude).
        component.verticalOscillationAmplitude = Float.random(in: 0.1...0.3)
        component.verticalOscillationFrequency = Float.random(in: 0.5...1.0)
        component.verticalOscillationPhase = Float.random(in: 0...(2 * .pi))
        
        // --- NEW: Smooth Transition into Orbiting ---
        // Capture the current position as the starting point.
        component.orbitTransitionStartPosition = entity.position(relativeTo: nil)
        // Reset transition progress.
        component.orbitTransitionProgress = 0.0
        // Increase the duration for a smoother transition.
        component.orbitTransitionDuration = 2.0  // For example, 2 seconds.
        
        // --- NEW: Tumbling Rotation Parameters ---
        // Reset the tumble angle and assign a random tumble speed.
        component.tumbleAngle = 0.0
        component.tumbleSpeed = Float.random(in: 0.5...1.5)  // Radians per second.
        
        // Disable collisions (if applicable).
        if var collisionComponent = entity.components[CollisionComponent.self] {
            collisionComponent.filter = CollisionFilter(group: collisionComponent.filter.group, mask: [])
            entity.components[CollisionComponent.self] = collisionComponent
        }
        
        entity.components[ADCComponent.self] = component
        
        #if DEBUG
        print("✅ ADC Reset Complete")
        print("New State: \(component.state)")
        #endif
    }
}
```

File: Systems/ADCMovementSystem+Retargeting.swift
```swift
// ADCMovementSystem+Retargeting.swift

import RealityKit
import Foundation
import RealityKitContent

@MainActor
extension ADCMovementSystem {
    
    static func retargetADC(_ entity: Entity,
                            _ adcComponent: inout ADCComponent,
                            currentPosition: SIMD3<Float>,
                            in scene: Scene) -> Bool {
        // Find new target
        guard let (newTarget, newCellID) = findNewTarget(for: entity, currentPosition: currentPosition, in: scene) else {
            #if DEBUG
            print("⚠️ No valid targets found for retargeting")
            #endif
            return false
        }
        
        #if DEBUG
        print("🎯 Retargeting ADC to new cancer cell (ID: \(newCellID))")
        #endif
        
        // Skip if targeting same cell
        if adcComponent.targetCellID == newCellID {
            #if DEBUG
            print("⚠️ Attempting to retarget to same cell - skipping")
            #endif
            return false
        }
        
        // Check that the new target is sufficiently far from current position
        let newTargetPos = newTarget.position(relativeTo: nil)
        let distanceToNewTarget = length(newTargetPos - currentPosition)
        let minRequiredDistance: Float = 0.3 // Match the scoring function's minimum distance
        
        if distanceToNewTarget < minRequiredDistance {
            #if DEBUG
            print("\n⚠️ Target Distance Check Failed:")
            print("New target \(newTarget.name) is too close to current position")
            print("Distance to target: \(distanceToNewTarget)")
            print("Required minimum distance: \(minRequiredDistance)")
            #endif
            return false
        } else {
            #if DEBUG
            print("\n✅ Target Distance Check Passed:")
            print("Distance to new target: \(distanceToNewTarget)")
            print("Current position: \(currentPosition)")
            print("Target position: \(newTargetPos)")
            #endif
        }
        
        // Store current target position and set up interpolation
        if let currentTargetID = adcComponent.targetEntityID,
           let currentTarget = scene.findEntity(id: currentTargetID) {
            // Store the current path length before updating
            adcComponent.previousPathLength = adcComponent.pathLength
            
            #if DEBUG
            print("\n=== Previous Path Info ===")
            print("Previous Path Length: \(adcComponent.pathLength)")
            print("Previous Progress: \(adcComponent.traveledDistance / adcComponent.pathLength)")
            print("Previous Target Position: \(currentTarget.position(relativeTo: nil))")
            print("Previous Target Distance: \(length(currentTarget.position(relativeTo: nil) - currentPosition))")
            #endif
            
            // Set up target interpolation using transform snapshots
            let currentTransform = currentTarget.transformMatrix(relativeTo: nil)
            let newTransform = newTarget.transformMatrix(relativeTo: nil)
            
            adcComponent.previousTargetPosition = currentTransform.translation()
            adcComponent.newTargetPosition = newTransform.translation()
            adcComponent.targetInterpolationProgress = 0
            
            #if DEBUG
            print("\n=== Starting Retarget ===")
            print("From: \(currentTarget.name) to: \(newTarget.name)")
            print("Current Distance Traveled: \(adcComponent.traveledDistance)")
            print("Current Path Length: \(adcComponent.pathLength)")
            print("Current Progress: \(adcComponent.traveledDistance / adcComponent.pathLength)")
            print("New Target Distance: \(length(newTarget.position(relativeTo: nil) - currentPosition))")
            print("Interpolation Start Position: \(currentPosition)")
            #endif
        }
        
        // Update component with new target info using proper component update pattern
        adcComponent.targetEntityID = newTarget.id
        adcComponent.targetCellID = newCellID
        
        // Update attachment point using proper component update pattern
        if let attachPoint = newTarget.components[AttachmentPoint.self] {
            var updatedAttachPoint = attachPoint
            updatedAttachPoint.isOccupied = true
            newTarget.components[AttachmentPoint.self] = updatedAttachPoint
            #if DEBUG
            print("✅ Marked attachment point as occupied")
            #endif
        }
        
        return true
    }
    
    static func validateTarget(_ targetEntity: Entity, _ adcComponent: ADCComponent, in scene: Scene) -> Bool {
        // Check if this is an untargeted spawn point
        if let attachPoint = targetEntity.components[AttachmentPoint.self],
           attachPoint.isUntargeted {
            return true
        }
        
        // The rest of the validation is for cancer cell targets
        if targetEntity.parent == nil {
            #if DEBUG
            print("\n=== ADC RETARGET (Target Lost) ===")
            print("Target attachment point has been removed from scene")
            #endif
            return false
        }
        
        // Use proper error handling for component access
        guard let cancerCell = findParentCancerCell(for: targetEntity, in: scene),
              let stateComponent = cancerCell.components[CancerCellStateComponent.self],
              let cellID = adcComponent.targetCellID else {
            #if DEBUG
            print("\n=== ADC RETARGET (Invalid State) ===")
            print("Missing required components or target cell ID")
            #endif
            return false
        }
        
        let parameters = stateComponent.parameters
        
        if parameters.isDestroyed {
            #if DEBUG
            print("\n=== ADC RETARGET (Cell Destroyed) ===")
            print("Cell ID: \(cellID)")
            print("Hit Count: \(parameters.hitCount)/\(parameters.requiredHits)")
            #endif
            return false
        }
        
        if parameters.hitCount >= parameters.requiredHits {
            #if DEBUG
            print("\n=== ADC RETARGET (Cell Complete) ===")
            print("Cell ID: \(cellID)")
            print("Hit Count: \(parameters.hitCount)/\(parameters.requiredHits)")
            #endif
            return false
        }
        
        if parameters.cellID == cellID &&
            !parameters.isDestroyed &&
            parameters.hitCount < parameters.requiredHits {
            return true
        }
        
        #if DEBUG
        print("\n=== ADC RETARGET (Target Invalid) ===")
        print("Cell ID: \(cellID)")
        print("Hit Count: \(parameters.hitCount)/\(parameters.requiredHits)")
        print("Is Destroyed: \(parameters.isDestroyed)")
        #endif
        return false
    }
    
    /// Calculates a score for an attachment point based on its position and orientation relative to an approach position
    /// - Parameters:
    ///   - attachPosition: World position of the attachment point
    ///   - cellCenter: World position of the cell center
    ///   - approachPosition: Position from which the ADC is approaching
    ///   - minDistance: Minimum allowed distance (to prevent too-close targeting)
    /// - Returns: A score where higher values indicate better targets, or nil if the target is invalid
    @MainActor
    public static func calculateAttachmentScore(
        attachPosition: SIMD3<Float>,
        cellCenter: SIMD3<Float>,
        approachPosition: SIMD3<Float>,
        minDistance: Float = 0.3
    ) -> Float? {
        let distance = length(attachPosition - approachPosition)
        
        // Skip if the target is too close (prevent sharp turns)
        if distance < minDistance {
            return nil
        }
        
        // Base score on inverse distance (closer is better, but not too close)
        var score = 1.0 / max(distance, minDistance)
        
        // Factor in the facing direction of the antigen
        let antigenDirection = simd_normalize(attachPosition - cellCenter)
        let approachVector = simd_normalize(approachPosition - cellCenter)
        let dotProduct = simd_dot(antigenDirection, approachVector)
        
        // Adjust score based on how well the antigen faces the approach vector
        // (dotProduct + 1) * 2.0 maps the dot product from [-1,1] to [0,4]
        score *= (dotProduct + 1) * 2.0
        
        return score
    }

    static func findNewTarget(for adcEntity: Entity, currentPosition: SIMD3<Float>, in scene: Scene) -> (Entity, Int)? {
        let query = EntityQuery(where: .has(AttachmentPoint.self))
        var bestScore: Float = -Float.infinity
        var bestTarget: (Entity, Int)? = nil
        
        let entities = scene.performQuery(query)
        
        for entity in entities {
            guard let attachComponent = entity.components[AttachmentPoint.self],
                  !attachComponent.isOccupied else {
                continue
            }
            
            guard let cancerCell = findParentCancerCell(for: entity, in: scene),
                  let stateComponent = cancerCell.components[CancerCellStateComponent.self],
                  let cellID = stateComponent.parameters.cellID,
                  !stateComponent.parameters.isDestroyed else {
                continue
            }
            
            if stateComponent.parameters.hitCount >= stateComponent.parameters.requiredHits {
                continue
            }
            
            let attachPosition = entity.position(relativeTo: nil)
            let cellCenter = cancerCell.position(relativeTo: nil)
            
            guard let score = Self.calculateAttachmentScore(
                attachPosition: attachPosition,
                cellCenter: cellCenter,
                approachPosition: currentPosition
            ) else { continue }
            
            #if DEBUG
            // print("📊 Antigen Score - Distance: \(length(attachPosition - currentPosition)), Score: \(score)")
            #endif
            
            if score > bestScore {
                bestScore = score
                bestTarget = (entity, cellID)
                #if DEBUG
                print("✨ New best target found - Score: \(score)")
                #endif
            }
        }
        
        #if DEBUG
        if bestTarget != nil {
            // print("\n🎯 Selected target:")
            // print("Cell ID: \(target.1)")
            // print("Attachment Point: \(target.0.name)")
            // print("Final Score: \(bestScore)")
        }
        #endif
        
        return bestTarget
    }
    
    // --- Re-add findParentCancerCell ---
    static func findParentCancerCell(for attachmentPoint: Entity, in scene: Scene) -> Entity? {
        var current = attachmentPoint
        while let parent = current.parent {
            if parent.components[CancerCellStateComponent.self] != nil {
                return parent
            }
            current = parent
        }
        return nil
    }
}

```

File: Systems/CancerCellMovementData.swift
```swift
// CancerCellMovementData.swift
import RealityKit
import simd

/// A component to store the base movement data for a cancer cell.
public struct CancerCellMovementData: Component, Codable {
    public var baseLinearVelocity: SIMD3<Float>
    
    public init(baseLinearVelocity: SIMD3<Float>) {
        self.baseLinearVelocity = baseLinearVelocity
    }
}
```

File: Systems/MovementSystem.swift
```swift
import RealityKit
import RealityKitContent

/// A system that handles the movement and rotation of entities with MovementComponent
@MainActor
public class MovementSystem: System {
    /// Query to find entities that have a MovementComponent
    static let query = EntityQuery(where: .has(MovementComponent.self))
    
    /// Initialize the system with the RealityKit scene
    required public init(scene: Scene) {}
    
    /// Update the entities to apply movement and rotation
    public func update(context: SceneUpdateContext) {
        // Temporarily disabled
        return
        
        // Original code commented out
        /*
        // Iterate over entities that match the query and are currently rendering
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            // Get the MovementComponent from the entity
            var comp = entity.components[MovementComponent.self]!
            
            // Update the time as it passes
            comp.time += context.deltaTime
            
            // Update the component in the entity
            entity.components[MovementComponent.self] = comp
            
            // Use SIMD3 axis directly since we changed the component
            entity.setOrientation(simd_quatf(angle: Float(0.1 * comp.speed), axis: comp.axis), relativeTo: entity)
        }
        */
    }
}

```

File: Systems/ADCMovementSystem+Math.swift
```swift
// ADCMovementSystem+Math.swift

import RealityKit
import Foundation
import RealityKitContent

@MainActor
extension ADCMovementSystem {
    
    internal static func mix(_ a: Float, _ b: Float, t: Float) -> Float {
        return a * (1 - t) + b * t
    }
    
    internal static func mix(_ a: SIMD3<Float>, _ b: SIMD3<Float>, t: Float) -> SIMD3<Float> {
        return a * (1 - t) + b * t
    }
    
    internal static func smoothstep(_ edge0: Float, _ edge1: Float, _ x: Float) -> Float {
        let t = max(0, min((x - edge0) / (edge1 - edge0), 1))
        return t * t * (3 - 2 * t)
    }
    
    /// Quadratic Bézier point calculation: B(t) = (1-t)²P₀ + 2(1-t)tP₁ + t²P₂
    static func quadraticBezierPoint(_ p0: SIMD3<Float>,
                                     _ p1: SIMD3<Float>,
                                     _ p2: SIMD3<Float>,
                                     t: Float) -> SIMD3<Float> {
        let mt = 1 - t
        return mt * mt * p0 + 2 * mt * t * p1 + t * t * p2
    }
    
    /// Given a quadratic Bézier curve, sample it to build a lookup table of cumulative arc lengths.
    static func buildLookupTableForQuadraticBezier(start: SIMD3<Float>, control: SIMD3<Float>, end: SIMD3<Float>, samples: Int) -> [Float] {
        var lookup: [Float] = [0.0]
        var previousPoint = start
        for i in 1...samples {
            let t = Float(i) / Float(samples)
            let point = quadraticBezierPoint(start, control, end, t: t)
            let segmentLength = simd_distance(point, previousPoint)
            let cumulative = lookup.last! + segmentLength
            lookup.append(cumulative)
            previousPoint = point
        }
        return lookup
    }
    
    /// Given the traveled distance and a lookup table, interpolate the corresponding parameter t.
    static func lookupParameter(forDistance distance: Float, lookup: [Float]) -> Float {
        guard let totalLength = lookup.last, totalLength > 0 else { return 0 }
        let d = simd_clamp(distance, 0, totalLength)
        for i in 1..<lookup.count {
            if lookup[i] >= d {
                let t0 = Float(i - 1) / Float(lookup.count - 1)
                let t1 = Float(i) / Float(lookup.count - 1)
                let d0 = lookup[i - 1]
                let d1 = lookup[i]
                let segmentFraction = (d - d0) / (d1 - d0)
                return t0 + segmentFraction * (t1 - t0)
            }
        }
        return 1.0
    }
    
    /// Calculates complete path metrics (for legacy or debugging purposes).
    static func calculatePathMetrics(
        start: SIMD3<Float>,
        control: SIMD3<Float>,
        end: SIMD3<Float>
    ) -> (length: Float, initialDirection: SIMD3<Float>, controlPoint: SIMD3<Float>) {
        let pathLength = quadraticBezierLength(start, control, end)
        let initialDerivative = 2 * (control - start)
        let initialDirection = normalize(initialDerivative)
        return (pathLength, initialDirection, control)
    }
    
    /// Quadratic Bézier curve length using Gauss–Legendre quadrature.
    static func quadraticBezierLength(_ p0: SIMD3<Float>, _ p1: SIMD3<Float>, _ p2: SIMD3<Float>) -> Float {
        let weights: [Float] = [0.236926885056189, 0.478628670499366, 0.568888888888889, 0.478628670499366, 0.236926885056189]
        let nodes: [Float] = [0.046910077030668, 0.230765344947158, 0.5, 0.769234655052842, 0.953089922969332]
        
        return nodes.enumerated().reduce(0) { acc, pair in
            let t = pair.element
            let derivative = 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1))
            return acc + weights[pair.offset] * simd_length(derivative)
        } * 0.5
    }
    
    internal static func validateQuaternion(_ quat: simd_quatf) -> Bool {
        if quat.vector.x.isNaN || quat.vector.y.isNaN || quat.vector.z.isNaN || quat.vector.w.isNaN {
            return false
        }
        let length = sqrt(quat.vector.x * quat.vector.x +
                          quat.vector.y * quat.vector.y +
                          quat.vector.z * quat.vector.z +
                          quat.vector.w * quat.vector.w)
        return abs(length - 1.0) < 0.001
    }
    
    static func calculateOrientation(progress: Float,
                                     direction: SIMD3<Float>,
                                     deltaTime: TimeInterval,
                                     currentOrientation: simd_quatf,
                                     entity: Entity) -> simd_quatf {
        // Validate inputs
        guard validateOrientationCalculation(entity: entity,
                                          progress: progress,
                                          direction: direction,
                                          currentOrientation: currentOrientation) else {
            return currentOrientation
        }
        
        // Handle protein complex spin animation
        if let proteinComplex = entity.findEntity(named: "antibodyProtein_complex"),
           let adcComponent = entity.components[ADCComponent.self] {
            let worldSpinAxis = currentOrientation.act([-1, 0, 0])
            let spinRotation = simd_quatf(angle: Float(deltaTime) * adcComponent.proteinSpinSpeed, axis: worldSpinAxis)
            proteinComplex.orientation = spinRotation * proteinComplex.orientation
        }
        
        // Early return if we don't have the necessary components
        guard let adcComponent = entity.components[ADCComponent.self],
              let targetID = adcComponent.targetEntityID else {
            return currentOrientation
        }
        
        // Find target entity
        let query = EntityQuery(where: .has(AttachmentPoint.self))
        guard let targetEntity = entity.scene?.performQuery(query).first(where: { $0.id == Entity.ID(targetID) }) else {
            return currentOrientation
        }
        
        // Compute landing orientation and blend factor
        let landingOrientation = computeLandingOrientation(for: entity, with: targetEntity)
        let blendFactor = computeBlendFactor(progress: progress)
        
        // Debug state if needed
        // #if DEBUG
        // debugPrintOrientationState(
        //     progress: progress,
        //     blendFactor: blendFactor,
        //     currentOrientation: currentOrientation,
        //     targetOrientation: landingOrientation
        // )
        // #endif
        
        if blendFactor > 0 {
            // Blend between flight orientation and landing orientation
            let flightOrientation = simd_quatf(from: [0, 0, 1], to: direction)
            let intermediateOrientation = safeSlerp(from: flightOrientation, to: landingOrientation, t: blendFactor)
            
            // Add subtle banking based on progress
            let bankAngle = computeBankingAngle(progress: progress, blendFactor: blendFactor)
            let bankRotation = simd_quatf(angle: bankAngle, axis: [1, 0, 0])
            
            // Combine orientations
            let targetOrientation = bankRotation * intermediateOrientation
            
            // Smoothly interpolate from current to target orientation
            return safeSlerp(from: currentOrientation, to: targetOrientation, t: Float(deltaTime) * rotationSmoothingFactor)
        } else {
            // Standard flight orientation when not near target
            let flightOrientation = simd_quatf(from: [0, 0, 1], to: direction)
            
            // Add banking during normal flight
            let bankAngle = computeBankingAngle(progress: progress, blendFactor: 0)
            let bankRotation = simd_quatf(angle: bankAngle, axis: [1, 0, 0])
            
            // Combine orientations
            let targetOrientation = bankRotation * flightOrientation
            
            // Smoothly interpolate from current to target orientation
            return safeSlerp(from: currentOrientation, to: targetOrientation, t: Float(deltaTime) * rotationSmoothingFactor)
        }
    }
    
    // MARK: - Landing Orientation Helpers
    
    /// Ensures a quaternion is normalized and valid
    internal static func normalizeQuaternion(_ quat: simd_quatf) -> simd_quatf {
        if !validateQuaternion(quat) {
            // Create identity quaternion manually (w=1, xyz=0)
            return simd_quatf(vector: SIMD4<Float>(0, 0, 0, 1))
        }
        return quat
    }
    
    /// Safely normalizes a vector, returning a default up vector if normalization fails
    internal static func safeNormalize(_ vector: SIMD3<Float>, defaultVector: SIMD3<Float> = SIMD3<Float>(0, 1, 0)) -> SIMD3<Float> {
        let vectorLength = length(vector)
        
        // Check for near-zero length or NaN components
        if vectorLength < 1e-6 || vector.x.isNaN || vector.y.isNaN || vector.z.isNaN {
            #if DEBUG
            // print("⚠️ Vector normalization failed:")
            // print("Vector: \(vector)")
            // print("Length: \(vectorLength)")
            // print("Using default vector: \(defaultVector)")
            #endif
            return defaultVector
        }
        
        return vector / vectorLength
    }
    
    /// Computes surface normal from a point on the surface to the center
    internal static func computeSurfaceNormal(surfacePoint: SIMD3<Float>, center: SIMD3<Float>) -> SIMD3<Float> {
        let vector = surfacePoint - center
        
        #if DEBUG
        // print("Surface Normal Calculation:")
        // print("Vector: \(vector)")
        // print("Vector Length: \(length(vector))")
        #endif
        
        return safeNormalize(vector)
    }
    
    /// Safely interpolates between two quaternions with validation
    internal static func safeSlerp(from start: simd_quatf, to end: simd_quatf, t: Float) -> simd_quatf {
        guard validateQuaternion(start) && validateQuaternion(end) else {
            #if DEBUG
            print("⚠️ Invalid quaternions in slerp - using start quaternion")
            #endif
            return start
        }
        return simd_slerp(start, end, t)
    }
    
    // MARK: - Easing and Blending
    
    /// Smooth easing function for orientation blending
    internal static func smoothEaseInOut(_ x: Float) -> Float {
        let t = simd_clamp(x, 0, 1)
        return t * t * (3 - 2 * t)
    }
    
    /// Exponential ease out for smoother deceleration
    internal static func expEaseOut(_ x: Float) -> Float {
        return x == 1 ? 1 : 1 - pow(2, -10 * x)
    }
    
    /// Computes blend factor for landing orientation transition
    internal static func computeBlendFactor(progress: Float, startBlend: Float = 0.8) -> Float {
        if progress < startBlend {
            return 0
        }
        let rawFactor = (progress - startBlend) / (1 - startBlend)
        return smoothEaseInOut(rawFactor)
    }
    
    /// Computes banking angle based on progress and blend factor
    internal static func computeBankingAngle(progress: Float, blendFactor: Float) -> Float {
        let baseAngle = sin(progress * .pi * 2)
        return (1 - blendFactor) * maxBankAngle * baseAngle
    }
    
    // MARK: - Landing Orientation
    
    /// Computes a landing orientation that aligns the ADC with the antigen's surface normal
    internal static func computeLandingOrientation(for adc: Entity, with target: Entity) -> simd_quatf {
        // Get the antigen (two levels up from attachment point)
        guard let antigenOffset = target.parent,
              let antigen = antigenOffset.parent,
              let scene = antigen.scene,
              let cell = findParentCancerCell(for: antigen, in: scene) else {
            #if DEBUG
            print("⚠️ No parent cell found for target - using target orientation")
            #endif
            return target.orientation(relativeTo: nil)
        }
        
        // Compute world positions using the antigen position instead of attachment point
        let antigenWorldPos = antigen.position(relativeTo: nil)
        let cellWorldPos = cell.position(relativeTo: nil)
        
        // #if DEBUG
        // print("\n=== Landing Orientation Debug ===")
        // print("Antigen Entity: \(antigen.name)")
        // print("Antigen World Position: \(antigenWorldPos)")
        // print("Cell World Position: \(cellWorldPos)")
        // print("Vector between positions: \(antigenWorldPos - cellWorldPos)")
        // #endif
        
        // Compute surface normal and validate
        let normal = computeSurfaceNormal(surfacePoint: antigenWorldPos, center: cellWorldPos)
        
        // #if DEBUG
        // print("Computed Normal: \(normal)")
        // print("Normal length: \(length(normal))")
        // print("Has NaN?: \(normal.x.isNaN || normal.y.isNaN || normal.z.isNaN)")
        // #endif
        
        guard !normal.x.isNaN && !normal.y.isNaN && !normal.z.isNaN else {
            #if DEBUG
            print("⚠️ Invalid surface normal computed - using target orientation")
            #endif
            return target.orientation(relativeTo: nil)
        }
        
        // Base rotation to align ADC's up vector with surface normal
        let baseRotation = simd_quatf(from: SIMD3<Float>(0, 1, 0), to: normal)
        guard validateQuaternion(baseRotation) else {
            #if DEBUG
            print("⚠️ Invalid base rotation - using target orientation")
            #endif
            return target.orientation(relativeTo: nil)
        }
        
        // Add randomized rotation around the normal for variety
        let randomAngle = Float.random(in: -Float.pi/8 ... Float.pi/8)
        let randomRotation = simd_quatf(angle: randomAngle, axis: normal)
        
        // Combine rotations and validate
        let finalOrientation = normalizeQuaternion(randomRotation * baseRotation)
        if !validateQuaternion(finalOrientation) {
            #if DEBUG
            print("⚠️ Invalid final orientation - using target orientation")
            #endif
            return target.orientation(relativeTo: nil)
        }
        
        return finalOrientation
    }
    
    /// Computes the complete landing transform including position offset
    internal static func computeLandingTransform(for adc: Entity, with target: Entity) -> Transform {
        var transform = Transform()
        
        // // Set orientation
        // transform.rotation = computeLandingOrientation(for: adc, with: target)
        
        // // Set position with slight offset along the surface normal
        // if let cell = target.parent {
        //     let normal = computeSurfaceNormal(
        //         surfacePoint: target.position(relativeTo: nil),
        //         center: cell.position(relativeTo: nil)
        //     )
        //     transform.translation = SIMD3<Float>(0, -0.08, 0) // Slight offset for visual appeal
        // } else {
        //     transform.translation = .zero
        // }
        
        // Create a pitch rotation of -90 degrees (i.e. -π/2 radians) around the X axis.
        let pitchRotation = simd_quatf(angle: -Float.pi/2, axis: SIMD3<Float>(1, 0, 0))
        
        // Generate a random yaw rotation between 0 and 360 degrees (0 to 2π radians) around the Y axis.
        let randomYawAngle = Float.random(in: 0 ..< (2 * Float.pi))
        let yawRotation = simd_quatf(angle: randomYawAngle, axis: SIMD3<Float>(0, 1, 0))
        
        // Combine the rotations. (Multiplication order matters:
        // here, yawRotation * pitchRotation means that the ADC first gets pitched -90°,
        // then rotated randomly around its new up axis.)
        transform.rotation = yawRotation * pitchRotation
        
        // Optionally, add a slight translation offset along the local Y axis.
        // (This offset can be adjusted to fine-tune the "lily pad" visual.)
        transform.translation = SIMD3<Float>(0, -0.08, 0)
        
        // Set the scale to uniform 1.
        transform.scale = SIMD3<Float>(1, 1, 1)

        return transform
    }
    
    // MARK: - Validation and Debugging
    
    /// Validates all inputs for orientation calculation
    internal static func validateOrientationCalculation(entity: Entity,
                                                      progress: Float,
                                                      direction: SIMD3<Float>,
                                                      currentOrientation: simd_quatf) -> Bool {
        // Check for NaN values in direction vector
        if direction.x.isNaN || direction.y.isNaN || direction.z.isNaN {
            #if DEBUG
            print("⚠️ Invalid direction vector in orientation calculation")
            #endif
            return false
        }
        
        // Validate current orientation
        if !validateQuaternion(currentOrientation) {
            #if DEBUG
            print("⚠️ Invalid current orientation in calculation")
            #endif
            return false
        }
        
        // Validate progress value
        if progress.isNaN || progress < 0 || progress > 1 {
            #if DEBUG
            print("⚠️ Invalid progress value: \(progress)")
            #endif
            return false
        }
        
        // Validate entity has required components
        if entity.components[ADCComponent.self] == nil {
            #if DEBUG
            print("⚠️ Entity missing ADC component")
            #endif
            return false
        }
        
        return true
    }
    
    /// Debug function to print orientation state
    internal static func debugPrintOrientationState(progress: Float,
                                                  blendFactor: Float,
                                                  currentOrientation: simd_quatf,
                                                  targetOrientation: simd_quatf) {
        print("""
        === ADC Orientation State ===
        Progress: \(String(format: "%.3f", progress))
        Blend Factor: \(String(format: "%.3f", blendFactor))
        Current Orientation: \(currentOrientation)
        Target Orientation: \(targetOrientation)
        Quaternion Lengths:
          Current: \(sqrt(simd_dot(currentOrientation.vector, currentOrientation.vector)))
          Target: \(sqrt(simd_dot(targetOrientation.vector, targetOrientation.vector)))
        ========================
        """)
    }
    
    /// Validates transform for landing
    internal static func validateLandingTransform(_ transform: Transform) -> Bool {
        // Check position
        if transform.translation.x.isNaN || transform.translation.y.isNaN || transform.translation.z.isNaN {
            #if DEBUG
            print("⚠️ Invalid landing position")
            #endif
            return false
        }
        
        // Check rotation
        if !validateQuaternion(transform.rotation) {
            #if DEBUG
            print("⚠️ Invalid landing rotation")
            #endif
            return false
        }
        
        // Check scale (should be uniform)
        if transform.scale.x != transform.scale.y || transform.scale.y != transform.scale.z {
            #if DEBUG
            print("⚠️ Non-uniform scale in landing transform")
            #endif
            return false
        }
        
        return true
    }
}
```

File: Systems/CancerCellSpeedBoostSystem.swift
```swift
import RealityKit
import simd

public class CancerCellSpeedBoostSystem: System {

    private struct BoostConfig {
        static let maxBoostMultiplier: Float = 20.5
        static let lerpSharpness: Float = 4.0
        static let gravityMagnitude: Float = 0.1
    }
    
    private static let query = EntityQuery(where:
        .has(PhysicsMotionComponent.self)
    )
    
    public required init(scene: Scene) {}
    
    public func update(context: SceneUpdateContext) {
        let dt = Float(context.deltaTime)
        
        // If you have a specific user Entity, get its position.
        // Otherwise assume the user is at (0,0,0).
        let userPos = SIMD3<Float>(0, 0, 0)
        
        for entity in context.scene.performQuery(Self.query) {
            guard var motion = entity.components[PhysicsMotionComponent.self] else { continue }
            
            // 1) Current offset from user
            let worldPos = entity.position(relativeTo: nil)
            let offset   = worldPos - userPos
            
            // 2) Radius + angle
            let radius = simd_length(offset)
            // angle in [-π, π], with angle=0 meaning “behind user” if we do atan2(x,z).
            // (Because if x=0 and z>0 => angle=0 => that is “back” in your coordinate scheme.)
            let angle  = atan2(offset.x, offset.z)
            
            // 3) Recompute tangential orbit direction each frame so they keep circling
            let orbitDirection = SIMD3<Float>(
                cos(angle),
                0,
                -sin(angle)
            )
            
            // 4) Base orbital speed
            let baseOrbitSpeed = sqrt(BoostConfig.gravityMagnitude / radius) * 0.5
            
            // 5) Smoothly define a speed‐boost factor based on angle
            //
            //    Example:  f(angle) = 1 + (maxBoost - 1)*((cos(angle)+1)/2)
            //
            //    This yields:
            //      angle=0 (behind user)   => cos(0)=1  => raw=1.0 => boost= max
            //      angle=±π (front user)   => cos(±π)=-1 => raw=0.0 => boost= 1 (none)
            //      angle=±π/2 (left/right) => cos(±π/2)=0 => raw=0.5 => midrange
            //
            let rawFactor  = (cos(angle) + 1) * 0.5  // in [0..1]
            var boostFactor = 1 + (
                BoostConfig.maxBoostMultiplier - 1
            ) * rawFactor
            
            // 6) Final velocity
            let targetVelocity = orbitDirection * (baseOrbitSpeed * boostFactor)

            // Ensure at least some minimal speed-up in front
            boostFactor = max(boostFactor, 1.5)
            
            // 7) Smoothly lerp from current to target so it doesn’t jerk
            motion.linearVelocity = simd_mix(
                motion.linearVelocity,
                targetVelocity,
                SIMD3<Float>(repeating: dt * BoostConfig.lerpSharpness)
            )
            
            entity.components.set(motion)
        }
    }
}

```
</file_contents>

