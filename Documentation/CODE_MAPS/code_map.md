<file_map>
├── PfizerOutdoCancer
│   ├── ADC
│   │   ├── ECS
│   │   │   ├── ADCBillboardSystem.swift
│   │   │   ├── ADCCameraSystem.swift
│   │   │   ├── ADCGestureComponent.swift
│   │   │   ├── ADCProximitySystem.swift
│   │   │   └── ADCSimpleBillboardSystem.swift
│   │   ├── Extensions
│   │   │   ├── Gestures
│   │   │   │   ├── ADCEntityExtensions.swift
│   │   │   │   ├── ADCGestureExtensions.swift
│   │   │   │   └── ADCRealityViewExtensions.swift
│   │   │   ├── ADCColor+Extensions.swift
│   │   │   ├── ADCEntity+Extensions.swift
│   │   │   ├── ADCMaterialUtility.swift
│   │   │   ├── ADCMath+Extensions.swift
│   │   │   ├── ADCModelEntity+Extensions.swift
│   │   │   └── ADCView+Extensions.swift
│   │   ├── Models
│   │   │   └── ADCDataModel.swift
│   │   └── Views
│   │       └── ADCBuilder
│   │           ├── ADCOptimizedImmersive
│   │           │   ├── ADCOptimizedImmersive.swift
│   │           │   ├── ADCOptimizedImmersive+Attachments.swift
│   │           │   ├── ADCOptimizedImmersive+Audio.swift
│   │           │   ├── ADCOptimizedImmersive+Entities.swift
│   │           │   └── ADCOptimizedImmersive+Gestures.swift
│   │           ├── ADCBuilderView.swift
│   │           ├── ADCButtonSquareWithOutline.swift
│   │           ├── ADCCheckmarkButton.swift
│   │           ├── ADCLinkerSelectorView.swift
│   │           ├── ADCPayloadSelectorView.swift
│   │           ├── ADCSelectorView.swift
│   │           └── ADCView.swift
│   ├── AppModel
│   │   ├── AppModel.swift
│   │   └── AppModel+AssetLoading.swift
│   ├── AssetManagement
│   │   ├── AssetLoadingManager.swift
│   │   └── AssetLoadingManager+Lab.swift
│   ├── Assets.xcassets
│   │   ├── AccentColor.colorset
│   │   │   └── Contents.json
│   │   ├── ADCBuilder
│   │   │   ├── antibody0.imageset
│   │   │   │   ├── antibody0.png
│   │   │   │   └── Contents.json
│   │   │   ├── antibody1.imageset
│   │   │   │   ├── antibody1.png
│   │   │   │   └── Contents.json
│   │   │   ├── antibody2.imageset
│   │   │   │   ├── antibody2.png
│   │   │   │   └── Contents.json
│   │   │   ├── antibody3.imageset
│   │   │   │   ├── antibody3.png
│   │   │   │   └── Contents.json
│   │   │   ├── linkers0.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── linkers0.png
│   │   │   ├── linkers1.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── linkers1.png
│   │   │   ├── linkers2.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── linkers2.png
│   │   │   ├── linkers3.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── linkers3.png
│   │   │   ├── payload0.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── payload0.png
│   │   │   ├── payload1.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── payload1.png
│   │   │   ├── payload2.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── payload2.png
│   │   │   ├── payload3.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── payload3.png
│   │   │   ├── questionMark.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── questionMark.png
│   │   │   └── Contents.json
│   │   ├── AppIcon.solidimagestack
│   │   │   ├── Back.solidimagestacklayer
│   │   │   │   ├── Content.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── PfizerIconBackground.jpg
│   │   │   │   └── Contents.json
│   │   │   ├── Front.solidimagestacklayer
│   │   │   │   ├── Content.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── PfizerIconFront.png
│   │   │   │   └── Contents.json
│   │   │   ├── Middle.solidimagestacklayer
│   │   │   │   ├── Content.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── PfizerIconMiddle.png
│   │   │   │   └── Contents.json
│   │   │   └── Contents.json
│   │   ├── DarkRed050.colorset
│   │   │   └── Contents.json
│   │   ├── DarkRed200.colorset
│   │   │   └── Contents.json
│   │   ├── DarkRed400.colorset
│   │   │   └── Contents.json
│   │   ├── DarkRed600.colorset
│   │   │   └── Contents.json
│   │   ├── DarkRed800.colorset
│   │   │   └── Contents.json
│   │   ├── gradient050.colorset
│   │   │   └── Contents.json
│   │   ├── gradient200.colorset
│   │   │   └── Contents.json
│   │   ├── gradient400.colorset
│   │   │   └── Contents.json
│   │   ├── gradient600.colorset
│   │   │   └── Contents.json
│   │   ├── gradient800.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue050.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue200.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue400.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue600.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue800.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen050.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen200.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen400.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen600.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen800.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard050.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard200.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard400.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard600.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard800.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed050.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed200.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed400.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed600.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed800.colorset
│   │   │   └── Contents.json
│   │   ├── Pfizer_Logo_Color_RGB.imageset
│   │   │   ├── Contents.json
│   │   │   └── Pfizer_Logo_Color_RGB.png
│   │   ├── Pfizer_Logo_White_RGB.imageset
│   │   │   ├── Contents.json
│   │   │   └── Pfizer_Logo_White_RGB.png
│   │   ├── screen.imageset
│   │   │   ├── Contents.json
│   │   │   └── screen.jpg
│   │   ├── tap.imageset
│   │   │   ├── Contents.json
│   │   │   └── tap.jpg
│   │   └── Contents.json
│   ├── Extensions
│   │   ├── Entity+Animation.swift
│   │   ├── Entity+Audio.swift
│   │   ├── Entity+Find.swift
│   │   ├── Entity+Opacity.swift
│   │   ├── Entity+Trace.swift
│   │   ├── EnvironmentResource.swift
│   │   ├── Transitions.swift
│   │   ├── View+SelectorAnimation.swift
│   │   ├── View+WordAnimation.swift
│   │   └── WordByWordTransition.swift
│   ├── FollowSystemAndComponent
│   │   ├── FollowComponent.swift
│   │   ├── FollowSystem.swift
│   │   ├── HeadPositionTracker.swift
│   │   ├── PositioningComponent.swift
│   │   └── PositioningSystem.swift
│   ├── Managers
│   │   ├── HandTrackingManager.swift
│   │   └── TrackingSessionManager.swift
│   ├── Preview Content
│   │   └── Preview Assets.xcassets
│   │       └── Contents.json
│   ├── Resources
│   │   ├── lab_v005.exr
│   │   └── metro_noord_2k.exr
│   ├── Systems
│   │   ├── ADCMovementSystem.swift
│   │   ├── ADCMovementSystem+Math.swift
│   │   ├── ADCMovementSystem+Retargeting.swift
│   │   ├── ADCMovementSystem+Utils.swift
│   │   ├── ADCSystem.swift
│   │   ├── AntigenSystem.swift
│   │   ├── AttachmentSystem.swift
│   │   ├── BreathingSystem.swift
│   │   ├── CancerCellMovementData.swift
│   │   ├── CancerCellSpeedBoostSystem.swift
│   │   ├── MovementSystem.swift
│   │   ├── RotationAxis.swift
│   │   ├── RotationSystem.swift
│   │   ├── SwirlingSystem.swift
│   │   ├── TraceComponent.swift
│   │   ├── UIAttachmentSystem.swift
│   │   ├── UIStabilizerSystem.swift
│   │   └── UIStateSyncSystem.swift
│   ├── Utilities
│   │   └── Logger.swift
│   ├── Utility
│   │   ├── ClosureComponent.swift
│   │   ├── CollisionGroups.swift
│   │   ├── Floats.swift
│   │   ├── Gravity.swift
│   │   ├── HeadTracker.swift
│   │   ├── IBLUtility.swift
│   │   ├── PortalManager.swift
│   │   ├── RotationHelpers.swift
│   │   └── UnorderedPair.swift
│   ├── ViewModels
│   │   ├── AttackCancerViewModel
│   │   │   ├── AttackCancerViewModel.swift
│   │   │   ├── AttackCancerViewModel+ADC.swift
│   │   │   ├── AttackCancerViewModel+Collisions.swift
│   │   │   ├── AttackCancerViewModel+GameStats.swift
│   │   │   ├── AttackCancerViewModel+HandInteraction.swift
│   │   │   ├── AttackCancerViewModel+Notifications.swift
│   │   │   ├── AttackCancerViewModel+SceneSetup.swift
│   │   │   ├── AttackCancerViewModel+Spawning.swift
│   │   │   └── AttackCancerViewModel+UI.swift
│   │   ├── IntroViewModel
│   │   │   └── IntroViewModel.swift
│   │   ├── LabViewModel
│   │   │   └── LabViewModel.swift
│   │   └── OutroViewModel
│   │       └── OutroViewModel.swift
│   ├── Views
│   │   ├── Effects
│   │   │   └── ButtonHoverEffects.swift
│   │   ├── ADCBuilderViewerButton.swift
│   │   ├── AttackCancerInstructionsView.swift
│   │   ├── AttackCancerView.swift
│   │   ├── AttackCancerViewerButton.swift
│   │   ├── CompletedView.swift
│   │   ├── ContentView.swift
│   │   ├── ErrorView.swift
│   │   ├── GradientNavigationButtonStyle.swift
│   │   ├── HitCounterView.swift
│   │   ├── HopeMeterUtilityView.swift
│   │   ├── HopeMeterView.swift
│   │   ├── IntroView.swift
│   │   ├── IntroWindowView.swift
│   │   ├── LabView.swift
│   │   ├── LabViewerButton.swift
│   │   ├── LibraryView.swift
│   │   ├── LibraryWindow.swift
│   │   ├── LoadingView.swift
│   │   ├── NavigationButton.swift
│   │   ├── NavigationView.swift
│   │   ├── NavToggleView.swift
│   │   ├── OutdoCancer.swift
│   │   ├── OutroView.swift
│   │   ├── Screen.swift
│   │   ├── StartButton.swift
│   │   └── StartView.swift
│   ├── Info.plist
│   └── PfizerOutdoCancerApp.swift

</file_map>

<file_contents>
File: ADC/Models/ADCDataModel.swift
```swift
import Foundation
import RealityKit
import SwiftUI

@Observable
class ADCDataModel {
    // Positioning state
    var isRootSetupComplete = false
    var isEnvironmentSetupComplete = false
    var isHeadTrackingRootReady = false
    var shouldUpdateHeadPosition = false
    var isPositioningComplete = false
    
    var isReadyForInteraction: Bool {
        isRootSetupComplete && 
        isEnvironmentSetupComplete && 
        isHeadTrackingRootReady
    }
    
    // Color selections for ADC components
    var selectedADCAntibody: Int? = nil
    public var selectedADCLinker: Int? = nil
    public var selectedADCPayload: Int? = nil
    
    var selectedLinkerType: Int? = nil
    var selectedPayloadType: Int? = nil
    
    public var linkersWorkingIndex: Int = 0
    public var payloadsWorkingIndex: Int = 0
    
    public var adcBuildStep = 0
    
    var placedLinkerCount: Int = 0
    var placedPayloadCount: Int = 0
    
    public var isVOPlaying = false
    public var hasInitialVOCompleted = false
    public var antibodyVOCompleted = false
    public var antibodyStepCompleted = false
    public var showSelector = false
    
    public var manualStepTransition: Bool = false
    
    // Voice-over progress tracking
    public var voiceOverProgress: Double = 0.0
    let voiceOverDurations: [Int: TimeInterval] = [
        0: 18.0,  // VO1
        1: 22.0,  // VO2
        2: 28.0,  // VO3
        3: 16.0   // VO4
    ]
    
    var isCurrentStepComplete: Bool {
        switch adcBuildStep {
        case 0:
            return selectedADCAntibody != nil
        case 1:
            return selectedLinkerType != nil && linkersWorkingIndex == 3
        case 2:
            return selectedPayloadType != nil && payloadsWorkingIndex == 3
        default:
            return true
        }
    }
    
    // Fill all linker positions with currently selected linker type
    func fillAllLinkers() {
        // set condition if VO is finished  
        guard let selectedType = selectedLinkerType else { return }
        selectedADCLinker = selectedType
        placedLinkerCount = 4
        linkersWorkingIndex = 4
        
        // Move to next step
        adcBuildStep = 2
        // selectedPayloadType = nil
    }
    
    // Fill all payload positions with currently selected payload type
    func fillAllPayloads() {
        guard let selectedType = selectedPayloadType else { return }
        selectedADCPayload = selectedType
        placedPayloadCount = 4
        payloadsWorkingIndex = 4
        
        // Move to next step
        adcBuildStep = 3
    }
    
    func getADCImageName() -> String {
        if let index = selectedADCAntibody {
            return "antibody\(index)"
        } else {
            return "antibody3"
        }
    }
    func getLinkerImageName() -> String {
        if let index = selectedLinkerType {
            return "linkers\(index)"
        } else {
            return "linkers3"
        }
    }
    func getPayloadImageName() -> String {
        if let index = selectedPayloadType {
            return "payload\(index)"
        } else {
            return "payload3"
        }
    }
    
    // MARK: - Cleanup
    func cleanup() {
        // Reset selections
        selectedADCAntibody = nil
        selectedADCLinker = nil
        selectedADCPayload = nil
        selectedLinkerType = nil
        selectedPayloadType = nil
        
        // Reset indices
        linkersWorkingIndex = 0
        payloadsWorkingIndex = 0
        
        // Reset build step
        adcBuildStep = 0
        
        // Reset counters
        placedLinkerCount = 0
        placedPayloadCount = 0
        
        // Reset flags
        isVOPlaying = false
        hasInitialVOCompleted = false
        showSelector = false
        
        // Reset positioning state
        isPositioningComplete = false
    }
    
    // MARK: - Setup Methods
    func setupRoot() -> Entity {
        // Reset state tracking first
        isRootSetupComplete = false
        isEnvironmentSetupComplete = false
        isHeadTrackingRootReady = false
        isPositioningComplete = false
        
        Logger.info("🔄 Starting new ADC session: tracking states reset")
        Logger.info("📱 ADCDataModel: Setting up root")
        
        let root = Entity()
        root.name = "MainEntity"
        root.position = AppModel.defaultEntityPosition
        
        root.components.set(PositioningComponent(
            offsetX: 0,
            offsetY: 0,
            offsetZ: -1.0,
            needsPositioning: false,
            shouldAnimate: false,
            animationDuration: 0.0
        ))
        
        Logger.info("""
        
        ✅ Root Setup Complete
        ├─ Root Entity: \(root.name)
        ├─ Position: \(root.position(relativeTo: nil))
        └─ Positioning: Ready for explicit updates
        """)
        
        isRootSetupComplete = true
        isHeadTrackingRootReady = true
        return root
    }
    
    // MARK: - Color selections for ADC components
}

public enum ADCUIAttachments {
    static let adcSelectorView = "adcSelectorAttachment"
    static let linkerSelectorView = "linkerSelectorAttachment"
    static let payloadSelectorView = "payloadSelectorAttachment"
    static let mainADCView = "mainADCView"
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Attachments.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import OSLog

extension ADCOptimizedImmersive {
//        func calculateMainViewPosition() -> SIMD3<Float> {
////        let cameraPosition = cameraEntity.position(relativeTo: nil)
////         let antibodyPosition = antibodyEntity?.position(relativeTo: nil) ?? [0, 0, defaultZPosition]  
////        
////        return SIMD3<Float>(
////            antibodyPosition.x + -0.5,
////            antibodyPosition.y + 0,
////            antibodyPosition.z + 0
////        )
//        // calculateRadialPosition(cameraPosition: cameraPosition, 
//        //                              antibodyPosition: antibodyPosition, 
//        //                              angleDegrees: -35, 
//        //                              yOffset: antibodyPosition.y, 
//        //                              radiusOffset: 0.1)
//    }
    
   func calculateTargetLinkerPosition() -> SIMD3<Float> {
        let antibodyPosition = antibodyEntity?.position(relativeTo: nil) ?? SIMD3<Float>(0, 0, defaultZPosition)
       
       // Return position 0.5 meters to the right of the antibody
       return SIMD3<Float>(
           antibodyPosition.x + linkerAttachmentOffset.x,  // 0.5 meters to the right
           antibodyPosition.y + linkerAttachmentOffset.y,        // same height
           antibodyPosition.z + linkerAttachmentOffset.z         // same depth
       )
   }
   func calculateTargetPayloadsPosition() -> SIMD3<Float> {
       
    //    let cameraPosition = cameraEntity.position(relativeTo: nil)
        let antibodyPosition = antibodyEntity?.position(relativeTo: nil) ?? [0, 0, defaultZPosition]
       
       return SIMD3<Float>(
           antibodyPosition.x + payloadAttachmentOffset.x,  // 0.5 meters to the right
           antibodyPosition.y + payloadAttachmentOffset.y,        // same height
           antibodyPosition.z + payloadAttachmentOffset.z         // same depth
       )
    //    calculateRadialPosition(cameraPosition: cameraPosition, antibodyPosition: antibodyPosition, angleDegrees: 35, yOffset: antibodyPosition.y, radiusOffset: 0.1)

   }
    
    func setAntibodyAttachmentPosition() {
        
        // let cameraPosition = cameraEntity.position(relativeTo: nil)
        // let antibodyPosition = antibodyEntity?.position(relativeTo: nil) ?? [0, 1.5, defaultZPosition]
        
        // let newPosition = calculateRadialPosition(cameraPosition: cameraPosition, antibodyPosition: antibodyPosition, angleDegrees: 35, yOffset: antibodyPosition.y, radiusOffset: 0.1)
        // adcAttachmentEntity?.position = newPosition
    }
    
    func setLinkerAttachmentPosition() {
        if let linkerAttachmentEntity = linkerAttachmentEntity,
           let linkerEntity = linkerEntity {
            // Get the world position of the linker entity
            let linkerPosition = linkerEntity.position(relativeTo: nil)
            // Set the attachment position with offset
            linkerAttachmentEntity.position = linkerPosition + linkerAttachmentOffset
        }
    }
    
    // func calculateRadialPosition(cameraPosition camera: SIMD3<Float>, antibodyPosition antibody: SIMD3<Float>, angleDegrees: Float, yOffset: Float, radiusOffset: Float = 0.0) -> SIMD3<Float>  {
    //      let c: SIMD3<Float> = [camera.x,0,camera.z]
    //      let a: SIMD3<Float> = [antibody.x ,0,antibody.z]

    //      let directionVector = a - c
    //      let radius = length(directionVector)
    //      let normalizedAC = directionVector.adcNormalized

    //      let aAngleRadians = atan2(normalizedAC.z, normalizedAC.x)
    //      let aAngleDegrees = aAngleRadians * 180 / .pi

    //      let newAngleDegrees = (aAngleDegrees + angleDegrees)
    //      let newAngleRadians = newAngleDegrees * .pi / 180

    //      let x = (radius + radiusOffset) * cos(newAngleRadians)
    //      let z = (radius + radiusOffset) * sin(newAngleRadians)

    //      let b: SIMD3<Float> = [x,yOffset,z] + c
        
    //      return b
    // }
    
    
    func updateADC() {
//        os_log(.debug, "ITR..updateADC() called")
        mainViewEntity.isEnabled = shouldAddMainViewAttachment
        if shouldAddMainViewAttachment {
            //Calculate the new position of mainViewEntity
            // mainViewEntity.position = calculateMainViewPosition()
        }
        if (dataModel.adcBuildStep == 0) {
            if let adcAttachmentEntity {
                if shouldAddADCAttachment {
                    mainEntity?.addChild(adcAttachmentEntity)
                    
//                    if let antibodyEntity {
//                        self.adcAttachmentEntity?.position = antibodyEntity.position(relativeTo: nil) + antibodyAttachmentOffset
//                    }
                    // setAntibodyAttachmentPosition()
                    
                } else {
                    mainEntity?.removeChild(adcAttachmentEntity)
                }
            }
            self.linkerAttachmentEntity?.isEnabled = false
            if let payloadAttachmentEntity { payloadEntity?.removeChild(payloadAttachmentEntity) }
        }
        if (dataModel.adcBuildStep == 1) {
            // if let adcAttachmentEntity { mainEntity?.removeChild(adcAttachmentEntity) }
            setLinkerAttachmentPosition()
            if shouldAddLinkerAttachment {
                self.linkerAttachmentEntity?.isEnabled = true

            } else {
                self.linkerAttachmentEntity?.isEnabled = false
            }
            if let payloadAttachmentEntity { payloadEntity?.removeChild(payloadAttachmentEntity) }
        }
        if (dataModel.adcBuildStep == 2) {
            // if let adcAttachmentEntity { mainEntity?.removeChild(adcAttachmentEntity) }
            self.linkerAttachmentEntity?.isEnabled = false
            if let payloadAttachmentEntity {
                if shouldAddPayloadAttachment {
                    payloadEntity?.addChild(payloadAttachmentEntity)
                } else {
                    payloadEntity?.removeChild(payloadAttachmentEntity)
                }
            }
        }
    }
    
    func setupAttachments(attachments: RealityViewAttachments) {
        if let viewAttachment = attachments.entity(for: ADCUIAttachments.mainADCView) {
            viewAttachment.name = ADCUIAttachments.mainADCView
//            viewAttachment.scale = SIMD3<Float>(0.6, 0.6, 0.6)
            viewAttachment.scale = .one
            //  viewAttachment.components[BillboardComponent.self] = BillboardComponent()
            mainViewEntity.addChild(viewAttachment)
        }
    }
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Audio.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import OSLog

extension ADCOptimizedImmersive {
    
    // MARK: - Audio Functions
    
    func prepareAudioEntities() async {
        // Load audio resources
        if let resource = try? await AudioFileResource(named: "/Root/bubblepop_mp3", from: "antibodyScene.usda", in: realityKitContentBundle) {
            popAudioFileResource = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded pop sound")
            
            // Create pop sound entity with spatial audio
            let popSource = Entity()
            popSource.name = "PopSource"
            popSource.components.set(SpatialAudioComponent(
                gain: 0.5,  // Reduce volume to 50%
                directivity: .beam(focus: 1.0)
            ))
            if let popAudioFileResource = popAudioFileResource {
                popAudioPlaybackController = popSource.prepareAudio(popAudioFileResource)
                if popAudioPlaybackController != nil {
                    os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully prepared pop sound controller")
                } else {
                    os_log(.error, "ITR..ADCOptimizedImmersive: ❌ Failed to create pop sound controller")
                }
            }
            self.popAudioEntity = popSource
            
            // Detach pop sound from main entity
            if let mainEntity {
                mainEntity.removeChild(popSource)
                os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully detached pop sound from main entity")
            }
        } else {
            os_log(.error, "ITR..ADCOptimizedImmersive: ❌ Error loading pop sound from antibodyScene.usda")
        }

        if let resource = try? await AudioFileResource(named: "/Root/BuildADC_VO_1_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            vo1Audio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded VO1")
        }
        if let resource = try? await AudioFileResource(named: "/Root/BuildADC_VO_2_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            vo2Audio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded VO2")
        }
        if let resource = try? await AudioFileResource(named: "/Root/BuildADC_VO_3_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            vo3Audio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded VO3")
        }
        if let resource = try? await AudioFileResource(named: "/Root/BuildADC_VO_4_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            vo4Audio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded VO4")
        }
        if let resource = try? await AudioFileResource(named: "/Root/ADC_Build_Complete_1_wav", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            completionAudio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded completion sound")
        }
        if let resource = try? await AudioFileResource(named: "/Root/niceJob_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            niceJobAudio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded nice job sound")
        }

        // Create voice-over entity with spatial audio - attached to main view entity
        let voiceOverSource = Entity()
        voiceOverSource.name = "VoiceOverSource"

        // Conditionally set up the audio entity to be spatial or channel-based
        if !useChannelAudioForVO { // Only add the spatial component if NOT using channel audio
            voiceOverSource.components.set(SpatialAudioComponent(directivity: .beam(focus: 1.0)))
        }

        if let mainEntity {
            mainEntity.addChild(voiceOverSource)
        }
        self.voiceOverAudioEntity = voiceOverSource
        os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully set up voice over entity")
    }

    func attachPopSoundToTarget(_ target: Entity) {
        if let popSound = popAudioEntity {
            // Remove from current parent if any
            popSound.removeFromParent()
            
            // Add to new target and set transform
            target.addChild(popSound)
            popSound.transform = .init(scale: .one, rotation: .init(), translation: .zero)
            
            // Ensure spatial audio component is set
            if !popSound.components.has(SpatialAudioComponent.self) {
                popSound.components.set(SpatialAudioComponent(
                    gain: 1.0,
                    directivity: .beam(focus: 1.0)
                ))
                os_log(.debug, "ITR..attachPopSoundToTarget(): Added spatial audio component")
            }
            
            os_log(.debug, "ITR..attachPopSoundToTarget(): Successfully attached pop sound to target at position: \(target.position)")
        } else {
            os_log(.error, "ITR..attachPopSoundToTarget(): No pop sound entity available")
        }
    }

    func playPopSound() {
        os_log(.debug, "ITR..playPopSound(): Starting pop sound playback...")
        
        if let controller = popAudioPlaybackController {
            if let popSound = popAudioEntity {
                os_log(.debug, "ITR..playPopSound(): Pop sound entity position: \(popSound.position)")
            }
            
            // Stop any currently playing pop sound
            controller.stop()
            
            // Play the sound
            controller.play()
            os_log(.debug, "ITR..playPopSound(): Started playing pop sound")
        } else {
            os_log(.error, "ITR..playPopSound(): ❌ No popAudioPlaybackController")
        }
    }

    @MainActor
    func playSpatialAudio(step: Int) async throws {
        os_log(.debug, "ITR..playSpatialAudio(): Playing spatial audio for step \(step)")
        
        dataModel.isVOPlaying = true
        dataModel.voiceOverProgress = 0.0
        
        // Stop any currently playing VO
        if let controller = currentVOController {
            controller.stop()
            currentVOController = nil
        }
        
        // For step 3, play completion sound first
        if step == 3 {
            guard let completionAudio,
                  let niceJobAudio,
                  let vo4Audio,
                  let voEntity = voiceOverAudioEntity else {
                os_log(.error, "ITR..playSpatialAudio(): Missing required audio or entity for step 3")
                throw NSError(domain: "ADCOptimizedImmersive", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing required audio or entity for step 3"])
            }
            
            // 1. Play completion sound and wait for it to finish
            await withCheckedContinuation { continuation in
                let completionController = voEntity.prepareAudio(completionAudio)
                completionController.completionHandler = {
                    os_log(.debug, "ITR..playSpatialAudio(): Completion sound finished")
                    continuation.resume()
                }
                completionController.play()
                os_log(.debug, "ITR..playSpatialAudio(): Started playing completion sound")
            }
            
            // 2. Play nice job audio and wait for it to finish
            await withCheckedContinuation { continuation in
                let niceJobController = voEntity.prepareAudio(niceJobAudio)
                niceJobController.completionHandler = {
                    os_log(.debug, "ITR..playSpatialAudio(): Nice job audio finished")
                    continuation.resume()
                }
                niceJobController.play()
                os_log(.debug, "ITR..playSpatialAudio(): Started playing nice job audio")
            }
            
            // 3. Play VO 4 with progress
            return await withCheckedContinuation { continuation in
                currentVOController = voEntity.prepareAudio(vo4Audio)
                currentVOController?.completionHandler = {
                    dataModel.voiceOverProgress = 0.0
                    dataModel.isVOPlaying = false
                    continuation.resume()
                }
                currentVOController?.play()
                
                // Start progress timer
                let duration = dataModel.voiceOverDurations[3] ?? 16.0
                Task {
                    let startTime = Date()
                    while dataModel.isVOPlaying {
                        let elapsed = Date().timeIntervalSince(startTime)
                        dataModel.voiceOverProgress = min(elapsed / duration, 1.0)
                        try? await Task.sleep(for: .milliseconds(16)) // ~60fps
                    }
                }
                
                os_log(.debug, "ITR..playSpatialAudio(): Started playing VO 4")
            }
        }
        
        // Get appropriate VO resource for other steps
        let voResource: AudioFileResource? = switch step {
            case 0: vo1Audio
            case 1: vo2Audio
            case 2: vo3Audio
            default: nil
        }
        
        guard let voResource,
              let voEntity = voiceOverAudioEntity else {
            os_log(.error, "ITR..playSpatialAudio(): Missing VO resource or entity for step \(step)")
            throw NSError(domain: "ADCOptimizedImmersive", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing VO resource or entity"])
        }
        
        // Create and play VO with completion handling
        return await withCheckedContinuation { continuation in
            currentVOController = voEntity.prepareAudio(voResource)
            currentVOController?.completionHandler = {
                dataModel.voiceOverProgress = 0.0
                dataModel.isVOPlaying = false
                continuation.resume()
            }
            currentVOController?.play()
            
            // Start progress timer
            let duration = dataModel.voiceOverDurations[step] ?? 18.0
            Task {
                let startTime = Date()
                while dataModel.isVOPlaying {
                    let elapsed = Date().timeIntervalSince(startTime)
                    dataModel.voiceOverProgress = min(elapsed / duration, 1.0)
                    try? await Task.sleep(for: .milliseconds(16)) // ~60fps
                }
            }
            
            os_log(.debug, "ITR..playSpatialAudio(): Started playing VO for step \(step)")
        }
    }

    func playVO1() async {
        os_log(.debug, "ITR..playVO1(): Starting...")
        if let voiceOverAudioEntity {
            os_log(.debug, "ITR..playVO1(): ✅ Found voiceOverAudioEntity")
            if let vo1Audio {
                os_log(.debug, "ITR..playVO1(): ✅ Found vo1Audio")
                let controller = voiceOverAudioEntity.prepareAudio(vo1Audio)
                currentVOController = controller
                if let controller = currentVOController {
                    controller.play()
                    os_log(.debug, "ITR..playVO1(): ✅ Play called successfully")
                } else {
                    os_log(.error, "ITR..playVO1(): ❌ No controller")
                }
            } else {
                os_log(.error, "ITR..playVO1(): ❌ No vo1Audio")
            }
        } else {
            os_log(.error, "ITR..playVO1(): ❌ No voiceOverAudioEntity")
        }
    }

    func playVO2() async {
        os_log(.debug, "ITR..playVO2(): Starting...")
        if let voiceOverAudioEntity {
            os_log(.debug, "ITR..playVO2(): ✅ Found voiceOverAudioEntity")
            if let vo2Audio {
                os_log(.debug, "ITR..playVO2(): ✅ Found vo2Audio")
                let controller = voiceOverAudioEntity.prepareAudio(vo2Audio)
                currentVOController = controller
                if let controller = currentVOController {
                    controller.play()
                    os_log(.debug, "ITR..playVO2(): ✅ Play called successfully")
                } else {
                    os_log(.error, "ITR..playVO2(): ❌ No controller")
                }
            } else {
                os_log(.error, "ITR..playVO2(): ❌ No vo2Audio")
            }
        } else {
            os_log(.error, "ITR..playVO2(): ❌ No voiceOverAudioEntity")
        }
    }

    func playVO3() async {
        os_log(.debug, "ITR..playVO3(): Starting...")
        if let voiceOverAudioEntity {
            os_log(.debug, "ITR..playVO3(): ✅ Found voiceOverAudioEntity")
            if let vo3Audio {
                os_log(.debug, "ITR..playVO3(): ✅ Found vo3Audio")
                let controller = voiceOverAudioEntity.prepareAudio(vo3Audio)
                currentVOController = controller
                if let controller = currentVOController {
                    controller.play()
                    os_log(.debug, "ITR..playVO3(): ✅ Play called successfully")
                } else {
                    os_log(.error, "ITR..playVO3(): ❌ No controller")
                }
            } else {
                os_log(.error, "ITR..playVO3(): ❌ No vo3Audio")
            }
        } else {
            os_log(.error, "ITR..playVO3(): ❌ No voiceOverAudioEntity")
        }
    }

    func playVO4() async {
        os_log(.debug, "ITR..playVO4(): Starting...")
        if let voiceOverAudioEntity {
            os_log(.debug, "ITR..playVO4(): ✅ Found voiceOverAudioEntity")
            if let vo4Audio {
                os_log(.debug, "ITR..playVO4(): ✅ Found vo4Audio")
                let controller = voiceOverAudioEntity.prepareAudio(vo4Audio)
                currentVOController = controller
                if let controller = currentVOController {
                    controller.play()
                    os_log(.debug, "ITR..playVO4(): ✅ Play called successfully")
                } else {
                    os_log(.error, "ITR..playVO4(): ❌ No controller")
                }
            } else {
                os_log(.error, "ITR..playVO4(): ❌ No vo4Audio")
            }
        } else {
            os_log(.error, "ITR..playVO4(): ❌ No voiceOverAudioEntity")
        }
    }
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive.swift
```swift
// ADCOptimizedImmersive.swift
//
//  ADCOptimizedImmersive
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/4/25.
//
//  This file contains the ADCImmersiveView, which is the immersive view
//  for the ADC Builder.  This view contains the main view hierarchy of the
//  ADC Builder, including the main view, the ADC attachment, and the
//  linker and payload attachment entities.


import SwiftUI
import RealityKit
import RealityKitContent
import OSLog
import ARKit

// MARK: - Types

enum ADCEntityType {
    case linker
    case payload
}

struct ADCOptimizedImmersive: View {
    
    @Environment(AppModel.self) var appModel
    @Environment(ADCDataModel.self) var dataModel
    
    // Audio system
    @State internal var bubblePopSound = false
    
    @State var mainEntity: Entity?
    @State var mainViewEntity = Entity()
    @State var antibodyRootEntity: Entity?
    @State var antibodyEntity: ModelEntity?
    @State var popAudioEntity: Entity?  // Audio source entity for pop sound
    @State var voiceOverAudioEntity: Entity?  // Audio source entity for voice-overs
    
    @State var linkerEntity: Entity?
    @State var payloadEntity: Entity?
    
    @State var workingLinker: ModelEntity?
    @State var workingPayloadInner: ModelEntity?
    @State var workingPayloadOuter: ModelEntity?
    
    // Sort group for managing render order of ADC components
    @State var adcSortGroup: ModelSortGroup?
    
    @State var adcLinkers: [ModelEntity] = .init()
    @State var adcPayloadsInner: [ModelEntity] = .init()
    @State var adcPayloadsOuter: [ModelEntity] = .init()
    
    @State var adcAttachmentEntity: ViewAttachmentEntity?
    @State var linkerAttachmentEntity: ViewAttachmentEntity?
    @State var payloadAttachmentEntity: ViewAttachmentEntity?
    
    @State var shouldAddADCAttachment: Bool = false
    @State var shouldAddLinkerAttachment: Bool = false
    @State var shouldAddPayloadAttachment: Bool = false
    @State var shouldAddMainViewAttachment: Bool = false
    
    @State var refreshFlag = false
    
    @State var popAudioFileResource: AudioFileResource?
    @State var audioEntity: Entity = Entity()
    @State var currentVOController: AudioPlaybackController?
    @State var popAudioPlaybackController: AudioPlaybackController?
    
    @State var vo1Audio: AudioFileResource?
    @State var vo2Audio: AudioFileResource?
    @State var vo3Audio: AudioFileResource?
    @State var vo4Audio: AudioFileResource?
    @State var completionAudio: AudioFileResource?
    @State var niceJobAudio: AudioFileResource?
    
    @State var timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
    @State var isCameraInitialized = false

    @State var useChannelAudioForVO: Bool = true
    
    // let antibodyAttachmentOffset: SIMD3<Float> = SIMD3(-0.5, 0, 0)
    let linkerAttachmentOffset: SIMD3<Float> = SIMD3(0.25, 0, 0)
    let payloadAttachmentOffset: SIMD3<Float> = SIMD3(0.35, 0, 0)
    let defaultZPosition: Float = -1.0
    let antibodyRootOffset: SIMD3<Float> = SIMD3(0, 0, 0)
    
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.openWindow) private var openWindow
    
    @State var originalLinkerMaterial: ShaderGraphMaterial?
    @State var originalPayloadInnerMaterial: PhysicallyBasedMaterial?
    @State var originalPayloadOuterMaterial: ShaderGraphMaterial?
    
    @State var initialLinkerPosition: SIMD3<Float>?
    @State var initialPayloadPosition: SIMD3<Float>?
    
    @State var outlineMaterial: ShaderGraphMaterial?
    
    @State var originalAntibodyMaterial: ShaderGraphMaterial?
    
    @State var targetLinkerEntity: Entity?
    @State var targetPayloadEntity: Entity?
    
    var body: some View {
        RealityView { content, attachments in
            let root = dataModel.setupRoot()
            mainEntity = root
            content.add(root)
            
            Task { @MainActor in
                await setupEntitiesAndMaterials()
                setupAttachments(attachments: attachments)
                await prepareAudioEntities()
                dataModel.isEnvironmentSetupComplete = true
                dataModel.shouldUpdateHeadPosition = true
            }
        } update: { content, attachments in
            // updateADC()
        } attachments: {
            Attachment(id: ADCUIAttachments.mainADCView) {
                ADCBuilderView()
            }
        }
        .installGestures()
        .onAppear {
            dismissWindow(id: AppModel.navWindowId)
        }
        .onDisappear {
            mainEntity?.removeFromParent()
            mainEntity = nil
        }
        .task {
            await appModel.trackingManager.processWorldTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.monitorTrackingEvents()
        }
        // Position update handler
        .onChange(of: dataModel.shouldUpdateHeadPosition) { _, shouldUpdate in
            if shouldUpdate && dataModel.isReadyForInteraction {
                if let root = mainEntity {
                    Logger.info("""
                    
                    🎯 Head Position Update Requested
                    ├─ Current World Position: \(root.position(relativeTo: nil))
                    ├─ Root Setup: \(dataModel.isRootSetupComplete ? "✅" : "❌")
                    ├─ Environment: \(dataModel.isEnvironmentSetupComplete ? "✅" : "❌")
                    └─ HeadTracking: \(dataModel.isHeadTrackingRootReady ? "✅" : "❌")
                    """)
                    
                    Task {
                        await root.checkHeadPosition(animated: true, duration: 0.5)
                        dataModel.shouldUpdateHeadPosition = false
                        dataModel.isPositioningComplete = true  // Set after animation completes
                    }
                }
            }
        }
        // Setup continuation handler
        .onChange(of: dataModel.isPositioningComplete) { _, complete in
            if complete {
                Task { @MainActor in
                    
                    
                    shouldAddADCAttachment = true
                    shouldAddMainViewAttachment = true
                    
                    antibodyRootEntity?.isEnabled = true
                    antibodyEntity?.isEnabled = false
                    antibodyEntity?.opacity = 0
                    dataModel.adcBuildStep = 0
                    
                    // Play audio for initial step
                    do {
                        try await playSpatialAudio(step: 0)
                    } catch {
                        os_log(.error, "ITR..ADCOptimizedImmersive: ❌ Failed to play initial VO: \(error)")
                    }
                }
            }
        }
        .onChange(of: appModel.currentPhase) { oldPhase, newPhase in
            if oldPhase == .building && newPhase != .building {
                print("\n=== ADCOptimizedImmersive Phase Change Cleanup ===")
                print("Transitioning from .building to \(newPhase)")
                cleanup()  // Perform complete cleanup
                print("✅ ADCOptimizedImmersive cleanup complete\n")
            }
        }
        .onChange(of: dataModel.adcBuildStep) { oldValue, newValue in
            Task { @MainActor in
                // Log color summary at each step
                os_log(.debug, "ADC Build Step \(newValue) - Color Summary:")
                os_log(.debug, "- Antibody Color: \(dataModel.selectedADCAntibody ?? -1)")
                os_log(.debug, "- Linker Color: \(dataModel.selectedLinkerType ?? -1)")
                os_log(.debug, "- Payload Color: \(dataModel.selectedPayloadType ?? -1)")
                
                // Play step audio only if this is a natural transition
                if !dataModel.manualStepTransition {
                    Task { @MainActor in
                        do {
                            try await playSpatialAudio(step: newValue)
                        } catch {
                            os_log(.error, "ITR..createLinkerGestureComponent(): ❌ Failed to play VO: \(error)")
                        }
                    }
                }
//                else {
//                    // Reset manual flag for future transitions
//                    dataModel.manualStepTransition = false
//                }
                
                switch newValue {
                case 0:
                    // Starting case - select the antibody color
                    os_log(.debug, "ITR.. ✅ ADC build step 0")
                    // setAntibodyAttachmentPosition()
//                    self.adcLinkers.forEach { $0.isEnabled = false }
                    self.linkerEntity?.isEnabled = false
                    self.payloadEntity?.isEnabled = false

                    updateAttachmentEntities()
                    
                    
                    // Ensure all payloads are disabled in step 0
//                    self.adcPayloadsInner.forEach { $0.isEnabled = false }
//                    self.adcPayloadsOuter.forEach { $0.isEnabled = false }
                case 1:
                    os_log(.debug, "ITR.. ✅ ADC build step 1 - checkmark to move past antibody to linker")
                    self.antibodyRootEntity?.components.remove(ADCGestureComponent.self)
                    for (index, element) in adcLinkers.enumerated() {
                        element.isEnabled = index <= dataModel.linkersWorkingIndex
                        element.components.remove(ADCProximitySourceComponent.self)
                    }
                    adcLinkers[dataModel.linkersWorkingIndex].components.set(ADCProximitySourceComponent())
                    
                    print("going to look for linker entity")
                    if let linkerEntity = linkerEntity {
                        print("case 1, found linker entity")
                        if dataModel.isCurrentStepComplete {
                            print("current step is complete, linker entity = \(linkerEntity.isEnabled)")
//                            linkerEntity.opacity = 1
                            linkerEntity.isEnabled = false
                        } else {
                            print("linker step is not complete, enabling linker entity dataModel.isCurrentStepComplete = \(dataModel.isCurrentStepComplete)")
                            linkerEntity.isEnabled = true
                            linkerEntity.opacity = 1
                            print("setting linker opacity to \(linkerEntity.opacity)")
                        }
                        if !dataModel.manualStepTransition {
                            print("manualStepTransition = \(dataModel.manualStepTransition)")
                            linkerEntity.opacity = 0
                            print("setting linker opacity to \(linkerEntity.opacity)")
                        }
                    }
                    self.linkerAttachmentEntity?.isEnabled = true
                    self.payloadEntity?.isEnabled = false
                case 2:
                    // clicked checkmark to apply the material to all of the linkers
                    os_log(.debug, "ITR.. ✅ ADC build step 2 - checkmark to fill all linkers")
                    // If we came from checkmark button (all linkers filled)
                    if dataModel.linkersWorkingIndex == 4 {
                        Task { @MainActor in
                            // Play pop sound for successful placement
                            // bubblePopSound.toggle()
                            
                            // Apply original material and selected color to all linkers
                            for linker in adcLinkers {
                                if let originalMaterial = originalLinkerMaterial {
                                    linker.updateMaterials { material in
                                        material = originalMaterial
                                    }
                                }
                                // changed underlying shader to shaderGraph
                                linker.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[dataModel.selectedLinkerType ?? 0])
                                linker.isEnabled = true
                            }
                            
                            // Only advance step after visuals are complete
                            // dataModel.adcBuildStep = 3
                        }
                    }
                    
                    self.adcLinkers.forEach { $0.isEnabled = true }
                    self.linkerEntity?.isEnabled = false
                    self.linkerAttachmentEntity?.isEnabled = false
                    
//                    if let payloadEntity = payloadEntity {
//                        if dataModel.isCurrentStepComplete {
//                            payloadEntity.isEnabled = true
//                        }
//                        payloadEntity.isEnabled = false
//                        payloadEntity.opacity = 0
//                    }
                    
                    print("going to look for payload entity")
                    if let payloadEntity = payloadEntity {
                        print("case 1, found payloadEntity entity")
                        if dataModel.isCurrentStepComplete {
                            print("current step is complete, payloadEntity entity = \(payloadEntity.isEnabled)")
                            payloadEntity.isEnabled = false
                        } else {
                            print("payloadEntity step is not complete, enabling payloadEntity  dataModel.isCurrentStepComplete = \(dataModel.isCurrentStepComplete)")
                            payloadEntity.isEnabled = true
                            payloadEntity.opacity = 1
                            print("setting payloadEntity opacity to \(payloadEntity.opacity)")
                        }
                        if !dataModel.manualStepTransition {
                            print("manualStepTransition = \(dataModel.manualStepTransition)")
                            payloadEntity.opacity = 0
                            print("setting payloadEntity opacity to \(payloadEntity.opacity)")
                        }
                    }
                    
                    
                    // Restore payload setup code
                    for (index, element) in adcPayloadsInner.enumerated() {
                        element.isEnabled = index <= dataModel.payloadsWorkingIndex
                    }
                    for (index, element) in adcPayloadsOuter.enumerated() {
                        element.isEnabled = index <= dataModel.payloadsWorkingIndex
                        element.components.remove(ADCProximitySourceComponent.self)
                    }
                    adcPayloadsOuter[dataModel.payloadsWorkingIndex].components.set(ADCProximitySourceComponent())
                case 3:
                    // clicked checkmark to apply the material to all of the payloads
                    os_log(.debug, "ITR.. ✅ ADC build step 3 - checkmark to fill all payloads")
                    // If we came from checkmark button (all payloads filled)
                    // play animation sequence
                    if !dataModel.manualStepTransition {
                        print("dataModel.manualStepTransition = \(dataModel.manualStepTransition) Must play animation sequence")
                        Task { @MainActor in
                            if let antibodyRootEntity = antibodyRootEntity {
                                os_log(.debug, "ITR..🔍 Starting ADC animation sequence")
                                
                                if let adcComplexEntity = antibodyRootEntity.findEntity(named: "ADC_complex_001") {
                                    os_log(.debug, "ITR..Found ADC_complex_001, starting animation sequence")
                                    os_log(.debug, "ITR..Initial ADC position: %@", String(describing: adcComplexEntity.position))
                                    
                                    do {
                                        // Move antibody up
                                        try await adcComplexEntity.animatePosition(
                                            to: SIMD3(-0.4, 0, 0),
                                            duration: 1.0,
                                            timing: .easeInOut,
                                            waitForCompletion: true
                                        )
                                        os_log(.debug, "ITR..ADC position after move: %@", String(describing: adcComplexEntity.position))
                                        
                                        // Start rotation
                                        os_log(.debug, "ITR..Starting ADC rotation")
                                        adcComplexEntity.startContinuousRotation(speed: 0.5, axis: .xAxis)
                                        
                                        // Move main view back
                                        os_log(.debug, "ITR..Moving main view back to original position")
                                        try await mainViewEntity.animatePositionAndRotation(
                                            position: SIMD3(0.5, 0, -0.2),
                                            rotation: 0,
                                            duration: 1.0,
                                            timing: .easeInOut,
                                            waitForCompletion: true
                                        )
                                        os_log(.debug, "ITR..Main view returned to original position")
                                    } catch {
                                        os_log(.error, "ITR..❌ Animation sequence failed: %@", error.localizedDescription)
                                    }
                                } else {
                                    os_log(.error, "ITR..❌ Could not find ADC_complex_001 entity")
                                }
                            } else {
                                os_log(.error, "ITR..❌ No antibody root entity found")
                            }
                        }
                    }
                    

                    if dataModel.payloadsWorkingIndex == 4 {
                        Task { @MainActor in
                            // Play pop sound for successful placement
                            bubblePopSound.toggle()
                            
                            // Apply original materials and selected color to all payloads
                            for (inner, outer) in zip(adcPayloadsInner, adcPayloadsOuter) {
                                if let originalInnerMaterial = originalPayloadInnerMaterial {
                                    inner.updateMaterials { material in
                                        material = originalInnerMaterial
                                    }
                                }
                                if let originalOuterMaterial = originalPayloadOuterMaterial {
                                    outer.model?.materials = [originalOuterMaterial]
                                }
                                
                                inner.updatePBREmissiveColor(.adcEmissive[dataModel.selectedPayloadType ?? 0])
                                outer.updateShaderGraphColor(parameterName: "glowColor", color: .adc[dataModel.selectedPayloadType ?? 0])
                                
                                inner.isEnabled = true
                                outer.isEnabled = true
                            }
                            
                            // Only advance step after visuals are complete
                            // dataModel.adcBuildStep = 4
                            
                        }
                    }
                    
                    self.linkerEntity?.isEnabled = false
                    self.linkerAttachmentEntity?.isEnabled = false
                    self.payloadEntity?.isEnabled = false
                    antibodyRootEntity?.components.set(createGestureComponent())
                default:
                    os_log(.debug, "ITR.. ✅ ADC build step \(newValue)")
                    self.linkerEntity?.isEnabled = false
                    self.linkerAttachmentEntity?.isEnabled = false
                    self.payloadEntity?.isEnabled = false
                    antibodyRootEntity?.components.set(createGestureComponent())
                }
                
                
                    // Reset manual flag for future transitions
                    dataModel.manualStepTransition = false
                
            }
        }
        // Change the Antibody 3D model material color to the selected color
        .onChange(of: dataModel.selectedADCAntibody) { oldValue, newValue in
            os_log(.debug, "ITR..onChange(of: selectedADCAntibody): new value: \(newValue ?? -1)")
            handleAntibodyColorChange(newValue: newValue)
        }
        .onChange(of: dataModel.isVOPlaying) { oldValue, newValue in
            if !newValue {  // VO finished playing
                Task { @MainActor in
                    os_log(.debug, "ITR..VO finished playing, current step: \(dataModel.adcBuildStep)")
                    // Fade in the appropriate entities based on current step
                    switch dataModel.adcBuildStep {
                    case 0:  // Initial fade in of antibody
                        // if dataModel.adcBuildStep == 0 && !dataModel.hasInitialVOCompleted {
                        //     dataModel.hasInitialVOCompleted = true
                        //     // dataModel.showSelector = true
                        // }
                        dataModel.hasInitialVOCompleted = true
                        dataModel.antibodyVOCompleted = true
                        
                        
//                        try? await mainEntity.animatePosition(to: SIMD3(-0.125, 0, 0), duration: 1.0, delay: 0.0)
//                        os_log(.debug, "ITR..Attempting to animate main view position")
                        try? await mainViewEntity.animatePositionAndRotation(
                            position: SIMD3(-0.5, 0, 0.2),
                            rotation: 30,
                            duration: 1.0,
                            delay: 0.5
                        )
                        
                        // After position animation, fade in antibody with delay
                        if let antibodyEntity = antibodyEntity {
                            os_log(.debug, "ITR..antibodyEntity exists, fading in")
                            try? await antibodyEntity.fadeOpacity(to: 1, duration: 1.0, delay: 1.0)
                            antibodyEntity.isEnabled = true
                            os_log(.debug, "ITR..antibodyEntity fade complete, isEnabled set to true")
                        }
                    case 1:  // Fade in linker
                        // dataModel.showSelector = true
                        os_log(.debug, "ITR..Attempting to fade in linker entities")
                        if let linkerEntity = linkerEntity {
                            os_log(.debug, "ITR..linkerEntity exists, isEnabled: \(linkerEntity.isEnabled)")
                            // Fade in entities
                            try? await linkerEntity.fadeOpacity(to: 1, duration: 1.0)
                            linkerEntity.isEnabled = true
                            os_log(.debug, "ITR..linkerEntity fade complete, isEnabled set to true")
                        } else {
                            os_log(.error, "ITR..❌ linkerEntity is nil")
                        }
                    case 2:  // Fade in payload
                        // dataModel.showSelector = true
                        if let payloadEntity = payloadEntity {
                            os_log(.debug, "ITR..Attempting to fade in payloadEntity")
                            os_log(.debug, "ITR..payload.isEnabled: \(payloadEntity.isEnabled)")
                            try? await payloadEntity.fadeOpacity(to: 1, duration: 1.0)
                            payloadEntity.isEnabled = true
                        }
                    default:
                        os_log(.debug, "ITR..No fade needed for step \(dataModel.adcBuildStep)")
                    }
                    
                    await checkAndAdvanceStep()
                }
            }
        }
        // Change the linker 3D model material color to the selected color
        .onChange(of: dataModel.selectedLinkerType) { oldValue, newValue in
            Task { @MainActor in
                if let newValue {
                    // Update working (target) linker first
                    if let workingLinker {
                        // First restore original material
                        if let originalMaterial = originalLinkerMaterial {
                            if var modelComponent = workingLinker.components[ModelComponent.self] {
                                modelComponent.materials = [originalMaterial]
                                workingLinker.components[ModelComponent.self] = modelComponent
                            }
                        }
                        // Then apply color
                        workingLinker.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[newValue])
                    }
                    
                    // Update all previously placed linkers (up to current working index)
                    for index in 0..<dataModel.linkersWorkingIndex {
                        if let originalMaterial = originalLinkerMaterial {
                            if var modelComponent = adcLinkers[index].components[ModelComponent.self] {
                                modelComponent.materials = [originalMaterial]
                                adcLinkers[index].components[ModelComponent.self] = modelComponent
                            }
                        }
                        adcLinkers[index].updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[newValue])
                    }

                    // Change all linkers to the same color
                    for linker in adcLinkers {
                        linker.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[newValue])
                    }
                }
            }
        }
        // Change the payload inner and outer 3D model material color to the selected color
        .onChange(of: dataModel.selectedPayloadType) { oldValue, newValue in
            os_log(.debug, "ITR..onChange(of: dataModel.selectedPayloadType): New change selected working payload: \(newValue ?? -1)")
            guard dataModel.adcBuildStep == 2  else {
                os_log(.error, "ITR..onChange(of: dataModel.selectedPayloadType): ❌ Error, got a new value for selectedPayloadType: \(newValue ?? -1) but adcBuildStep is not 2")
                return
            }
            Task { @MainActor in
                if let newValue {
                    // Update working (target) payload first
                    if let workingPayloadInner,
                       let workingPayloadOuter {
                        // First restore original materials
                        if let originalInnerMaterial = originalPayloadInnerMaterial {
                            if var modelComponent = workingPayloadInner.components[ModelComponent.self] {
                                modelComponent.materials = [originalInnerMaterial]
                                workingPayloadInner.components[ModelComponent.self] = modelComponent
                            }
                        }
                        if let originalOuterMaterial = originalPayloadOuterMaterial {
                            if var modelComponent = workingPayloadOuter.components[ModelComponent.self] {
                                modelComponent.materials = [originalOuterMaterial]
                                workingPayloadOuter.components[ModelComponent.self] = modelComponent
                            }
                        }
                        // Then apply colors
                        workingPayloadInner.updatePBREmissiveColor(.adcEmissive[newValue])
                        workingPayloadOuter.updateShaderGraphColor(parameterName: "glowColor", color: .adc[newValue])
                    }
                    
                    // Change all payloads to the same color
                    for (inner, outer) in zip(adcPayloadsInner, adcPayloadsOuter) {
                        inner.updatePBREmissiveColor(.adcEmissive[newValue])
                        outer.updateShaderGraphColor(parameterName: "glowColor", color: .adc[newValue])
                    }
                }
            }
        }
        .onChange(of: bubblePopSound) { oldValue, newValue in
            os_log(.debug, "ITR..onChange(bubblePopSound): 🔊 SYSTEM 1 - Playing through popAudioPlaybackController")
            self.popAudioPlaybackController?.play()
        }

    }
    
    // MARK: - Step Management
    
    /// Checks conditions and advances to the next step if appropriate
    private func checkAndAdvanceStep() async {
        // Don't advance if VO is still playing
        guard !dataModel.isVOPlaying else { return }
        
        switch dataModel.adcBuildStep {
        case 1:  // Linker step
            // Check if we're on the last linker and it's been placed
            if dataModel.linkersWorkingIndex >= (adcLinkers.count - 1) {
                try? await Task.sleep(for: .milliseconds(500))
                dataModel.adcBuildStep = 2
                dataModel.selectedPayloadType = nil
            }
        case 2:  // Payload step
            // Check if we're on the last payload and it's been placed
            if dataModel.payloadsWorkingIndex >= (adcPayloadsInner.count - 1) {
                try? await Task.sleep(for: .milliseconds(500))
                dataModel.adcBuildStep = 3
            }
        default:
            break  // No auto-advancement for other steps
        }
    }
    
    // MARK: - Preparation

    private func handleAntibodyColorChange(newValue: Int?) {
        Task { @MainActor in
            guard let newValue = newValue,
                  let antibodyEntity = antibodyEntity else {
                os_log(.error, "ITR..handleAntibodyColorChange: ❌ Missing newValue or antibodyEntity")
                return
            }
            
            if var modelComponent = antibodyEntity.components[ModelComponent.self] {
                // First restore original material
                if let originalMaterial = originalAntibodyMaterial {
                    modelComponent.materials = [originalMaterial]
                    antibodyEntity.components[ModelComponent.self] = modelComponent
                    os_log(.debug, "ITR..handleAntibodyColorChange: ✅ Restored original material")
                }
                
                // Then apply the color
                antibodyEntity.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[newValue])
                os_log(.debug, "ITR..handleAntibodyColorChange: ✅ Applied color \(newValue)")
            }
        }
    }

    private func updateAttachmentEntities() {
        print("dataModel.isCurrentStepComplete: \(dataModel.isCurrentStepComplete)")
        let currentStepComplete = dataModel.isCurrentStepComplete
        linkerAttachmentEntity?.isEnabled = !currentStepComplete
        payloadAttachmentEntity?.isEnabled = !currentStepComplete
    }
    
    private func setupEntitiesAndMaterials() async {
        // Get outline material
        do {
            let materialEntity = try await Entity(named: "Materials/M_outline.usda", in: realityKitContentBundle)
            if let sphereEntity = materialEntity.findEntity(named: "Sphere"),
               let material = sphereEntity.components[ModelComponent.self]?.materials.first as? ShaderGraphMaterial {
                os_log(.debug, "ADCOptimizedImmersive: Successfully loaded outline material")
                self.outlineMaterial = material
            } else {
                os_log(.error, "ADCOptimizedImmersive: Could not find sphere or material in M_outline.usda")
            }
        } catch {
            os_log(.error, "ADCOptimizedImmersive: Failed to load outline material with error: %@", error.localizedDescription)
        }
        
        // Get antibody scene from asset manager
        do {
            let antibodyScene = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "antibody_scene",
                category: .buildADCEnvironment
            )
            os_log(.debug, "ADCOptimizedImmersive: Antibody scene loaded successfully")
            self.antibodyRootEntity = antibodyScene
            // Optionally log some identifying property:
            if let name = antibodyScene.name as String? {
                os_log(.debug, "ADCOptimizedImmersive: Antibody scene name: %@", name)
            }
            prepareAntibodyEntities()
            
            await prepareLinkerEntities()
            await preparePayloadEntities()
            if let rootEntity = antibodyRootEntity {
                prepareTargetEntities(antibodyScene: rootEntity)
            }
            
            self.adcLinkers.forEach { $0.isEnabled = false }
            
            // Create sort group for all ADC components
            self.adcSortGroup = ModelSortGroup(depthPass: .postPass)
            os_log(.debug, "ADCOptimizedImmersive: Created ADC sort group successfully")
        } catch {
            os_log(.error, "ADCOptimizedImmersive: Failed to load antibody scene with error: %@", error.localizedDescription)
        }
    }
}

```

File: AppModel/AppModel.swift
```swift
//
//  AppModel.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman
//

import SwiftUI
import RealityKit
import RealityKitContent
import ARKit
import os

// MARK: - App Constants
extension AppModel {
    nonisolated static let mainWindowId = "main"
    nonisolated static let introWindowId = "intro"
    nonisolated static let libraryWindowId = "library"
    nonisolated static let builderWindowId = "builder"
    nonisolated static let navWindowId = "DebugNavigation"
    nonisolated static let gameCompletedWindowId = "Completed"
    nonisolated static let hopeMeterUtilityWindowId = "HopeMeterUtility"
    
    nonisolated static let introSpaceId = "IntroSpace"
    nonisolated static let outroSpaceId = "OutroSpace"
    nonisolated static let labSpaceId = "LabSpace"
    nonisolated static let buildingSpaceId = "BuildingSpace"
    nonisolated static let attackSpaceId = "AttackSpace"
    
    // MARK: - Positioning Constants
    nonisolated static let defaultEntityPosition = SIMD3<Float>(0.0, -0.6, -1.0)
    
    // MARK: - Global UI Settings
    enum UIConstants {
        // Button Dimensions
        static let buttonCornerRadius: CGFloat = 16
        static let buttonPaddingHorizontal: CGFloat = 24
        static let buttonPaddingVertical: CGFloat = 16
        static let buttonExpandScale: CGFloat = 1.1
        static let buttonPressScale: CGFloat = 0.85
        
        // Animation Durations
        static let buttonHoverDuration: CGFloat = 0.2
        static let buttonPressDuration: CGFloat = 0.3
    }
}

enum AppPhase: String, CaseIterable, Codable, Sendable, Equatable {
    case loading
    case ready
    case intro
    case lab
    case building
    case playing
    case completed
    case outro
    case error
    
    var needsImmersiveSpace: Bool {
        return self != .loading && self != .error && self != .ready && self != .building 
    }
    
    var needsHandTracking: Bool {
        switch self {
        case .intro, .lab, .building, .playing:
            return true
        case .loading, .completed, .outro, .ready, .error:
            return false
        }
    }
    
    var shouldKeepPreviousSpace: Bool {
        if self == .completed { return true }
        return false
    }
    
    var spaceId: String {
        switch self {
        case .intro: return AppModel.introSpaceId
        case .lab: return AppModel.labSpaceId
        case .building: return AppModel.buildingSpaceId
        case .playing, .completed: return AppModel.attackSpaceId
        case .outro: return AppModel.outroSpaceId
        case .loading, .ready, .error: return ""
        }
    }
    
    var windowId: String {
        switch self {
        case .loading, .ready, .completed: return AppModel.mainWindowId
        case .intro: return AppModel.introWindowId
        case .lab: return AppModel.libraryWindowId
        case .building: return AppModel.builderWindowId
        case .playing, .outro, .error: return ""
        }
    }
    
    var instructionsWindowId: String? {
        switch self {
        case .playing: return AppModel.mainWindowId // Use main window for instructions
        default: return nil
        }
    }
}

@Observable
@MainActor
final class AppModel {
    // MARK: - Properties
    let trackingManager = TrackingSessionManager()
    
    var shouldDimSurroundings: Bool = false
    var hasBuiltADC: Bool = false
    
    /// Current phase of the app
    var currentPhase: AppPhase = .loading
    
    // MARK: - Immersive Space Management
    enum ImmersiveSpaceState {
        case closed
        case inTransition
        case open
    }
    
    enum DismissReason {
        case manual    // Our code dismissed it
        case system    // Digital Crown or system dismissed it
    }
    
    var immersiveSpaceState: ImmersiveSpaceState = .closed
    var immersiveSpaceDismissReason: DismissReason?
    var triggerImmersiveSpace = false
    
    var gameState: AttackCancerViewModel
    var introState: IntroViewModel
    var labState: LabViewModel
    var outroState: OutroViewModel
    var isNavWindowOpen = false
    var isHopeMeterUtilityWindowOpen = false
    var isLibraryWindowOpen = false
    var isIntroWindowOpen = false
    var isMainWindowOpen = false
    var isBuilderInstructionsOpen = false
    var isBuilderWindowOpen = false
    var isLoadingWindowOpen = false
    var readyToStartLab: Bool = false

    // MARK: - Immersion Style
    var introStyle: ImmersionStyle = .mixed
    var outroStyle: ImmersionStyle = .mixed
    var labStyle: ImmersionStyle = .full
    var buildingStyle: ImmersionStyle = .mixed
    var attackStyle: ImmersionStyle = .progressive(
        0.1...1.0,
        initialAmount: 1.0
    )

    // MARK: - Asset Management
    let assetLoadingManager = AssetLoadingManager.shared
    var loadingProgress: Float {
        switch assetLoadingManager.loadingState {
        case .notStarted:
            return 0
        case .loading(let progress):
            return progress
        case .completed:
            return 1
        case .error:
            return 0 // Or handle errors differently
        }
    }
    var displayedProgress: Float = 0.0 // Displayed progress for animation
    
    func toggleLibrary() {
        // Single source of truth for library state
        labState.isLibraryOpen.toggle()
    }
    
    func updateLibraryWindowState(isOpen: Bool) {
        isLibraryWindowOpen = isOpen
    }
    
    // MARK: - Space Management
    @ObservationIgnored private var currentImmersiveSpace: String?
    @ObservationIgnored private(set) var isTransitioning = false
    
    var hasImmersiveSpace: Bool {
        return currentImmersiveSpace != nil
    }
    
    // MARK: Start the Attack Cancer Game
    
    
    var shouldStartGame: Bool {
        gameState.tutorialComplete && gameState.isHopeMeterRunning
    }
    
    func startAttackCancerGame() {
        print("🎮 Starting Attack Cancer Game (startAttackCancerGame called)")
        print("Starting Hope Meter")
        startHopeMeter()
    }
    
    // MARK: - Hope Meter Management
    @ObservationIgnored private var hopeMeterTimer: Timer?
    
    func startHopeMeter() {
        print("🕒 Starting Hope Meter (startHopeMeter called)")
        stopHopeMeter() // Ensure any existing timer is cleaned up
        
        gameState.hopeMeterTimeLeft = gameState.hopeMeterDuration // Reset timer
        gameState.isHopeMeterRunning = true
        
        hopeMeterTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            
            Task { @MainActor in
                if self.gameState.hopeMeterTimeLeft > 0 {
                    self.gameState.hopeMeterTimeLeft -= 1
                } else {
                    self.stopHopeMeter()
                    await self.transitionToPhase(.completed)
                }
            }
        }
    }
    
    func stopHopeMeter() {
        print("🛑 Stopping Hope Meter")
        hopeMeterTimer?.invalidate()
        hopeMeterTimer = nil
        gameState.isHopeMeterRunning = false
    }
    
    @MainActor
    func accelerateHopeMeterToCompletion() async {
        print("🚀 Accelerating hope meter to completion")
        
        // Stop the normal timer
        hopeMeterTimer?.invalidate()
        hopeMeterTimer = nil
        
        // Animate the hope meter to completion using SwiftUI's withAnimation over 2 seconds.
        // This assumes that the UI is bound to gameState.hopeMeterTimeLeft.
        await MainActor.run {
            withAnimation(.easeInOut(duration: 2.0)) {
                gameState.hopeMeterTimeLeft = 0
            }
        }
        
        // Wait for 2 seconds after the animation completes.
        try? await Task.sleep(nanoseconds: 2_000_000_000)
        
        // Mark the hope meter as finished.
        await MainActor.run {
            gameState.isHopeMeterRunning = false
        }
    }
    
    deinit {
        // Since we're on MainActor, we can directly invalidate the timer
        hopeMeterTimer?.invalidate()
        hopeMeterTimer = nil
    }
    
    // MARK: - Initialization
    init() {
        self.gameState = AttackCancerViewModel()
        self.introState = IntroViewModel()
        self.labState = LabViewModel()
        self.outroState = OutroViewModel()
        
        // Set up dependencies
        self.gameState.appModel = self
        self.introState.appModel = self
        self.labState.appModel = self
        self.outroState.appModel = self
        self.gameState.handTracking = self.trackingManager.handTrackingManager
        print("AppModel init() - Instance: \(ObjectIdentifier(self))")
    }
    
    // MARK: - Phase Management
    @MainActor
    func transitionToPhase(_ newPhase: AppPhase, adcDataModel: ADCDataModel? = nil) async {
        print("🔄 Phase transition: \(currentPhase) -> \(newPhase)")
        print("🔍 isTransitioning: \(isTransitioning)")
        print("🔍 immersiveSpaceState: \(immersiveSpaceState)")
        guard !isTransitioning else {
            print("⚠️ Already transitioning, skipping")
            return
        }
        isTransitioning = true
        defer {
            isTransitioning = false
            print("✅ Phase transition completed: \(newPhase)")
        }

        // 1. Stop tracking if we're in a phase that uses it
        if currentPhase.needsHandTracking {
            trackingManager.stopTracking()
        }

        // 2. Pre-load assets for the *new* phase *before* any cleanup
        await preloadAssets(for: newPhase, adcDataModel: adcDataModel)

        if newPhase == .playing {
            // Before starting the playing session, reinitialize game state.
            gameState.resetCleanupForNewSession()
        }

        // 3. Clean up the *current* phase (guarantee completion with await)
        await cleanupCurrentPhase(for: newPhase)

        // 4. *Now* set the new phase
        currentPhase = newPhase

        // 5. Start tracking if the new phase needs it
        if newPhase.needsHandTracking {
            // Add a small delay to ensure ARKit has time to clean up
            try? await Task.sleep(for: .milliseconds(100))
            try? await trackingManager.startTracking(needsHandTracking: newPhase.needsHandTracking)
        }
    }

    private func preloadAssets(for phase: AppPhase, adcDataModel: ADCDataModel?) async {
        if phase == .playing {
            print("\n=== Pre-loading Playing Phase Assets ===")
            print("📱 Pre-loading required assets for playing phase...")
            if let adcDataModel = adcDataModel {
                do {
                    // Load and configure ADC template
                    print("🎯 Loading ADC template...")
                    let adcEntity = try await assetLoadingManager.instantiateAsset(
                        withName: "adc",
                        category: .adc
                    )
                    print("✅ ADC entity loaded, applying colors...")
                    gameState.setADCTemplate(adcEntity, dataModel: adcDataModel)
                    print("✅ ADC template configured with colors")

                    // Ensure tutorial asset is loaded and cached
                    print("🎯 Loading tutorial assets...")
                    _ = try await assetLoadingManager.instantiateAsset(
                        withName: "game_start_vo",
                        category: .attackCancerEnvironment
                    )
                    print("✅ Tutorial assets cached")

                    // ADDED: Load and cache attack_cancer_environment
                    print("🎯 Loading attack_cancer_environment...")
                    _ = try await assetLoadingManager.instantiateAsset(
                        withName: "attack_cancer_environment",
                        category: .attackCancerEnvironment
                    )
                    print("✅ attack_cancer_environment cached")
                    try? await Task.sleep(for: .milliseconds(100)) // Small delay
                    print("✅✅✅ Playing Phase Assets Ready (with delay) ===\n") // More emphatic message

                } catch {
                    print("❌ Failed to load playing phase assets: \(error)")
                }
            } else {
                print("❌ No ADCDataModel available for playing phase")
            }
        } else if phase == .outro {
            print("\n=== Pre-loading Outro Phase Assets ===")
            print("📱 Pre-loading outro environment...")
            do {
                _ = try await assetLoadingManager.instantiateAsset(
                    withName: "outro_environment",
                    category: .outroEnvironment
                )
                print("✅ Outro environment cached")
                print("=== Outro Phase Assets Ready ===\n")
            } catch {
                print("❌ Failed to pre-load outro environment: \(error)")
            }
        } else if phase == .building {
            os_log(.debug, "AppModel: Preloading Building Phase Assets...")
            // Optionally trigger a preloading for building assets if needed (for example, loading "antibody_scene" here)
            do {
                let scene = try await assetLoadingManager.instantiateAsset(
                    withName: "antibody_scene",
                    category: .buildADCEnvironment
                )
                os_log(.debug, "AppModel: Preloaded antibody_scene for Building Phase: %@", String(describing: scene))
            } catch {
                os_log(.error, "AppModel: Failed to preload Building Phase asset 'antibody_scene': %@", error.localizedDescription)
            }
        }
    }


    private func cleanupCurrentPhase(for newPhase: AppPhase) async {
        switch currentPhase {
        case .intro:
            // now that intro and lab are combined, we need to cleanup both
            introState.cleanup()
            await assetLoadingManager.releaseIntroEnvironment()
            labState.cleanup()
            await assetLoadingManager.releaseLabEnvironment()
        case .lab:
            labState.cleanup()
            await assetLoadingManager.releaseLabEnvironment()
        case .playing:
            if newPhase != .completed {
                print("I am in the playing phase and I am not transitioning to completed so I am cleaning up")
                await gameState.cleanup()
                await assetLoadingManager.releaseAttackCancerEnvironment()
            } else {
                print("I am in the playing phase and transitioning to completed, so preserving immersive assets")
            }
        case .completed:
            if newPhase != .outro {
                print("I am in the completed phase and transitioning to \(newPhase); cleaning up normally.")
                await gameState.cleanup()
                await assetLoadingManager.releaseAttackCancerEnvironment()
            } else {
                print("Transitioning from completed to outro; preserving immersive assets for AttackCancerView.")
                // Do not call cleanup so that the completed phase's assets remain for the outro.
            }
        case .outro:
            outroState.cleanup()
            await assetLoadingManager.releaseOutroEnvironment()
        case .ready, .loading, .building, .error:
            break // No cleanup needed.
        }
    }
    
    var isTutorialStarted: Bool = false
    
    // Track instruction window state
    var isInstructionsWindowOpen = false
    
    func startTutorial() {
        isTutorialStarted = true
        
    }
}

```

File: AppModel/AppModel+AssetLoading.swift
```swift
//
//  AppModel+AssetLoading.swift
//  SpawnAndAttrack
//
//  Created by Dale Carman on 12/10/24.
//

import SwiftUI

// Define a generic error to use
enum AppError: Error {
    case genericLoadingError
}

extension AppModel {
    // MARK: - Asset Loading
    
    var isLoadingAssets: Bool {
        if case .loading = assetLoadingManager.state {
            return true
        }
        return false
    }
    
    var assetsLoaded: Bool {
        if case .completed = assetLoadingManager.state {
            return true
        }
        return false
    }
    
    struct AssetToLoad {
        let name: String
        let category: AssetCategory
        let weight: Float  // Relative weight for progress calculation
    }
    
    func startLoading() async {
        print("\n=== Starting Initial Asset Loading ===")
        print("🔍 Current phase: \(currentPhase)")
        print("🔍 Loading state: \(assetLoadingManager.loadingState)")
        do {
            print("🔄 Starting prepareIntroPhase...")
            try await prepareIntroPhase()
            print("✅ prepareIntroPhase completed")
            print("🔄 Transitioning to .ready...")
            await transitionToPhase(.ready)
            print("✅ Transition to .ready completed")
        } catch {
            print("❌ Error loading initial assets: \(error)")
            assetLoadingManager.loadingState = .error(error)
            await transitionToPhase(.error)
        }
    }
    
    func prepareIntroPhase() async {
        print("\n=== Preparing Intro Phase ===")
        print("🔍 Current phase before loading: \(currentPhase)")
        print("🔍 Loading state: \(assetLoadingManager.loadingState)")
        
        var introAssets: [String] = []
        introAssets.append(contentsOf: [
            "intro_environment",
            "intro_warp",
        ])
        
        var attackAssets: [String] = []
        attackAssets.append(contentsOf: [
            "attack_cancer_environment",
            "adc",
            "cancer_cell"
        ])
        
        var labAssets: [String] = []
        labAssets.append(contentsOf: [
            "assembled_lab"
        ])
        
        let allAssets = introAssets + attackAssets + labAssets
        
        var completedAssets = 0
        
        // Load intro environment assets
        for key in allAssets {
            print("📱 Loading asset: \(key)")
            
            let category: AssetCategory
            if introAssets.contains(key) {
                category = .introEnvironment
            } else if attackAssets.contains(key) {
                category = .attackCancerEnvironment
            } else if labAssets.contains(key) {
                category = .labEnvironment
            } else {
                // Default case, should not happen
                print("⚠️ Unknown asset category for key: \(key)")
                continue
            }
            
            do {
                _ = try await assetLoadingManager.loadAsset(withName: key, category: category)
                completedAssets += 1
                let progress = Float(completedAssets) / Float(allAssets.count)
                print("✅ Loaded \(key) - Progress: \(progress)")
            } catch {
                print("❌ Failed to load \(key): \(error)")
                // Use the generic error here
                assetLoadingManager.loadingState = .error(AppError.genericLoadingError)
                return // Exit the function on error
            }
        }
        print("✅ prepareIntroPhase completed")
    }
}

```

File: ViewModels/IntroViewModel/IntroViewModel.swift
```swift
import Foundation
import RealityKit
import RealityKitContent
import SwiftUI

@Observable
@MainActor
final class IntroViewModel {
    // MARK: - Properties
    var introRootEntity: Entity?
    var scene: RealityKit.Scene?
    
    // Animation control flags
    var shouldUseSky = true  // New flag to control sky animation
    var skyDarkness: Float = 0.98
    
    // Animation task tracking
    private var animationTask: Task<Void, Never>?
    
    // Entity references
//    private var portalWarp: Entity?
    private var portal: Entity?
    private var skyDome: Entity?
    private var logo: Entity?
    private var titleRoot: Entity?
    private var material: ShaderGraphMaterial?
    private var assembledLab: Entity?
    private var introEnvironment: Entity?
    
    // Attachment entities
    var titleEntity: Entity?
    // var labViewerEntity: Entity?
    var navToggleEntity: Entity?
    
    // Animation States
    var showTitleText = false
    var shouldDimSurroundings = false
    var isSetupComplete = false
    
    // New flag to prevent duplicate environment loading
    var environmentLoaded = false
    
    // Dependencies
    var appModel: AppModel!
    
    // Root setup flags
    var isRootSetupComplete = false
    var isEnvironmentSetupComplete = false
    var isHeadTrackingRootReady = false
    var shouldUpdateHeadPosition = false
    var isPositioningComplete = false
    
    var isReadyForInteraction: Bool {
        isRootSetupComplete && 
        isEnvironmentSetupComplete && 
        isHeadTrackingRootReady
    }
    
    // MARK: - Setup Methods
    func setupRoot() -> Entity {  // Renamed from setupIntroRoot
        // Reset state tracking first
        isRootSetupComplete = false
        isEnvironmentSetupComplete = false
        isHeadTrackingRootReady = false
        isPositioningComplete = false
        
        Logger.info("🔄 Starting new intro session: tracking states reset")
        Logger.info("📱 IntroViewModel: Setting up root")
        
        let root = Entity()
        root.name = "IntroRoot"
        root.position = AppModel.defaultEntityPosition
        
        root.components.set(PositioningComponent(
            offsetX: 0,
            offsetY: -1.5,  // Maintain intro's specific offset
            offsetZ: -1.0,
            needsPositioning: false,
            shouldAnimate: false,
            animationDuration: 0.0
        ))
        
        Logger.info("""
        
        ✅ Root Setup Complete
        ├─ Root Entity: \(root.name)
        ├─ Position: \(root.position(relativeTo: nil))
        └─ Positioning: Ready for explicit updates
        """)
        
        introRootEntity = root
        isRootSetupComplete = true
        isHeadTrackingRootReady = true
        return root
    }
    
    // MARK: - Setup Environment
    func setupEnvironment(in root: Entity) async {
        print("📱 IntroViewModel: Starting environment setup")
        
        // Load intro environment using on-demand API through appModel.assetLoadingManager
        print("📱 IntroViewModel: Attempting to load intro environment")
        var environment: Entity
        do {
            environment = try await appModel.assetLoadingManager.instantiateAsset(withName: "intro_environment", category: AssetCategory.introEnvironment)
            print("✅ IntroViewModel: Successfully loaded intro environment")
            // Add environment to root
            introEnvironment = environment
            print("📱 IntroViewModel: Adding environment to root")
            root.addChild(environment)
            
            isEnvironmentSetupComplete = true
            print("✅ Environment setup complete")
        } catch {
            print("❌ IntroViewModel: Error loading intro environment: \(error)")
            return
        }
        
        // Find and setup entities
        print("📱 IntroViewModel: Setting up individual entities")
        setupSkyDome(in: environment)
//        await setupPortalWarp(in: environment)
        await setupPortal(in: root)
        
        print("✅ IntroViewModel: Environment setup complete")
    }
    
    func setupAttachments(in environment: Entity, for portal: Entity, titleEntity: Entity, labViewerEntity: Entity? = nil) {
        if let l = environment.findEntity(named: "logo") {
                print("🔍 Found logo: \(l.name)")
                logo = l
                l.scale = SIMD3<Float>(0.5, 0.5, 0.5)
                l.opacity = 0
                print("✅ Set logo scale to 0.5 and opacity to 0")

                // Add text attachment to titleRoot
                if let t = environment.findEntity(named: "outdoCancer") {
                titleRoot = t
                print("📎 Created titleRoot")
                // print("🔍 Before - titleEntity position: \(titleEntity.position), scale: \(titleEntity.transform.scale)")
                // titleEntity.position = [0, -1.2, 0.1]
                // titleEntity.transform.scale *= 10.0
                print("🔍 After - titleEntity position: \(titleEntity.position), scale: \(titleEntity.transform.scale)")
                t.addChild(titleEntity)

                l.addChild(t)
                print("📎 Added titleText to titleRoot")

            } else {
                print("❌ Could not find logo in environment")
            }
        }
    }
    
    // MARK: - Private Setup Methods
    private func setupSkyDome(in environment: Entity) {
        if let sky = environment.findEntity(named: "SkySphere") {
            print("🔍 Found skyDome: \(sky.name)")
            skyDome = sky
            sky.opacity = 0
            print("✅ Set skyDome opacity to 0")
        } else {
            print("❌ Could not find SkySphere in environment")
        }
    }
    
//    private func setupPortalWarp(in environment: Entity) async {
//        if let warp = environment.findEntity(named: "sh0100_v01_portalWarp3") {
//            print("🔍 Found portalWarp: \(warp.name)")
//            portalWarp = warp
//            warp.opacity = 0
//            print("✅ Set portalWarp opacity to \(warp.opacity)")
//            
//            // Find and store shader material
//            if let component = warp.components[ModelComponent.self],
//               let material = component.materials.first as? ShaderGraphMaterial {
//                self.material = material
//                print("✅ Found and stored shader material")
//            }
//        } else {
//            print("❌ Could not find portalWarp in environment")
//        }
//    }
    
    private func setupPortal(in root: Entity) async {
        print("📱 IntroViewModel: Starting portal setup")
        do {
            // Load assembled lab using loadAssembledLab
            let labEnvironment = try await appModel.assetLoadingManager.loadAssembledLab()
            print("✅ IntroViewModel: Successfully loaded assembled laboratory environment")
            
            assembledLab = labEnvironment
            assembledLab?.name = "assembled_lab"
            
            // Create portal with loaded environment
            let p = await PortalManager.createPortal(
                appModel: appModel,
                environment: labEnvironment,
                portalPlaneName: "Plane_001"
            )
            print("✅ IntroViewModel: Created portal")
            
            // Store and configure portal
            portal = p
            p.opacity = 0.0
            p.position = [0, -0.25, 0]
            root.addChild(p)
            print("✅ IntroViewModel: Portal setup complete")
            
        } catch {
            print("❌ IntroViewModel: Failed to load laboratory environment: \(error)")
            // Handle specific error cases
            if let assetError = error as? AssetError {
                switch assetError {
                case .resourceNotFound:
                    print("❌ IntroViewModel: Lab environment resource not found")
                case .protobufError(let name):
                    print("❌ IntroViewModel: Protobuf error loading lab environment: \(name)")
                default:
                    print("❌ IntroViewModel: Asset error loading lab environment: \(assetError)")
                }
            }
        }
    }
    
    // MARK: - Positioning Refresh
    /// Refreshes the position of the introRootEntity based on the current device anchor.
    /// Called at the moment the user starts the animation sequence.
    private func refreshPosition() async {
        guard let root = introRootEntity else {
            print("❌ refreshPosition: introRootEntity is nil.")
            return
        }

        guard let posComponent = root.components[PositioningComponent.self] else {
            print("❌ refreshPosition: No PositioningComponent on introRootEntity.")
            return
        }

        // Query the device anchor from the tracking manager.
        guard let deviceAnchor = appModel.trackingManager.worldTrackingProvider.queryDeviceAnchor(atTimestamp: CACurrentMediaTime()) else {
            print("❌ refreshPosition: Device anchor unavailable. Using fallback position.")
            let fallback = SIMD3<Float>(posComponent.offsetX, posComponent.offsetY, posComponent.offsetZ)
            root.setPosition(fallback, relativeTo: nil)
            return
        }

        let deviceTransform = deviceAnchor.originFromAnchorTransform
        let translation = deviceTransform.translation()
        let translationLength = simd_length(translation)

        // Check if the translation seems valid.
        if translationLength < 0.01 {
            print("❌ refreshPosition: Device translation too small (\(translation)). Using fallback.")
            let fallback = SIMD3<Float>(posComponent.offsetX, posComponent.offsetY, posComponent.offsetZ)
            root.setPosition(fallback, relativeTo: nil)
            return
        }

        if translationLength > 10.0 {
            print("❌ refreshPosition: Device translation unusually high (\(translation)). Using fallback.")
            let fallback = SIMD3<Float>(posComponent.offsetX, posComponent.offsetY, posComponent.offsetZ)
            root.setPosition(fallback, relativeTo: nil)
            return
        }

        // Compute the final position using the offsets from PositioningComponent.
        let newPosition = SIMD3<Float>(
            translation.x + posComponent.offsetX,
            translation.y + posComponent.offsetY,
            translation.z + posComponent.offsetZ
        )
        root.setPosition(newPosition, relativeTo: nil)
        print("✅ refreshPosition: Updated introRootEntity position to \(newPosition)")

        // Optionally mark as positioned to prevent further automatic updates.
        var updatedComponent = posComponent
        updatedComponent.needsPositioning = false
        root.components[PositioningComponent.self] = updatedComponent
    }

    // Refresh the position at the moment the user initiates the animation sequence.
            // await refreshPosition()
    
    // MARK: - Animation Methods
    func runAnimationSequence() async {
        // // Request head position update before starting animation sequence
        // shouldUpdateHeadPosition = true
        
        // Cancel any existing animation task
        animationTask?.cancel()
        
        // Create new animation task
        animationTask = Task { @MainActor in
            let start = Date()
            print("🎬 Animation Sequence: Starting at \(start)")
            print("🔍 Entity Check - skyDome: \(skyDome != nil), logo: \(logo != nil), portal: \(portal != nil)")
            
            // Example helper guard to ensure an entity is still in the scene (if needed)
            func ensureValidEntity(_ entity: Entity?, with name: String) -> Bool {
                if let e = entity, e.parent != nil {
                    return true
                } else {
                    print("⚠️ Entity \(name) is no longer valid or not attached.")
                    return false
                }
            }
            
            // Check for cancellation before each animation step
            guard !Task.isCancelled else {
                print("🛑 Animation sequence cancelled before sky fade")
                return
            }
            
            // Sky fade animation
            if shouldUseSky {
                print("🌌 Sky: Starting at +\(Date().timeIntervalSince(start))s")
                if let s = skyDome {
                    print("🔍 Sky initial opacity: \(s.opacity)")
                    await s.fadeOpacity(to: skyDarkness, duration: 10.0)
                    print("🌌 Sky: Completed fade animation")
                    print("🔍 Sky final opacity: \(s.opacity)")
                } else {
                    print("❌ Sky: skyDome not found")
                }
            }
            
            // Portal warp fade (24s)
            print("⏰ Sleeping for 29s before portal warp")
            try? await Task.sleep(for: .seconds(29)) // changed from 19 to 29 since removed portalWarp
            
            // Check that portalWarp is still valid
//            guard ensureValidEntity(portalWarp, with: "portalWarp") else { return }
//            print("🌀 Portal warp: Starting at +\(Date().timeIntervalSince(start))s")
//            print("🔍 PortalWarp reference check: \(portalWarp != nil)")
//            if let warp = portalWarp {
//                print("🔍 Warp initial opacity: \(warp.opacity)")
//                await warp.fadeOpacity(to: 0.1, duration: 10.0)
//                print("🌀 Portal warp: Completed fade animation")
//                print("🔍 Warp final opacity: \(warp.opacity)")
//            } else {
//                print("❌ Portal warp: portalWarp not found")
//            }
            
            guard !Task.isCancelled else {
                print("🛑 Animation sequence cancelled before logo")
                return
            }
            
            // Logo and title sequence
            print("⏰ Sleeping for 75s before logo")
            try? await Task.sleep(for: .seconds(75))
            
            // Verify logo validity before animating
            guard ensureValidEntity(logo, with: "logo") else { return }
            print("🎯 Logo: Starting at +\(Date().timeIntervalSince(start))s")
            print("🔍 Logo reference check: \(logo != nil)")
            if let l = logo {
                print("🔍 Logo initial opacity: \(l.opacity)")
                await l.fadeOpacity(to: 1.0, duration: 10.0)
                print("🎯 Logo: Completed fade animation")
                print("🔍 Logo final opacity: \(l.opacity)")
                try? await Task.sleep(for: .seconds(5))
                print("📝 Title: Showing at +\(Date().timeIntervalSince(start))s")
                print("About to set showTitleText, current value: \(showTitleText)")
                
                // Small delay to let the view hierarchy settle before updating the flag
                try? await Task.sleep(for: .milliseconds(100))
                withAnimation(.easeInOut(duration: 0.5)) {
                    showTitleText = true
                }
                print("Updated showTitleText to \(showTitleText)")
            } else {
                print("❌ Logo: logo not found")
            }
            
            guard !Task.isCancelled else {
                print("🛑 Animation sequence cancelled before portal")
                return
            }
            
            // Portal sequence
            print("🌐 Portal: Starting at +\(Date().timeIntervalSince(start))s")
            guard ensureValidEntity(portal, with: "portal") else { return }
            print("🔍 Portal reference check: \(portal != nil)")
            if let p = portal {
                print("🔍 Portal initial opacity: \(p.opacity)")
                await p.fadeOpacity(to: 1.0, duration: 5.0)
                print("🌐 Portal: Completed fade animation")
                print("🔍 Portal final opacity: \(p.opacity)")
                try? await Task.sleep(for: .seconds(5.0))
                
                // Perform the original portalPlane X-scale animation
                if let portalPlane = p.findEntity(named: "portalPlane") {
                    print("🌐 Portal plane: Starting X scale animation at +\(Date().timeIntervalSince(start))s")
                    await portalPlane.animateXScale(from: 0, to: 1.0, duration: 1.0)
                    print("🌐 Portal plane: Completed X scale animation")
                } else {
                    print("❌ Portal plane: portalPlane not found")
                }

                // Wait 2 seconds after portalPlane animation finishes
                try? await Task.sleep(for: .seconds(2.0))

                // Concurrent animations – first verify that all required entities are still valid.
                guard let portalRoot = p.findEntity(named: "portalRoot"),
                      let portalWorld = p.findEntity(named: "world"),
                      let portalPlane2 = p.findEntity(named: "portalPlane"),
//                      ensureValidEntity(portalWarp, with: "portalWarp"),
                      ensureValidEntity(introEnvironment, with: "introEnvironment"),
                      ensureValidEntity(introRootEntity, with: "introRootEntity"),
                      let extras = introRootEntity?.findEntity(named: "ExtraItems"),
                      ensureValidEntity(logo, with: "logo"),
                      ensureValidEntity(titleRoot, with: "titleRoot"),
                      ensureValidEntity(skyDome, with: "skyDome")
                else {
                    print("❌ One or more entities for concurrent animations not found.")
                    if p.findEntity(named: "portalRoot") == nil {
                        print("❌ PortalRoot not found")
                    }
                    if p.findEntity(named: "world") == nil {
                        print("❌ World not found")
                    }
                    if p.findEntity(named: "portalPlane") == nil {
                        print("❌ PortalPlane not found")
                    }
                    return
                }

                print("🌐 Starting concurrent animations for PortalRoot, World, and PortalPlane scale")
                let moveDuration = 20.0
                
                async let _: () = skyDome!.fadeOpacity(to: 0.0, duration: 10.0)
//                async let _: () = portalWarp!.fadeOpacity(to: 0.0, duration: 10.0)
                async let _: () = logo!.fadeOpacity(to: 0.0, duration: 3.0)
                async let _: () = titleRoot!.fadeOpacity(to: 0.0, duration: 3.0)
                async let animatePortalRoot: () = portalRoot.animateAbsolutePositionAndScale(
                    to: SIMD3<Float>(0, 0, 0),
                    scale: SIMD3<Float>(1, 1, 1),
                    duration: moveDuration,
                    timing: .easeInOut,
                    waitForCompletion: true
                )

                async let animateWorld: () = portalWorld.animateAbsolutePositionAndScale(
                    to: SIMD3<Float>(0, 0.25, 1),
                    scale: SIMD3<Float>(1, 1, 1),
                    duration: moveDuration,
                    timing: .easeInOut,
                    waitForCompletion: true
                )

                async let animatePortalPlaneScale: () = portalPlane2.animateScale(
                    to: 20.0,
                    duration: moveDuration,
                    timing: .easeInOut,
                    waitForCompletion: true
                )
                
                // async let animatePortalPlanePosition: () = portalPlane2.animatePosition(
                //     to: SIMD3<Float>(0, 0, -10),
                //     duration: moveDuration
                // )

                _ = await (animatePortalRoot, animateWorld, animatePortalPlaneScale)
                
                print("🌐 Completed concurrent animations for PortalRoot, World, and PortalPlane scale")
                
                // Fade out the introEnvironment
//                print("introEnvironment opacity started at \(introEnvironment!.opacity)")
//                await introEnvironment!.fadeOpacity(to: 0.0, duration: 5.0)
//                print("introEnvironment opacity faded out to \(introEnvironment!.opacity)")

                // Wait for 5 seconds
                try? await Task.sleep(for: .seconds(5))
                
                // Unparent the portalWorld from the portal and reparent it to the root while preserving its transform
                if let lab = assembledLab {
                    // Capture the current transform of the lab in world space
                    let worldTransform = lab.transformMatrix(relativeTo: nil)
                    
                    // Remove the lab from its current parent
                    lab.removeFromParent()
                    
                    // Reparent the lab to the intro root entity
                    introRootEntity!.addChild(lab)
                    print("🛑 assembledLab position in world space PRE-TRANSFORM FIX is \(lab.position(relativeTo: nil))")
                    
                    // Restore the lab's transform
                    lab.setTransformMatrix(worldTransform, relativeTo: nil)
                    print("✅ assembledLab position in world space is \(lab.position(relativeTo: nil))")
                }

                // Change the portal component to spill out into the world
                if var portalComponent = portalPlane2.components[PortalComponent.self] {
                    portalComponent.crossingMode = .plane(.positiveZ)
                    portalPlane2.components.set(portalComponent)
                } else {
                    print("❌ PortalComponent not found on portalPlane2.")
                }
                
                if let portalEnv = self.portal {
                    print("\n 🔍 Inspecting portal hierarchy \n")
                    self.appModel.assetLoadingManager.inspectEntityHierarchy(portalEnv)
                    portalEnv.removeFromParent()
                    self.portal = nil
                    print("Removed portal completely from the scene as we transition to lab.")
                }

                if let introEnv = introEnvironment {
                    introEnv.removeFromParent()
                    introEnvironment = nil
                    print("Removed introEnvironment completely from the scene as we transition to lab.")
                }
                
                // Enable large room reverb and inspect hierarchy
                introRootEntity!.enableLargeRoomReverb()
                // appModel.assetLoadingManager.inspectEntityHierarchy(introRootEntity!)

                appModel.readyToStartLab = true
                print("readyToStartLab set to \(appModel.readyToStartLab)")
                
            } else {
                print("❌ Portal: portal not found")
            }
            
            print("🎬 Animation Sequence: Completed at +\(Date().timeIntervalSince(start))s")
        }
    }
    
    // MARK: - Entity Access Methods
    func getPortal() -> Entity? {
        return portal
    }
    
    // MARK: - Cleanup
    func cleanup() {
        print("\n=== Starting IntroViewModel Cleanup ===")
        
        // First, cancel any running animation task
        print("🛑 Cancelling animation sequence")
        animationTask?.cancel()
        animationTask = nil
        
        // Clear root entity and scene
        if let root = introRootEntity {
            print("🗑️ Removing intro root entity")
            // Reset positioning component before removal
            if var positioningComponent = root.components[PositioningComponent.self] {
                print("🎯 Resetting positioning component")
                positioningComponent.needsPositioning = true
                root.components[PositioningComponent.self] = positioningComponent
            }
            root.removeFromParent()
        }
        introRootEntity = nil
        
        // Clear scene reference
        scene = nil
        
        // Clear entity references
//        portalWarp = nil
        portal = nil
        skyDome = nil
        logo = nil
        material = nil
        
        // Clear attachment entities
        titleEntity = nil
        navToggleEntity = nil
        
        // Reset state flags
        showTitleText = false
        shouldDimSurroundings = false
        isSetupComplete = false
        environmentLoaded = false
        isPositioningComplete = false
        
        print("✅ Completed IntroViewModel cleanup\n")
    }
}

```

File: ViewModels/LabViewModel/LabViewModel.swift
```swift
//
//  LabViewModel.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/23/25.
//

import Foundation
import RealityKit
import RealityKitContent
import SwiftUI

@Observable
@MainActor
final class LabViewModel {
    // MARK: - Properties
    var mainEntity: Entity?
    var scene: RealityKit.Scene?
    
    // Entity references
    private var labAudioEntity: Entity?
    
    // Attachment entities
    var adcBuilderViewerButtonEntity: Entity?
    var attackCancerViewerButtonEntity: Entity?
    
    // State
    var isSetupComplete = false
    var isLibraryOpen = false
    var shouldShowADCButton = false
    
    // Dependencies
    var appModel: AppModel!
    
    // MARK: - Setup Methods
    func setupRoot() -> Entity {
        print("📱 LabViewModel: Setting up root entity")
        let root = Entity()
        root.name = "MainEntity"
        root.components.set(PositioningComponent(
            offsetX: 0,
            offsetY: -1.425,
            offsetZ: -0.25
        ))
        mainEntity = root
        print("✅ LabViewModel: Root entity configured")
        return root
    }
    
    func setupInitialLabEnvironment(in root: Entity, isIntro: Bool? = nil) async throws {
        print("📱 LabViewModel: Setting up initial environment")
        
        if isIntro != nil {
            // Intro mode - find existing lab and configure devices
            let labEnvironment = root.findEntity(named: "assembled_lab")!
            configureInteractiveDevices(in: labEnvironment)
        } else {
            // Lab mode - load and set up the complete lab
            guard let root = mainEntity else {
                print("❌ LabViewModel: No root entity for initial environment")
                return
            }
            
            // Load the complete assembled lab
            print("📱 Loading assembled lab environment")
            let labEnvironment = try await appModel.assetLoadingManager.loadAssembledLab()
            root.addChild(labEnvironment)
            print("🏢 Assembled Lab Environment added to MainEntity")
            print("📍 Lab Environment position: \(labEnvironment.position)")
            
            // Configure the interactive devices
            configureInteractiveDevices(in: labEnvironment)
        }
    }
    
    // MARK: - Environment Setup
    func setupLabEnvironment(in root: Entity, isIntro: Bool? = nil) async throws {
        Logger.info("\n=== Lab Environment Setup ===")
        Logger.info("📱 LabViewModel: Starting environment setup")
        Logger.info("🔍 isIntro parameter: \(String(describing: isIntro))")
        
        if isIntro == nil {
            // Lab mode - check for main entity
            guard mainEntity != nil else {
                Logger.error("❌ LabViewModel: No root entity for environment setup")
                throw AssetError.resourceNotFound
            }
        }
        
        Logger.info("🔍 Current appModel.hasBuiltADC: \(appModel.hasBuiltADC)")
        
        // Set ADC button visibility based on previous build
        shouldShowADCButton = appModel.hasBuiltADC
        Logger.info("🎯 ADC Button visibility set to: \(shouldShowADCButton)")
        
        Logger.info("\n🎙️ Attempting to load lab VO...")
        do {
            let labVO = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "lab_vo",
                category: .labEnvironment
            )
            Logger.info("✅ Lab VO asset loaded successfully")
            root.addChild(labVO)
            Logger.info("✅ Lab VO added to root entity")
        } catch {
            Logger.error("❌ Failed to load lab VO: \(error)")
        }
        
        // Only start the timer for ADC button if it's not already visible
        if !shouldShowADCButton {
            Logger.info("""
            
            ⏲️ Starting 30-second timer for ADC button visibility
            ├─ Current shouldShowADCButton: \(shouldShowADCButton)
            └─ hasBuiltADC: \(appModel.hasBuiltADC)
            """)
            Task {
                try? await Task.sleep(for: .seconds(38))
                Logger.info("⏲️ Timer complete - showing ADC button")
                withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {
                    shouldShowADCButton = true
                }
            }
        } else {
            Logger.info("""
            
            🎯 Skipping ADC button timer
            ├─ Current shouldShowADCButton: \(shouldShowADCButton)
            └─ hasBuiltADC: \(appModel.hasBuiltADC)
            """)
        }
        
        Logger.info("\n🔊 Loading lab audio...")
        do {
            let labAudio = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "lab_audio",
                category: .labEnvironment
            )
            root.addChild(labAudio)
            labAudioEntity = labAudio
            Logger.info("✅ Lab Audio added to MainEntity")
        } catch {
            Logger.error("❌ Failed to load lab audio: \(error)")
        }
        
        isSetupComplete = true
        Logger.info("""
        
        ✅ Lab Environment Setup Complete
        ├─ isSetupComplete: \(isSetupComplete)
        ├─ shouldShowADCButton: \(shouldShowADCButton)
        └─ hasBuiltADC: \(appModel.hasBuiltADC)
        """)
    }
    
    // MARK: - Attachment Setup
    func setupAttachments(attachments: RealityViewAttachments) {
        // Setup ADC Builder Button
        if let adbBuilderView = attachments.entity(for: "ADCBuilderViewerButton") {
            print("🔧 ADCBuilderViewerButton attachment created")
            if let builderTarget = mainEntity?.findEntity(named: "ADCBuilderAttachment") {
                print("🔧 Found ADCBuilderAttachment entity at position: \(builderTarget.position)")
                builderTarget.addChild(adbBuilderView)
                adbBuilderView.components.set(BillboardComponent())
                adcBuilderViewerButtonEntity = adbBuilderView
            } else {
                print("❌ ADCBuilderAttachment entity not found in scene")
            }
        }
        
        // Setup Attack Cancer Button
        if let attackCancerView = attachments.entity(for: "AttackCancerViewerButton") {
            print("🎯 AttackCancerViewerButton attachment created")
            if let attackTarget = mainEntity?.findEntity(named: "AttackCancerAttachment") {
                print("🎯 Found AttackCancerAttachment entity at position: \(attackTarget.position)")
                attackTarget.addChild(attackCancerView)
                attackCancerView.components.set(BillboardComponent())
                attackCancerViewerButtonEntity = attackCancerView
            }
        }
    }
    
    // MARK: - Interactive Devices
    private func findInteractiveDevices(in root: Entity) -> [(entity: Entity, meshEntity: Entity)] {
        var results: [(Entity, Entity)] = []
        
        // Check if this is a mesh entity with M_screen material
        if root.name.hasSuffix("_mesh") {
            if let modelComponent = root.components[ModelComponent.self],
               modelComponent.materials.contains(where: { $0.name == "M_screen" }) {
                // Find parent that contains "laptop" or "pcmonitor"
                var current = root.parent
                while let parent = current {
                    if parent.name.lowercased().contains("laptop") || 
                       parent.name.lowercased().contains("pcmonitor") {
                        results.append((parent, root))
                        break
                    }
                    current = parent.parent
                }
            }
        }
        
        // Search children
        for child in root.children {
            results.append(contentsOf: findInteractiveDevices(in: child))
        }
        
        return results
    }

    private func configureInteractiveDevices(in entity: Entity) {
        // Find and configure all interactive devices
        let devices = findInteractiveDevices(in: entity)
        print("\n=== Configuring Interactive Devices ===")
        print("🔍 Found \(devices.count) potential interactive devices")
        
        for (device, meshEntity) in devices {
            print("⚙️ Adding hover effect to: \(device.name) with mesh: \(meshEntity.name)")
            
            // Find M_screen material in the mesh entity
            if let modelComponent = meshEntity.components[ModelComponent.self],
               modelComponent.materials.contains(where: { $0.name == "M_screen" }) {
                
                // Add hover effect with shader inputs
                let hoverEffect = HoverEffectComponent(.shader(
                    HoverEffectComponent.ShaderHoverEffectInputs(
                        fadeInDuration: 0.3,
                        fadeOutDuration: 0.2
                    )
                ))
                device.components.set(hoverEffect)
            }
        }
    }
    
    // MARK: - Interactive Device Handling
    func handleTap(on entity: Entity) {
        print("🎯 Tap detected on entity: \(entity.name)")
        
        if entity.components[InteractiveDeviceComponent.self] != nil {
            print("📱 Found InteractiveDeviceComponent, toggling library...")
            isLibraryOpen.toggle()
        }
    }
    
    // MARK: - Cleanup
    func cleanup() {
        print("\n=== Starting LabViewModel Cleanup ===")
        
        // Clear main entity and scene
        if let root = mainEntity {
            print("🗑️ Removing main entity")
            // Reset positioning component before removal
            if var positioningComponent = root.components[PositioningComponent.self] {
                print("🎯 Resetting positioning component")
                positioningComponent.needsPositioning = true
                root.components[PositioningComponent.self] = positioningComponent
            }
            root.removeFromParent()
        }
        mainEntity = nil
        scene = nil
        
        // Clear audio entity
        if let audio = labAudioEntity {
            print("🔊 Removing lab audio entity")
            audio.removeFromParent()
        }
        labAudioEntity = nil
        
        // Clear attachment entities
        if let builder = adcBuilderViewerButtonEntity {
            print("🔧 Removing ADC builder button")
            builder.removeFromParent()
        }
        adcBuilderViewerButtonEntity = nil
        
        if let attack = attackCancerViewerButtonEntity {
            print("🎯 Removing Attack Cancer button")
            attack.removeFromParent()
        }
        attackCancerViewerButtonEntity = nil
        
        // Reset state
        isSetupComplete = false
        isLibraryOpen = false
        shouldShowADCButton = false  // Reset the button state
        
        print("✅ Completed LabViewModel cleanup\n")
    }
}

```

File: Views/AttackCancerInstructionsView.swift
```swift
//
//  AttackCancerInstructionsView.swift
//  ViewBuilder
//
//  Created by Dale Carman on 1/4/25.
//


import SwiftUI
import RealityKit
import OSLog

struct AttackCancerInstructionsView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel

    @Environment(\.dismiss) private var dismiss
    @Environment(\.openWindow) private var openWindow
    
    @State private var opacity: Double = 0  // Add state for opacity
    
    var body: some View {
        var adcEntity = Entity()
        
        NavigationStack {
            VStack {
//                Spacer()
                VStack {
                    RealityView { content in
                        print("\n=== AttackCancerInstructionsView Rotating ADC Setup ===")
                        print("📱 Instructions View: Setting up root entity")
                        let root = appModel.gameState.setupRoot()
                        content.add(root)
                        
                        // Setup IBL
                        await appModel.gameState.setupIBL(in: root)
                        print("✅ Instructions View: IBL setup complete")
                        
                        // Use the template from gameState (already has colors applied)
                        if let template = appModel.gameState.adcTemplate {
                            print("✅ Instructions View: Found ADC template")
                            adcEntity = template.clone(recursive: true)
                            adcEntity.components.set(RotationComponent())
                            root.addChild(adcEntity)
                            print("✅ Instructions View: Added ADC to display")
                        } else {
                            print("❌ Instructions View: No ADC template available")
                        }
                        print("=== Instructions View Setup Complete ===\n")
                    }
                }
                VStack(spacing: 0) {
                    // Title
                    Text("Attack Cancer Instructions")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .padding(.bottom, 30)
                    
                    // Instructions sections
                    VStack(alignment: .leading, spacing: 20) {
                        instructionSection(
                            title: "Target Cancer Cells",
                            description: "Look at a floating cancer cell in your environment and use a spatial tap gesture to launch an ADC to attack it.",
                            systemImage: "target"
                        )
                        
                        instructionSection(
                            title: "Track Progress",
                            description: "Watch the hit counter above each cell. Some cells require multiple hits.",
                            systemImage: "chart.bar.fill"
                        )
                        
                        instructionSection(
                            title: "Hope Meter",
                            description: "Keep an eye on your Hope Meter on your left hand. You have a limited amount of time!",
                            systemImage: "gauge.medium"
                        )
                        
                        instructionSection(
                            title: "Victory",
                            description: "Destroy as many cancer cells as possible before the Hope Meter depletes to win.",
                            systemImage: "trophy.fill"
                        )
                    }
                    .padding(.bottom, 60)
                    .padding(.horizontal, 120)
                    // Start button
                    NavigationButton(
                        title: appModel.isTutorialStarted ? "Attack Cancer!" : "Start Tutorial",
                        action: {
                            if !appModel.isTutorialStarted {
                                Logger.info("\n🎓 Initiating tutorial sequence...")
                                // Request head position update when ready
                                appModel.gameState.shouldUpdateHeadPosition = true
                                appModel.isTutorialStarted = true
                                appModel.isInstructionsWindowOpen = false
                            } else {
                                Logger.info("\n🎮 Starting game sequence...")
                                // Request head position update when ready
                                appModel.gameState.shouldUpdateHeadPosition = true
                                appModel.startAttackCancerGame()
                                appModel.isInstructionsWindowOpen = false
                                if !appModel.isHopeMeterUtilityWindowOpen {
                                    openWindow(id: AppModel.hopeMeterUtilityWindowId)
                                }
                            }
                        },
                        font: .title,
                        scaleEffect: AppModel.UIConstants.buttonExpandScale,
                        width: 200
                    )
                    .fontWeight(.bold)
                    // .padding(30)
                }
                .padding(.bottom, 100)
                .opacity(opacity)  // Apply opacity
                .onAppear {
                    withAnimation(.easeIn(duration: 2.0)) {
                        opacity = 1.0
                    }
                }
                .onDisappear {
                    withAnimation(.easeOut(duration: 1.0)) {
                        opacity = 1.0
                    }
                }
            }
        }
        .frame(minWidth: 800)
        .frame(minHeight: 900)
        

    }
    
    private func instructionSection(title: String, description: String, systemImage: String) -> some View {
        HStack(alignment: .top, spacing: 15) {
            Image(systemName: systemImage)
                .font(.title)
                .foregroundColor(.blue)
                .frame(width: 30)
            
            VStack(alignment: .leading, spacing: 5) {
                Text(title)
                    .font(.title3)
                    .fontWeight(.semibold)
                    .fixedSize(horizontal: false, vertical: true)
                
                Text(description)
                    .font(.body)
                    .foregroundColor(.secondary)
                    .opacity(0.7)
                    .fixedSize(horizontal: false, vertical: true)
                    .lineLimit(nil)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
    }
}

//#Preview("Instruction View") {
//    @Previewable @State var isVisible: Bool = true
//    
//    VStack {
//        GroupBox {
//            Toggle("Visible", isOn: $isVisible.animation())
//        }
//        Spacer()
//        
//        if isVisible {
//            AttackCancerInstructionsView()
//                .environment(AppModel())
//                .environment(ADCDataModel())
//                .transition(Appear())
//        }
//        Spacer()
//    }
//    .padding()
//    
//}

```

File: Views/IntroView.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

/// A RealityView that creates an immersive lab environment with spatial audio and IBL lighting
struct IntroView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.openWindow) private var openWindow
    
    @State private var introTintIntensity: Double = 0.01 {
        didSet {
            print("introTintIntensity changed to: \(introTintIntensity)")
            // Consider adding a breakpoint here to inspect the call stack
        }
    }
    
    @State private var showNavToggle: Bool = true
    
    var surroundingsEffect: SurroundingsEffect? {
        let tintColor = Color(red: introTintIntensity, green: introTintIntensity, blue: introTintIntensity)
        return SurroundingsEffect.colorMultiply(tintColor)
    }

    @State var handTrackedEntity: Entity = {
        let handAnchor = AnchorEntity(.hand(.left, location: .aboveHand))
        return handAnchor
    }()
    
    var body: some View {
        @Bindable var appModel = appModel
        
        RealityView { content, attachments in
            print("\n=== Setting up IntroView ===")
            
            // Create fresh root entity
            let root = appModel.introState.setupRoot()
            content.add(root)
            print("✅ Added root to content")
            
             if showNavToggle {
                 content.add(handTrackedEntity)
                 if let attachmentEntity = attachments.entity(for: "navToggle") {
                     attachmentEntity.components[BillboardComponent.self] = .init()
                     handTrackedEntity.addChild(attachmentEntity)
                 }
             }
            
            // Handle environment and attachments in Task
            Task { @MainActor in
                do {
                    // Load environment first
                    print("📱 IntroView: Starting environment setup")
                    await appModel.introState.setupEnvironment(in: root)
                    appModel.introState.environmentLoaded = true
                    print("✅ Environment setup complete")
                    
                    // Now that environment is loaded, handle attachments
                    if let titleEntity = attachments.entity(for: "titleText")
                       {
                        print("📱 IntroView: Found SwiftUI attachments")
                        
                        // Store attachments in view model
                        appModel.introState.titleEntity = titleEntity
                        
                        // Get portal and set up attachments
                        if let portal = appModel.introState.getPortal() {
                            print("✅ Found portal for attachments")
                            
                            // Set up attachments on portal
                            appModel.introState.setupAttachments(
                                in: root,
                                for: portal,
                                titleEntity: titleEntity
                            )
                        }
                    }

                    // set up the lab attachments
                    // Now that environment is loaded, set up attachments
                    if let adcButton = attachments.entity(for: "ADCBuilderViewerButton"),
                       let attackButton = attachments.entity(for: "AttackCancerViewerButton") {
                        
                        // Find attachment points and set up buttons
                        if let builderTarget = root.findEntity(named: "ADCBuilderAttachment") {
                            print("🎯 Found ADCBuilderAttachment target")
                            builderTarget.addChild(adcButton)
                            adcButton.components.set(BillboardComponent())
                            appModel.labState.adcBuilderViewerButtonEntity = adcButton
                        } else {
                            print("❌ ADCBuilderAttachment target not found")
                        }
                        
                        if let attackTarget = root.findEntity(named: "AttackCancerAttachment") {
                            print("🎯 Found AttackCancerAttachment target")
                            attackTarget.addChild(attackButton)
                            attackButton.components.set(BillboardComponent())
                            appModel.labState.attackCancerViewerButtonEntity = attackButton
                        } else {
                            print("❌ AttackCancerAttachment target not found")
                        }
                    }
                } catch {
                    print("❌ IntroView: Setup failed: \(error)")
                }
            }
        } attachments: {
            Attachment(id: "titleText") {
                if appModel.introState.showTitleText {
                    OutdoCancer(showTitle: $appModel.introState.showTitleText)
                }
            }
            if showNavToggle {
                Attachment(id: "navToggle") {
                    NavToggleView()
                }
            }
            Attachment(id: "ADCBuilderViewerButton") {
                ADCBuilderViewerButton()
            }
            Attachment(id: "AttackCancerViewerButton") {
                AttackCancerViewerButton()
            }
            Attachment(id: "AttachmentContent") {
                HStack(spacing: 12) {
                    Button(action: {
                        appModel.isNavWindowOpen.toggle()
                        openWindow(id: AppModel.navWindowId)
                    }, label: {
                        Image(systemName: "arrow.2.circlepath.circle")
                    })

                }
                .opacity(appModel.isNavWindowOpen ? 0 : 1)
            }
        }
//        .preferredSurroundingsEffect(surroundingsEffect)

        .onAppear {
            print("\n=== IntroView Appeared ===")
            dismissWindow(id: AppModel.navWindowId)
            // Ensure library window starts closed
            appModel.updateLibraryWindowState(isOpen: false)
        }
        .onDisappear {
            // Cleanup is now handled by AssetLoadingManager during phase transitions
        }
        .onChange(of: appModel.labState.isLibraryOpen) { _, isOpen in
            if isOpen {
                print(">>> Library window opened 🚪")
                openWindow(id: AppModel.libraryWindowId)
                appModel.updateLibraryWindowState(isOpen: true)
            } else {
                print(">>> Library window closed")
                dismissWindow(id: AppModel.libraryWindowId)
                appModel.updateLibraryWindowState(isOpen: false)
            }
        }
        .gesture(
            SpatialTapGesture()
                .targetedToAnyEntity()
                .onEnded { value in
                   appModel.labState.handleTap(on: value.entity)
                }
        )
        // Keep tracking tasks separate
        .task {
            await appModel.trackingManager.processWorldTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.processHandTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.monitorTrackingEvents()
        }
        // Add head position update handler
        .onChange(of: appModel.introState.shouldUpdateHeadPosition) { _, shouldUpdate in
            if shouldUpdate && appModel.introState.isReadyForInteraction {
                if let root = appModel.introState.introRootEntity {
                    Logger.info("""
                    
                    🎯 Head Position Update Requested
                    ├─ Current World Position: \(root.position(relativeTo: nil))
                    ├─ Root Setup: \(appModel.introState.isRootSetupComplete ? "✅" : "❌")
                    ├─ Environment: \(appModel.introState.isEnvironmentSetupComplete ? "✅" : "❌")
                    └─ HeadTracking: \(appModel.introState.isHeadTrackingRootReady ? "✅" : "❌")
                    """)
                    
                    Task {
                        await root.checkHeadPosition(animated: true, duration: 0.5)
                        appModel.introState.shouldUpdateHeadPosition = false
                        appModel.introState.isPositioningComplete = true  // Set after animation completes
                    }
                }
            }
        }
        // Add positioning completion handler
        .onChange(of: appModel.introState.isPositioningComplete) { _, complete in
            if complete {
                Task { @MainActor in
                    if let root = appModel.introState.introRootEntity {
                        Logger.info("🎬 Starting intro sequence after positioning complete...")
                        
                        // Start animation sequence
                        await appModel.introState.runAnimationSequence()
                        appModel.introState.isSetupComplete = true
                    }
                }
            }
        }
        // start the lab environment when readyToStartLab becomes true
        .onChange(of: appModel.readyToStartLab) { _, newValue in
            if newValue {
                if let root = appModel.introState.introRootEntity {
                    Task { @MainActor in
                        do {
                            try await appModel.labState.setupInitialLabEnvironment(in: root, isIntro: true)
                            try await appModel.labState.setupLabEnvironment(in: root, isIntro: true)
                        } catch {
                            print("❌ Error setting up lab environment: \(error)")
                        }
                    }
                } else {
                    print("❌ Intro root entity not available for lab setup")
                }
            }
        }
    }
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Entities.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import OSLog


extension ADCOptimizedImmersive {
    func prepareAntibodyEntities() {
        guard let antibodyRoot = antibodyRootEntity else { 
            os_log(.error, "ITR..prepareAntibodyEntities(): ❌ No antibody root entity")
            return 
        }
        
        if let antibody = antibodyRoot.findModelEntity(named: "ADC_complex") {
            self.antibodyEntity = antibody
            antibody.isEnabled = false
            
            // Add to main entity with proper hierarchy
            if let mainEntity = self.mainEntity {
                mainEntity.addChild(antibodyRoot)
                
                // Set initial position with proper transform
                antibodyRoot.position = antibodyRoot.position + antibodyRootOffset
                // Commenting out second transform to avoid double-application
                // antibodyRoot.transform.translation = [antibodyRoot.transform.translation.x,
                //                                    antibodyRoot.transform.translation.y,
                //                                    antibodyRoot.transform.translation.z]
                
                // Add mainViewEntity as child with proper transform
                mainViewEntity.position = mainViewEntity.position //  + antibodyAttachmentOffset
                // Commenting out second transform to avoid double-application
                // mainViewEntity.transform.translation = [mainViewEntity.transform.translation.x,
                //                                      mainViewEntity.transform.translation.y,
                //                                      mainViewEntity.transform.translation.z]
                antibodyRoot.addChild(mainViewEntity)
                
                // Set up gesture component with proper configuration
                let gestureComponent = createGestureComponent()
                antibodyRoot.components.set(gestureComponent)
                
                // Set up audio with proper resource handling
                if let resource = popAudioFileResource {
                    do {
                        self.popAudioPlaybackController = try popAudioEntity?.prepareAudio(resource)
                        os_log(.debug, "ITR..prepareAntibodyEntities(): ✅ Audio prepared successfully")
                    } catch {
                        os_log(.error, "ITR..prepareAntibodyEntities(): ❌ Failed to prepare audio: \(error)")
                    }
                }
                
                // Store original material with proper type checking
                if let modelComponent = antibody.components[ModelComponent.self],
                   let originalMaterial = modelComponent.materials.first as? ShaderGraphMaterial {
                    self.originalAntibodyMaterial = originalMaterial
                    os_log(.debug, "ITR..prepareAntibodyEntities(): ✅ Stored original antibody material")
                }
                
                // Apply outline material with proper component handling
                if let material = outlineMaterial,
                   var modelComponent = antibody.components[ModelComponent.self] {
                    modelComponent.materials = [material]
                    antibody.components[ModelComponent.self] = modelComponent
                    os_log(.debug, "ITR..prepareAntibodyEntities(): ✅ Applied outline material")
                    
                    // Add sort component for render order
                    if let sortGroup = adcSortGroup {
                        let sortComponent = ModelSortGroupComponent(group: sortGroup, order: 10)
                        antibody.components.set(sortComponent)
                        os_log(.debug, "ITR..prepareAntibodyEntities(): ✅ Added sort component with order 10")
                    }
                }
            } else {
                os_log(.error, "ITR..prepareAntibodyEntities(): ❌ No main entity to attach to")
            }
        } else {
            os_log(.error, "ITR..prepareAntibodyEntities(): ❌ Could not find ADC_complex entity")
        }
    }
    

    
    func prepareLinkerEntities() async {
        guard let antibodyRoot = antibodyRootEntity else { return }
        
        if let linker0 = antibodyRoot.findModelEntity(named: "linker", from: "linker01_offset"),
           let linker1 = antibodyRoot.findModelEntity(named: "linker", from: "linker02_offset"),
           let linker2 = antibodyRoot.findModelEntity(named: "linker", from: "linker03_offset"),
           let linker3 = antibodyRoot.findModelEntity(named: "linker", from: "linker04_offset") {
            
            self.adcLinkers = [linker0, linker1, linker2, linker3]
            
            // Store original material from first linker
            if let originalMaterial = linker0.components[ModelComponent.self]?.materials.first as? ShaderGraphMaterial {
                self.originalLinkerMaterial = originalMaterial
                os_log(.debug, "ITR..prepareLinkerEntities(): ✅ Stored original ShaderGraphMaterial")
            }
            
            // Apply stored outline material to all linkers
            if let material = outlineMaterial {
                self.adcLinkers.forEach { linker in
                    if var modelComponent = linker.components[ModelComponent.self] {
                        os_log(.debug, "ITR..prepareLinkerEntities(): Applying outline material to linker")
                        modelComponent.materials = [material]
                        linker.components[ModelComponent.self] = modelComponent
                        linker.isEnabled = false
                    }
                    
                    // Add sort component for render order
                    if let sortGroup = adcSortGroup {
                        let sortComponent = ModelSortGroupComponent(group: sortGroup, order: 20)
                        linker.components.set(sortComponent)
                    }
                }
                os_log(.debug, "ITR..prepareLinkerEntities(): ✅ Added sort components to linkers with order 20")
            } else {
                os_log(.error, "ITR..prepareLinkerEntities(): ❌ No outline material available")
            }
        }
    }
    
    func preparePayloadEntities() async {
        guard let antibodyRoot = antibodyRootEntity else {
            os_log(.error, "ITR..preparePayloadEntities(): ❌ No antibody root entity")
            return
        }
        
        // Find all payload entities with proper error handling
        let payloadPairs: [(inner: ModelEntity?, outer: ModelEntity?)] = [
            (antibodyRoot.findModelEntity(named: "InnerSphere", from: "linker01_offset"),
             antibodyRoot.findModelEntity(named: "OuterSphere", from: "linker01_offset")),
            (antibodyRoot.findModelEntity(named: "InnerSphere", from: "linker02_offset"),
             antibodyRoot.findModelEntity(named: "OuterSphere", from: "linker02_offset")),
            (antibodyRoot.findModelEntity(named: "InnerSphere", from: "linker03_offset"),
             antibodyRoot.findModelEntity(named: "OuterSphere", from: "linker03_offset")),
            (antibodyRoot.findModelEntity(named: "InnerSphere", from: "linker04_offset"),
             antibodyRoot.findModelEntity(named: "OuterSphere", from: "linker04_offset"))
        ]
        
        // Process payload pairs with proper component handling
        for (inner, outer) in payloadPairs {
            if let innerPayload = inner, let outerPayload = outer {
                // Set up inner payload
                innerPayload.isEnabled = false
                if var modelComponent = innerPayload.components[ModelComponent.self] {
                    // Store original inner material
                    if let originalMaterial = modelComponent.materials.first as? PhysicallyBasedMaterial {
                        self.originalPayloadInnerMaterial = originalMaterial
                        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Stored original inner PBR material for payload %{public}@", String(describing: innerPayload.name))
                    } else {
                        os_log(.error, "ITR..preparePayloadEntities(): ❌ Failed to get original PBR material for inner payload %{public}@", String(describing: innerPayload.name))
                    }
                    modelComponent.materials = [outlineMaterial].compactMap { $0 }
                    innerPayload.components[ModelComponent.self] = modelComponent
                    
                    // Add sort component for inner payload
                    if let sortGroup = adcSortGroup {
                        let sortComponent = ModelSortGroupComponent(group: sortGroup, order: 30)
                        innerPayload.components.set(sortComponent)
                        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Added sort component to inner payload with order 30")
                    }
                } else {
                    os_log(.error, "ITR..preparePayloadEntities(): ❌ No ModelComponent found for inner payload %{public}@", String(describing: innerPayload.name))
                }
                adcPayloadsInner.append(innerPayload)
                
                // Set up outer payload
                outerPayload.isEnabled = false
                if var modelComponent = outerPayload.components[ModelComponent.self] {
                    // Store original outer material
                    if let originalMaterial = modelComponent.materials.first as? ShaderGraphMaterial {
                        self.originalPayloadOuterMaterial = originalMaterial
                        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Stored original outer shader material for payload %{public}@", String(describing: outerPayload.name))
                        
                        // Log available parameters for debugging
                        let parameters = originalMaterial.parameterNames
                        os_log(.debug, "ITR..preparePayloadEntities(): 📝 Available shader parameters for %{public}@: %{public}@", String(describing: outerPayload.name), parameters.joined(separator: ", "))
                    } else {
                        os_log(.error, "ITR..preparePayloadEntities(): ❌ Failed to get original shader material for outer payload %{public}@", String(describing: outerPayload.name))
                    }
                    modelComponent.materials = [outlineMaterial].compactMap { $0 }
                    outerPayload.components[ModelComponent.self] = modelComponent
                    
                    // Add sort component for outer payload
                    if let sortGroup = adcSortGroup {
                        let sortComponent = ModelSortGroupComponent(group: sortGroup, order: 40)
                        outerPayload.components.set(sortComponent)
                        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Added sort component to outer payload with order 40")
                    }
                } else {
                    os_log(.error, "ITR..preparePayloadEntities(): ❌ No ModelComponent found for outer payload %{public}@", String(describing: outerPayload.name))
                }
                adcPayloadsOuter.append(outerPayload)
                
                // Ensure proper transform binding
                innerPayload.transform = Transform(scale: .one,
                                                rotation: .init(),
                                                translation: innerPayload.position)
                outerPayload.transform = Transform(scale: .one,
                                                rotation: .init(),
                                                translation: outerPayload.position)
            } else {
                os_log(.error, "ITR..preparePayloadEntities(): ❌ Failed to find payload pair")
            }
        }
        
        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Found \(adcPayloadsInner.count) inner payloads and \(adcPayloadsOuter.count) outer payloads")
    }
    
    func prepareTargetEntities(antibodyScene: Entity) {
        guard adcLinkers.count > 0 else {
            os_log(.error, "ITR..prepareTargetEntities(): ❌ Error, self.adcLinkers is empty. It should have content at this point.")
            return
        }

        guard !adcPayloadsInner.isEmpty else {
            os_log(.error, "ITR..prepareTargetEntities(): ❌ Error, self.adcPayloadsInner is empty. It should have content at this point.")
            return
        }

        if let linker = antibodyScene.findEntity(named: "targetLinker"),
           let payload = antibodyScene.findEntity(named: "targetPayload"),
           let workingLinker = linker.findModelEntity(named: "linker"),
           let workingPayloadInner = payload.findModelEntity(named: "InnerSphere"),
           let workingPayloadOuter = payload.findModelEntity(named: "OuterSphere") {
            
            // Attach audio to target entities
            attachPopSoundToTarget(linker)
            attachPopSoundToTarget(payload)
            
            linkerEntity = linker
            antibodyRootEntity?.addChild(linker)
            linker.position = linker.position + linkerAttachmentOffset
            initialLinkerPosition = linker.position  // Save initial position
            
            linker.isEnabled = false
            linker.components.set(createLinkerGestureComponent(linkerEntity: linker, linkerTarget: adcLinkers[dataModel.linkersWorkingIndex]))
            workingLinker.components.set(ADCProximityComponent(minScale: 0.3, maxScale: 1.0, minProximity: 0.1, maxProximity: 0.5))
            
            payloadEntity = payload
            payload.isEnabled = false
            payload.components.set(createPayloadGestureComponent(payloadEntity: payload, payloadTarget: adcPayloadsInner[dataModel.payloadsWorkingIndex]))
            
            antibodyRootEntity?.addChild(payload)
            payload.position = payload.position + payloadAttachmentOffset
            initialPayloadPosition = payload.position  // Save initial position
            
            // Apply outline material to draggable linker
            if let material = outlineMaterial {
                if var modelComponent = workingLinker.components[ModelComponent.self] {
                    modelComponent.materials = [material]
                    workingLinker.components[ModelComponent.self] = modelComponent
                    os_log(.debug, "ITR..prepareTargetEntities(): ✅ Applied outline material to draggable linker")
                }
                
                // Apply to both inner and outer payload
                if var innerComponent = workingPayloadInner.components[ModelComponent.self],
                   var outerComponent = workingPayloadOuter.components[ModelComponent.self] {
                    innerComponent.materials = [material]
                    outerComponent.materials = [material]
                    workingPayloadInner.components[ModelComponent.self] = innerComponent
                    workingPayloadOuter.components[ModelComponent.self] = outerComponent
                    os_log(.debug, "ITR..prepareTargetEntities(): ✅ Applied outline material to draggable payload")
                }
            }
            
            // Add sort components for draggable payloads
            if let sortGroup = adcSortGroup {
                let innerSortComponent = ModelSortGroupComponent(group: sortGroup, order: 50)
                workingPayloadInner.components.set(innerSortComponent)
                
                let outerSortComponent = ModelSortGroupComponent(group: sortGroup, order: 60)
                workingPayloadOuter.components.set(outerSortComponent)
                os_log(.debug, "ITR..prepareTargetEntities(): ✅ Added sort components to draggable payloads (inner: 50, outer: 60)")
            }
            
            // Rest stays the same...
            self.workingLinker = workingLinker
            self.workingPayloadInner = workingPayloadInner
            self.workingPayloadOuter = workingPayloadOuter
            workingPayloadOuter.components.set(ADCProximityComponent(minScale: 2.0, maxScale: 15.0, minProximity: 0.15, maxProximity: 0.6))
            workingPayloadInner.components.set(ADCProximityComponent(minScale: 2.0, maxScale: 15.0, minProximity: 0.15, maxProximity: 0.6))
        }
    }
    
    func cleanup() {
        os_log(.debug, "ITR..reset() called")
        
        // Reset dataModel state
        dataModel.selectedADCAntibody = nil
        dataModel.selectedADCLinker = nil
        dataModel.selectedADCPayload = nil
        dataModel.selectedLinkerType = nil
        dataModel.selectedPayloadType = nil
        dataModel.linkersWorkingIndex = 0
        dataModel.payloadsWorkingIndex = 0
        dataModel.placedLinkerCount = 0
        dataModel.placedPayloadCount = 0
        
        // Reset audio
        currentVOController?.stop()
        currentVOController = nil
        popAudioPlaybackController?.stop()
        popAudioPlaybackController = nil
//        audioStorage?.cleanup()
        
        // Reset entities
        mainEntity?.removeFromParent()
        mainViewEntity.removeFromParent()
        antibodyRootEntity?.removeFromParent()
        
        // Remove all components before removing entities
        antibodyEntity?.components.remove(ModelComponent.self)
        antibodyEntity?.components.remove(CollisionComponent.self)
        antibodyEntity?.components.remove(InputTargetComponent.self)
        
        // Clear all entities
        mainEntity = nil
        mainViewEntity = Entity()
        antibodyRootEntity = nil
        antibodyEntity = nil
        linkerEntity = nil
        payloadEntity = nil
        
        // Clear working entities
        workingLinker = nil
        workingPayloadInner = nil
        workingPayloadOuter = nil
        
        // Clear arrays
        adcLinkers.removeAll(keepingCapacity: false)
        adcPayloadsInner.removeAll(keepingCapacity: false)
        adcPayloadsOuter.removeAll(keepingCapacity: false)
        
        // Clear attachments
        adcAttachmentEntity = nil
        linkerAttachmentEntity = nil
        payloadAttachmentEntity = nil
        
        // Reset flags
        shouldAddADCAttachment = false
        shouldAddLinkerAttachment = false
        shouldAddPayloadAttachment = false
        shouldAddMainViewAttachment = false
        refreshFlag = false
        bubblePopSound = false
        
        // Reset audio resources
        popAudioFileResource = nil
        vo1Audio = nil
        vo2Audio = nil
        vo3Audio = nil
        vo4Audio = nil
        
        // Ensure cleanup happens on main actor
        Task { @MainActor in
            await Task.yield()
            // Release any strong references
            originalAntibodyMaterial = nil
            originalPayloadInnerMaterial = nil
            originalPayloadOuterMaterial = nil
            outlineMaterial = nil
        }
    }
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Gestures.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import OSLog


extension ADCOptimizedImmersive {
    // MARK: - Gestures
    
    func createGestureComponent() -> ADCGestureComponent {
        var gestureComponent = ADCGestureComponent(canDrag: true,
                                                      pivotOnDrag: false,
                                                      canScale: false,
                                                      canRotate: true)
        gestureComponent.onDragStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddMainViewAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onDragEnded = { entity in
            shouldAddADCAttachment = true
            shouldAddMainViewAttachment = true
            shouldAddLinkerAttachment = true
            shouldAddPayloadAttachment = true
        }
        gestureComponent.onRotateStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddMainViewAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onRotateEnded = { entity in
            shouldAddADCAttachment = true
            shouldAddMainViewAttachment = true
            shouldAddLinkerAttachment = true
            shouldAddPayloadAttachment = true
        }
        return gestureComponent
    }
    
    func createLinkerGestureComponent(linkerEntity: Entity, linkerTarget: Entity) -> ADCGestureComponent {
        var gestureComponent = ADCGestureComponent(canDrag: true,
                                                pivotOnDrag: false,
                                                canScale: false,
                                                canRotate: false)
        gestureComponent.onDragStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onDragEnded = { entity in
            if let finishedEntity = entity {
//                os_log(.debug, "ITR..createLinkerGestureComponent(): Drag ended on entity \(finishedEntity.name)")
                shouldAddADCAttachment = true
                shouldAddLinkerAttachment = true
                shouldAddPayloadAttachment = true
                
                let currentPosition = finishedEntity.position(relativeTo: nil)
                let targetPosition = linkerTarget.position(relativeTo: nil)
                let dist = distance(currentPosition, targetPosition)
                
//                os_log(.debug, "ITR..createLinkerGestureComponent(): LinkerEntity Position: \(currentPosition), \n     LinkerTargetPosition: \(targetPosition),    Distance: \(dist)")
                if dist < 0.2 {
                    os_log(.debug, "ITR..createLinkerGestureComponent(): Entity \(finishedEntity.name) is close enough to the target linker, dataModel.linkersWorkingIndex: \(dataModel.linkersWorkingIndex)")
                    // Set default color to 0 if none selected
                    if dataModel.selectedLinkerType == nil {
                        dataModel.selectedLinkerType = 0
                    }
                    dataModel.selectedADCLinker = dataModel.selectedLinkerType
                    dataModel.placedLinkerCount += 1
                    Task { @MainActor in
                        attachPopSoundToTarget(finishedEntity)
                        await playPopSound()
                    }
                    
                    Task { @MainActor in
                        // Only apply color if one has been chosen
                        if let selectedType = dataModel.selectedLinkerType {
                            // Update all previously placed linkers
                            for index in 0..<dataModel.linkersWorkingIndex {
                                if let originalMaterial = originalLinkerMaterial {
                                    if var modelComponent = adcLinkers[index].components[ModelComponent.self] {
                                        modelComponent.materials = [originalMaterial]
                                        adcLinkers[index].components[ModelComponent.self] = modelComponent
                                    }
                                }
                                adcLinkers[index].updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[selectedType])
                            }
                            
                            // Update current linker
                            if let originalMaterial = originalLinkerMaterial {
                                adcLinkers[dataModel.linkersWorkingIndex].updateMaterials { material in
                                    material = originalMaterial
                                }
                            }
                            adcLinkers[dataModel.linkersWorkingIndex].updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[selectedType])
                        }
                        
                        // If there's a next linker, give it the outline material
                        if dataModel.linkersWorkingIndex < (adcLinkers.count - 1) {
                            if let material = outlineMaterial {
                                adcLinkers[dataModel.linkersWorkingIndex + 1].model?.materials = [material]
                            }
                        }
                        
                        adcLinkers.forEach {
                            $0.components.remove(ADCProximitySourceComponent.self)
                        }
                        
                        let isFinalLinker = dataModel.linkersWorkingIndex >= (adcLinkers.count - 1)
                        if isFinalLinker {
                            await handleFinalEntityPlacement(
                                entityType: .linker,
                                workingEntity: linkerEntity,
                                savedPosition: initialLinkerPosition,
                                nextStep: 2
                            )
                        } else {
                            if let linkerEntity = self.linkerEntity,
                               let savedPosition = initialLinkerPosition {
                                linkerEntity.position = savedPosition  // Restore to original position
                            }

                            dataModel.linkersWorkingIndex += 1

                            for (index, element) in adcLinkers.enumerated() {
                                element.isEnabled = index <= dataModel.linkersWorkingIndex
                            }
                            
                            adcLinkers[dataModel.linkersWorkingIndex].components.set(ADCProximitySourceComponent())

                        }
                        updateADC()
                    }
                } else {
//                    os_log(.debug, "ITR..createLinkerGestureComponent(): Entity \(finishedEntity.name) distance: \(dist)")
                }
            }
        }
        gestureComponent.onRotateStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onRotateEnded = { entity in
            shouldAddADCAttachment = true
            shouldAddLinkerAttachment = true
            shouldAddPayloadAttachment = true
        }
        return gestureComponent
    }
    
    /// Handles the final placement of an entity (linker or payload)
    /// - Parameters:
    ///   - entityType: Type of entity being placed
    ///   - workingEntity: The current working entity to reset
    ///   - savedPosition: Original position to reset to
    ///   - nextStep: Step to advance to when complete
    func handleFinalEntityPlacement(entityType: ADCEntityType,
                                  workingEntity: Entity?,
                                  savedPosition: SIMD3<Float>?,
                                  nextStep: Int) async {
        // Play pop sound while entity is still in final position
        if let workingEntity = workingEntity {
            attachPopSoundToTarget(workingEntity)
            await playPopSound()
            workingEntity.opacity = 0
        }
        // Removed auto advancement logic.
        // The user must press the checkmark button to advance to the next step.
    }
    
    func createPayloadGestureComponent(payloadEntity: Entity, payloadTarget: Entity) -> ADCGestureComponent {
        var gestureComponent = ADCGestureComponent(canDrag: true,
                                                pivotOnDrag: false,
                                                canScale: false,
                                                canRotate: false)
        gestureComponent.onDragStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onDragEnded = { entity in
            if let finishedEntity = entity {
//                os_log(.debug, "ITR..createPayloadGestureComponent(): Drag ended on entity \(finishedEntity.name)")
                shouldAddADCAttachment = true
                shouldAddLinkerAttachment = true
                shouldAddPayloadAttachment = true
                
                //TODO: check if entity is close enough to the target linker, if so then remove the working linker and set the selected Linker
                let currentPosition = finishedEntity.position(relativeTo: nil)
                let targetPosition = payloadTarget.position(relativeTo: nil)
                let dist = distance(currentPosition, targetPosition)
                
//                os_log(.debug, "ITR..createPayloadGestureComponent(): PayloadEntity Position: \(currentPosition), \n     PayloadTargetPosition: \(targetPosition),    Distance: \(dist)")
                if dist < 0.2 {
                    os_log(.debug, "ITR..createPayloadGestureComponent(): Entity \(finishedEntity.name) is close enough to the target payload, dataModel.payloadsWorkingIndex: \(dataModel.payloadsWorkingIndex)")
                    // Set default color to 0 if none selected
                    if dataModel.selectedPayloadType == nil {
                        dataModel.selectedPayloadType = 0
                    }
                    dataModel.selectedADCPayload = dataModel.selectedPayloadType
                    Task { @MainActor in
                        attachPopSoundToTarget(finishedEntity)
                        await playPopSound()
                    }
                    dataModel.placedPayloadCount += 1
                    
                    Task { @MainActor in
                        // Only apply color if one has been chosen
                        if let selectedType = dataModel.selectedPayloadType {
                            // Update all previously placed payloads
                            for index in 0..<dataModel.payloadsWorkingIndex {
                                // Inner sphere
                                if let originalInnerMaterial = originalPayloadInnerMaterial {
                                    if var modelComponent = adcPayloadsInner[index].components[ModelComponent.self] {
                                        modelComponent.materials = [originalInnerMaterial]
                                        adcPayloadsInner[index].components[ModelComponent.self] = modelComponent
                                    }
                                }
                                adcPayloadsInner[index].updatePBREmissiveColor(.adcEmissive[selectedType])
                                
                                // Outer sphere
                                if let originalOuterMaterial = originalPayloadOuterMaterial {
                                    if var modelComponent = adcPayloadsOuter[index].components[ModelComponent.self] {
                                        modelComponent.materials = [originalOuterMaterial]
                                        adcPayloadsOuter[index].components[ModelComponent.self] = modelComponent
                                    }
                                }
                                adcPayloadsOuter[index].updateShaderGraphColor(parameterName: "glowColor", color: .adc[selectedType])
                            }
                            
                            // Update current payload
                            if let originalInnerMaterial = originalPayloadInnerMaterial {
                                adcPayloadsInner[dataModel.payloadsWorkingIndex].updateMaterials { material in
                                    material = originalInnerMaterial
                                }
                            }
                            if let originalOuterMaterial = originalPayloadOuterMaterial {
                                adcPayloadsOuter[dataModel.payloadsWorkingIndex].updateMaterials { material in
                                    material = originalOuterMaterial
                                }
                            }
                            adcPayloadsInner[dataModel.payloadsWorkingIndex].updatePBREmissiveColor(.adcEmissive[selectedType])
                            adcPayloadsOuter[dataModel.payloadsWorkingIndex].updateShaderGraphColor(parameterName: "glowColor", color: .adc[selectedType])
                        }
                        
                        // If there's a next payload, give it the outline material
                        let nextIndex = dataModel.payloadsWorkingIndex + 1
                        if nextIndex < adcPayloadsInner.count && nextIndex < adcPayloadsOuter.count {
                            if let material = outlineMaterial {
                                adcPayloadsInner[nextIndex].model?.materials = [material]
                                adcPayloadsOuter[nextIndex].model?.materials = [material]
                            }
                        }
                        
                        adcPayloadsOuter.forEach {
                            $0.components.remove(ADCProximitySourceComponent.self)
                        }
                        
                        let isFinalPayload = dataModel.payloadsWorkingIndex >= (adcPayloadsInner.count - 1)
                        if isFinalPayload {
                            await handleFinalEntityPlacement(
                                entityType: .payload,
                                workingEntity: payloadEntity,
                                savedPosition: initialPayloadPosition,
                                nextStep: 3
                            )
                        } else {
                            if let payloadEntity = self.payloadEntity,
                               let savedPosition = initialPayloadPosition {
                                payloadEntity.position = savedPosition  // Restore to original position
                            }
                            
                            dataModel.payloadsWorkingIndex += 1
                            
                            for (index, element) in adcPayloadsInner.enumerated() {
                                element.isEnabled = index <= dataModel.payloadsWorkingIndex
                            }
                            for (index, element) in adcPayloadsOuter.enumerated() {
                                element.isEnabled = index <= dataModel.payloadsWorkingIndex
                            }
                            
                            adcPayloadsOuter[dataModel.payloadsWorkingIndex].components.set(ADCProximitySourceComponent())
                        }
                        updateADC()
                    }
                } else {
//                    os_log(.debug, "ITR..createPayloadGestureComponent(): Entity \(finishedEntity.name) distance: \(dist)")
                }
            }
        }
        gestureComponent.onRotateStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onRotateEnded = { entity in
            shouldAddADCAttachment = true
            shouldAddLinkerAttachment = true
            shouldAddPayloadAttachment = true
        }
        return gestureComponent
    }
}

```
</file_contents>

