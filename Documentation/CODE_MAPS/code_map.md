<file_map>
├── PfizerOutdoCancer
│   ├── ADC
│   │   ├── ECS
│   │   │   ├── ADCBillboardSystem.swift
│   │   │   ├── ADCCameraSystem.swift
│   │   │   ├── ADCGestureComponent.swift
│   │   │   ├── ADCProximitySystem.swift
│   │   │   └── ADCSimpleBillboardSystem.swift
│   │   ├── Extensions
│   │   │   ├── Gestures
│   │   │   │   ├── ADCEntityExtensions.swift
│   │   │   │   ├── ADCGestureExtensions.swift
│   │   │   │   └── ADCRealityViewExtensions.swift
│   │   │   ├── ADCColor+Extensions.swift
│   │   │   ├── ADCEntity+Extensions.swift
│   │   │   ├── ADCMaterialUtility.swift
│   │   │   ├── ADCMath+Extensions.swift
│   │   │   ├── ADCModelEntity+Extensions.swift
│   │   │   └── ADCView+Extensions.swift
│   │   ├── Models
│   │   │   └── ADCDataModel.swift
│   │   └── Views
│   │       └── ADCBuilder
│   │           ├── ADCOptimizedImmersive
│   │           │   ├── ADCOptimizedImmersive.swift
│   │           │   ├── ADCOptimizedImmersive+Attachments.swift
│   │           │   ├── ADCOptimizedImmersive+Audio.swift
│   │           │   ├── ADCOptimizedImmersive+Entities.swift
│   │           │   └── ADCOptimizedImmersive+Gestures.swift
│   │           ├── ADCBuilderView.swift
│   │           ├── ADCButtonSquareWithOutline.swift
│   │           ├── ADCCheckmarkButton.swift
│   │           ├── ADCLinkerSelectorView.swift
│   │           ├── ADCPayloadSelectorView.swift
│   │           ├── ADCSelectorView.swift
│   │           └── ADCView.swift
│   ├── AppModel
│   │   ├── AppModel.swift
│   │   └── AppModel+AssetLoading.swift
│   ├── AssetManagement
│   │   ├── AssetLoadingManager.swift
│   │   └── AssetLoadingManager+Lab.swift
│   ├── Assets.xcassets
│   │   ├── AccentColor.colorset
│   │   │   └── Contents.json
│   │   ├── ADCBuilder
│   │   │   ├── antibody0.imageset
│   │   │   │   ├── antibody0.png
│   │   │   │   └── Contents.json
│   │   │   ├── antibody1.imageset
│   │   │   │   ├── antibody1.png
│   │   │   │   └── Contents.json
│   │   │   ├── antibody2.imageset
│   │   │   │   ├── antibody2.png
│   │   │   │   └── Contents.json
│   │   │   ├── antibody3.imageset
│   │   │   │   ├── antibody3.png
│   │   │   │   └── Contents.json
│   │   │   ├── linkers0.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── linkers0.png
│   │   │   ├── linkers1.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── linkers1.png
│   │   │   ├── linkers2.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── linkers2.png
│   │   │   ├── linkers3.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── linkers3.png
│   │   │   ├── payload0.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── payload0.png
│   │   │   ├── payload1.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── payload1.png
│   │   │   ├── payload2.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── payload2.png
│   │   │   ├── payload3.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── payload3.png
│   │   │   ├── questionMark.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── questionMark.png
│   │   │   └── Contents.json
│   │   ├── AppIcon.solidimagestack
│   │   │   ├── Back.solidimagestacklayer
│   │   │   │   ├── Content.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── PfizerIconBackground.jpg
│   │   │   │   └── Contents.json
│   │   │   ├── Front.solidimagestacklayer
│   │   │   │   ├── Content.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── PfizerIconFront.png
│   │   │   │   └── Contents.json
│   │   │   ├── Middle.solidimagestacklayer
│   │   │   │   ├── Content.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── PfizerIconMiddle.png
│   │   │   │   └── Contents.json
│   │   │   └── Contents.json
│   │   ├── DarkRed050.colorset
│   │   │   └── Contents.json
│   │   ├── DarkRed200.colorset
│   │   │   └── Contents.json
│   │   ├── DarkRed400.colorset
│   │   │   └── Contents.json
│   │   ├── DarkRed600.colorset
│   │   │   └── Contents.json
│   │   ├── DarkRed800.colorset
│   │   │   └── Contents.json
│   │   ├── gradient050.colorset
│   │   │   └── Contents.json
│   │   ├── gradient200.colorset
│   │   │   └── Contents.json
│   │   ├── gradient400.colorset
│   │   │   └── Contents.json
│   │   ├── gradient600.colorset
│   │   │   └── Contents.json
│   │   ├── gradient800.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue050.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue200.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue400.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue600.colorset
│   │   │   └── Contents.json
│   │   ├── LightBlue800.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen050.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen200.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen400.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen600.colorset
│   │   │   └── Contents.json
│   │   ├── LightGreen800.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard050.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard200.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard400.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard600.colorset
│   │   │   └── Contents.json
│   │   ├── LightMustard800.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed050.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed200.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed400.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed600.colorset
│   │   │   └── Contents.json
│   │   ├── LightRed800.colorset
│   │   │   └── Contents.json
│   │   ├── Pfizer_Logo_Color_RGB.imageset
│   │   │   ├── Contents.json
│   │   │   └── Pfizer_Logo_Color_RGB.png
│   │   ├── Pfizer_Logo_White_RGB.imageset
│   │   │   ├── Contents.json
│   │   │   └── Pfizer_Logo_White_RGB.png
│   │   ├── screen.imageset
│   │   │   ├── Contents.json
│   │   │   └── screen.jpg
│   │   ├── tap.imageset
│   │   │   ├── Contents.json
│   │   │   └── tap.jpg
│   │   └── Contents.json
│   ├── Extensions
│   │   ├── Entity+Animation.swift
│   │   ├── Entity+Audio.swift
│   │   ├── Entity+AudioSystem.swift
│   │   ├── Entity+Find.swift
│   │   ├── Entity+Opacity.swift
│   │   ├── Entity+Trace.swift
│   │   ├── EnvironmentResource.swift
│   │   ├── Transitions.swift
│   │   ├── View+SelectorAnimation.swift
│   │   ├── View+WordAnimation.swift
│   │   └── WordByWordTransition.swift
│   ├── FollowSystemAndComponent
│   │   ├── FollowComponent.swift
│   │   ├── FollowSystem.swift
│   │   ├── HeadPositionTracker.swift
│   │   ├── PositioningComponent.swift
│   │   └── PositioningSystem.swift
│   ├── Managers
│   │   ├── HandTrackingManager.swift
│   │   └── TrackingSessionManager.swift
│   ├── Preview Content
│   │   └── Preview Assets.xcassets
│   │       └── Contents.json
│   ├── Resources
│   │   ├── lab_v005.exr
│   │   └── metro_noord_2k.exr
│   ├── Systems
│   │   ├── ADCMovementSystem.swift
│   │   ├── ADCMovementSystem+Math.swift
│   │   ├── ADCMovementSystem+Retargeting.swift
│   │   ├── ADCMovementSystem+Utils.swift
│   │   ├── ADCSystem.swift
│   │   ├── AntigenSystem.swift
│   │   ├── AttachmentSystem.swift
│   │   ├── BreathingSystem.swift
│   │   ├── CancerCellMovementData.swift
│   │   ├── CancerCellSpeedBoostSystem.swift
│   │   ├── MovementSystem.swift
│   │   ├── RotationAxis.swift
│   │   ├── RotationSystem.swift
│   │   ├── SwirlingSystem.swift
│   │   ├── TraceComponent.swift
│   │   ├── UIAttachmentSystem.swift
│   │   ├── UIStabilizerSystem.swift
│   │   └── UIStateSyncSystem.swift
│   ├── Utility
│   │   ├── ClosureComponent.swift
│   │   ├── CollisionGroups.swift
│   │   ├── Floats.swift
│   │   ├── Gravity.swift
│   │   ├── HeadTracker.swift
│   │   ├── IBLUtility.swift
│   │   ├── Logger.swift
│   │   ├── PortalManager.swift
│   │   ├── RotationHelpers.swift
│   │   └── UnorderedPair.swift
│   ├── ViewModels
│   │   ├── AttackCancerViewModel
│   │   │   ├── AttackCancerViewModel.swift
│   │   │   ├── AttackCancerViewModel+ADC.swift
│   │   │   ├── AttackCancerViewModel+Audio.swift
│   │   │   ├── AttackCancerViewModel+Collisions.swift
│   │   │   ├── AttackCancerViewModel+GameStats.swift
│   │   │   ├── AttackCancerViewModel+HandInteraction.swift
│   │   │   ├── AttackCancerViewModel+Notifications.swift
│   │   │   ├── AttackCancerViewModel+SceneSetup.swift
│   │   │   ├── AttackCancerViewModel+Spawning.swift
│   │   │   └── AttackCancerViewModel+UI.swift
│   │   ├── IntroViewModel
│   │   │   └── IntroViewModel.swift
│   │   ├── LabViewModel
│   │   │   └── LabViewModel.swift
│   │   └── OutroViewModel
│   │       └── OutroViewModel.swift
│   ├── Views
│   │   ├── Effects
│   │   │   └── ButtonHoverEffects.swift
│   │   ├── ADCBuilderViewerButton.swift
│   │   ├── AttackCancerInstructionsView.swift
│   │   ├── AttackCancerView.swift
│   │   ├── AttackCancerViewerButton.swift
│   │   ├── CompletedView.swift
│   │   ├── ContentView.swift
│   │   ├── ErrorView.swift
│   │   ├── GradientNavigationButtonStyle.swift
│   │   ├── HitCounterView.swift
│   │   ├── HopeMeterUtilityView.swift
│   │   ├── HopeMeterView.swift
│   │   ├── IntroView.swift
│   │   ├── IntroWindowView.swift
│   │   ├── LabView.swift
│   │   ├── LabViewerButton.swift
│   │   ├── LibraryView.swift
│   │   ├── LibraryWindow.swift
│   │   ├── LoadingView.swift
│   │   ├── NavigationButton.swift
│   │   ├── NavigationView.swift
│   │   ├── NavToggleView.swift
│   │   ├── OutdoCancer.swift
│   │   ├── OutroView.swift
│   │   ├── Screen.swift
│   │   ├── StartButton.swift
│   │   └── StartView.swift
│   ├── Info.plist
│   └── PfizerOutdoCancerApp.swift

</file_map>

<file_contents>
File: ADC/ECS/ADCBillboardSystem.swift
```swift
import ARKit
import Foundation
import OSLog
@preconcurrency import RealityKit


/// Adjusts the position and orientation of an entity relative to a camera based on specified parameters.
///
/// - Parameters:
///   - offset: A vector that specifies a constant positional offset from the entity or camera.
///   - axisToFollow: A vector used to determine which axes should be followed. For example:
///     - `[0, 1, 0]` will follow the Y-axis, causing the entity to maintain a height equal to the camera’s height plus the offset.
///     - `[0, 0, 0]` fixes the entity’s position (while still enabling billboarding).
///     - `[1, 1, 1]` attaches the entity at a fixed distance (offset) from the camera on all axes.
///
///     **Note:** Currently, only values of `0` or `1` are valid for each component. This may change to booleans in the future.
///
///   - initializePositionOnlyOnce: When `true`, the entity’s initial position is set once—using the first non-zero camera position—then remains constant. When `false`, the entity’s position is updated every frame if `axisToFollow` is not `.zero`.
///
///   - isBillboardEnabled: When `true`, the entity will be reoriented every frame to face the user along the X and Y axes.
///   
struct ADCBillboardComponent: Component, Codable {
    var offset: SIMD3<Float> = .zero
    var axisToFollow: SIMD3<Int> = .zero
    var initializePositionOnlyOnce: Bool = false
    var isBillboardEnabled: Bool = false
    var isPositionInitialized: Bool = false
}

final class ADCBillboardSystem: System {
    static var dependencies: [SystemDependency] = [.before(ADCCameraSystem.self)]
    
    public init(scene: RealityKit.Scene) {
        ADCBillboardComponent.registerComponent()
    }
    
    public func update(context: SceneUpdateContext) {
        guard let cameraEntity = context.entities(matching: EntityQuery(where: .has(ADCCameraComponent.self)), updatingSystemWhen: .rendering).map({ $0 }).first else {
            return
        }

        for entity in context.entities(matching: EntityQuery(where: .has(ADCBillboardComponent.self)), updatingSystemWhen: .rendering) {
            guard var billboard = entity.components[ADCBillboardComponent.self] else { continue }
            if !billboard.isPositionInitialized {
                if cameraEntity.position != .zero {
                    billboard.isPositionInitialized = true
                }
                entity.components.set(billboard)
                let newPosition: SIMD3<Float> = [billboard.axisToFollow.x == 1 ? cameraEntity.position.x : 0,
                                                 billboard.axisToFollow.y == 1 ? cameraEntity.position.y : 0,
                                                 billboard.axisToFollow.z == 1 ? cameraEntity.position.z : 0] + billboard.offset
                entity.position = newPosition
            } else {
                if !billboard.initializePositionOnlyOnce {
                    let newPosition: SIMD3<Float> = [billboard.axisToFollow.x == 1 ? cameraEntity.position.x : 0,
                                                     billboard.axisToFollow.y == 1 ? cameraEntity.position.y : 0,
                                                     billboard.axisToFollow.z == 1 ? cameraEntity.position.z : 0] + billboard.offset
                    
                    entity.position = newPosition
                }
            }
            if billboard.isBillboardEnabled {
                entity.look(at: cameraEntity.scenePosition,
                            from: entity.scenePosition,
                            relativeTo: nil,
                            forward: .positiveZ)
            }

        }
    }
}

```

File: ADC/ECS/ADCGestureComponent.swift
```swift
import RealityKit
import SwiftUI

public class ADCEntityGestureState {
    
    /// The entity currently being dragged if a gesture is in progress.
    var targetedEntity: Entity?
    
    // MARK: - Drag
    
    /// The starting position.
    var dragStartPosition: SIMD3<Float> = .zero
    
    /// Marks whether the app is currently handling a drag gesture.
    var isDragging = false
    
    /// When `rotateOnDrag` is`true`, this entity acts as the pivot point for the drag.
    var pivotEntity: Entity?
    
    var initialOrientation: simd_quatf?
    
    // MARK: - Magnify
    
    /// The starting scale value.
    var startScale: SIMD3<Float> = .one
    
    /// Marks whether the app is currently handling a scale gesture.
    var isScaling = false
    
    // MARK: - Rotation
    
    /// The starting rotation value.
    var startOrientation = Rotation3D.identity
    
    /// Marks whether the app is currently handling a rotation gesture.
    var isRotating = false
    
    // MARK: - Singleton Accessor
    
    /// Retrieves the shared instance.
    @MainActor static let shared = ADCEntityGestureState()
}

// MARK: -

/// A component that handles gesture logic for an entity.
@MainActor
public struct ADCGestureComponent: Component {//}, Codable {
    
    /// A Boolean value that indicates whether a gesture can drag the entity.
    public var canDrag: Bool = true
    
    /// A Boolean value that indicates whether a dragging can move the object in an arc, similar to dragging windows or moving the keyboard.
    public var pivotOnDrag: Bool = true
    
    /// A Boolean value that indicates whether a pivot drag keeps the orientation toward the
    /// viewer throughout the drag gesture.
    ///
    /// The property only applies when `pivotOnDrag` is `true`.
    public var preserveOrientationOnPivotDrag: Bool = true
    
    /// A Boolean value that indicates whether a gesture can scale the entity.
    public var canScale: Bool = true
    
    /// A Boolean value that indicates whether a gesture can rotate the entity.
    public var canRotate: Bool = true
    
    // MARK: - Callbacks
    /// A callback that fires after the entity finishes a drag gesture.
    public var onDragStarted: ((Entity?) -> Void)? = nil
    public var onDragEnded: ((Entity?) -> Void)? = nil
    public var onRotateStarted: ((Entity?) -> Void)? = nil
    public var onRotateEnded: ((Entity?) -> Void)? = nil
    
    // MARK: - Drag Logic
    
    /// Handle `.onChanged` actions for drag gestures.
    mutating func onChanged(value: EntityTargetValue<DragGesture.Value>) {
        guard canDrag else { return }
        
        let state = ADCEntityGestureState.shared
        
        // Only allow a single Entity to be targeted at any given time.
        if state.targetedEntity == nil {
            state.targetedEntity = value.entity
            state.initialOrientation = value.entity.orientation(relativeTo: nil)
        }
        
        if pivotOnDrag {
            handlePivotDrag(value: value)
        } else {
            handleFixedDrag(value: value)
        }
    }
    
    mutating private func handlePivotDrag(value: EntityTargetValue<DragGesture.Value>) {
        
        let state = ADCEntityGestureState.shared
        guard let entity = state.targetedEntity else { fatalError("Gesture contained no entity") }
        
        // The transform that the pivot will be moved to.
        var targetPivotTransform = Transform()
        
        // Set the target pivot transform depending on the input source.
        if let inputDevicePose = value.inputDevicePose3D {
            
            // If there is an input device pose, use it for positioning and rotating the pivot.
            targetPivotTransform.scale = .one
            targetPivotTransform.translation = value.convert(inputDevicePose.position, from: .local, to: .scene)
            targetPivotTransform.rotation = value.convert(AffineTransform3D(rotation: inputDevicePose.rotation), from: .local, to: .scene).rotation
        } else {
            // If there is not an input device pose, use the location of the drag for positioning the pivot.
            targetPivotTransform.translation = value.convert(value.location3D, from: .local, to: .scene)
        }
        
        if !state.isDragging {
            // If this drag just started, create the pivot entity.
            let pivotEntity = Entity()
            
            guard let parent = entity.parent else { fatalError("Non-root entity is missing a parent.") }
            
            // Add the pivot entity into the scene.
            parent.addChild(pivotEntity)
            
            // Move the pivot entity to the target transform.
            pivotEntity.move(to: targetPivotTransform, relativeTo: nil)
            
            // Add the targeted entity as a child of the pivot without changing the targeted entity's world transform.
            pivotEntity.addChild(entity, preservingWorldTransform: true)
            
            // Store the pivot entity.
            state.pivotEntity = pivotEntity
            
            // Indicate that a drag has started.
            state.isDragging = true

            // Invoke the drag started callback here.
            onDragStarted?(entity)
        } else {
            // If this drag is ongoing, move the pivot entity to the target transform.
            // The animation duration smooths the noise in the target transform across frames.
            state.pivotEntity?.move(to: targetPivotTransform, relativeTo: nil, duration: 0.2)
        }
        
        if preserveOrientationOnPivotDrag, let initialOrientation = state.initialOrientation {
            state.targetedEntity?.setOrientation(initialOrientation, relativeTo: nil)
        }
    }
    
    mutating private func handleFixedDrag(value: EntityTargetValue<DragGesture.Value>) {
        let state = ADCEntityGestureState.shared
        guard let entity = state.targetedEntity else { fatalError("Gesture contained no entity") }
        
        if !state.isDragging {
            state.isDragging = true
            state.dragStartPosition = entity.scenePosition
            
            // Invoke the drag started callback here.
             onDragStarted?(entity)
        }
   
        let translation3D = value.convert(value.gestureValue.translation3D, from: .local, to: .scene)
        
        let offset = SIMD3<Float>(x: Float(translation3D.x),
                                  y: Float(translation3D.y),
                                  z: Float(translation3D.z))
        
        entity.scenePosition = state.dragStartPosition + offset
        if let initialOrientation = state.initialOrientation {
            state.targetedEntity?.setOrientation(initialOrientation, relativeTo: nil)
        }
        
    }
    
    /// Handle `.onEnded` actions for drag gestures.
    mutating func onEnded(value: EntityTargetValue<DragGesture.Value>) {
        let state = ADCEntityGestureState.shared
        let endedEntity = state.targetedEntity
        
        state.isDragging = false
        
        if let pivotEntity = state.pivotEntity,
           pivotOnDrag {
            pivotEntity.parent!.addChild(state.targetedEntity!, preservingWorldTransform: true)
            pivotEntity.removeFromParent()
        }
        
        state.pivotEntity = nil
        state.targetedEntity = nil
        
        // Invoke the callback after an entity finishes dragging.
        onDragEnded?(endedEntity)
    }

    // MARK: - Magnify (Scale) Logic
    
    /// Handle `.onChanged` actions for magnify (scale)  gestures.
    mutating func onChanged(value: EntityTargetValue<MagnifyGesture.Value>) {
        let state = ADCEntityGestureState.shared
        guard canScale, !state.isDragging else { return }
        
        let entity = value.entity
        
        if !state.isScaling {
            state.isScaling = true
            state.startScale = entity.scale
        }
        
        let magnification = Float(value.magnification)
        entity.scale = state.startScale * magnification
    }
    
    /// Handle `.onEnded` actions for magnify (scale)  gestures
    mutating func onEnded(value: EntityTargetValue<MagnifyGesture.Value>) {
        ADCEntityGestureState.shared.isScaling = false
    }
    
    // MARK: - Rotate Logic
    
    /// Handle `.onChanged` actions for rotate  gestures.
    mutating func onChanged(value: EntityTargetValue<RotateGesture3D.Value>) {
        let state = ADCEntityGestureState.shared
        guard canRotate, !state.isDragging else { return }

        let entity = value.entity
        
        if !state.isRotating {
            state.isRotating = true
            state.startOrientation = .init(entity.orientation(relativeTo: nil))
            onRotateStarted?(entity) // Rotation has started here
        }
        
        let rotation = value.rotation
        let flippedRotation = Rotation3D(angle: rotation.angle,
                                         axis: RotationAxis3D(x: -rotation.axis.x,
                                                              y: rotation.axis.y,
                                                              z: -rotation.axis.z))
        let newOrientation = state.startOrientation.rotated(by: flippedRotation)
        entity.setOrientation(.init(newOrientation), relativeTo: nil)
    }
    
    /// Handle `.onChanged` actions for rotate  gestures.
    mutating func onEnded(value: EntityTargetValue<RotateGesture3D.Value>) {
        ADCEntityGestureState.shared.isRotating = false

        // Invoke the rotation ended callback
        onRotateEnded?(value.entity)
    }
}


```

File: ADC/ECS/ADCCameraSystem.swift
```swift
import ARKit
import Foundation
import OSLog
@preconcurrency import RealityKit
import SwiftUI

struct ADCCameraComponent: Component, Codable {
}

final class ADCCameraSystem: System {
    
    static let query = EntityQuery(where: .has(ADCCameraComponent.self))
    
    private let arkitSession = ARKitSession()
    private let worldTrackingProvider = WorldTrackingProvider()
    
    public init(scene: RealityKit.Scene) {
        ADCCameraComponent.registerComponent()
        setUpSession()
    }
    
    func setUpSession() {
        Task { [arkitSession, worldTrackingProvider] in
                do {
                    try await arkitSession.run([worldTrackingProvider])
                } catch {
                    os_log(.info, "ITR..Error: \(error)")
                }
        }
    }
    
    public func update(context: SceneUpdateContext) {
        let entities = context.entities(matching: Self.query, updatingSystemWhen: .rendering).map({ $0 })
        
        guard !entities.isEmpty,
              let pose = worldTrackingProvider.queryDeviceAnchor(atTimestamp: CACurrentMediaTime()) else { return }
        let cameraTransform = Transform(matrix: pose.originFromAnchorTransform)
        
        for entity in entities {
            entity.transform = cameraTransform
        }
    }
}

```

File: ADC/ECS/ADCProximitySystem.swift
```swift

import Foundation
@preconcurrency import RealityKit
import OSLog

struct ADCProximityComponent: Component, Codable {
    let minScale: Float
    let maxScale: Float
    let minProximity: Float
    let maxProximity: Float
}

struct ADCProximitySourceComponent: Component, Codable {
}


final class ADCProximitySystem: System {
    
    static let proxymityQuery = EntityQuery(where: .has(ADCProximityComponent.self))
    static let proxymitySourceQuery = EntityQuery(where: .has(ADCProximitySourceComponent.self))
    
//    static let log = OSLog(subsystem: "com.groove.Pfizer", category: "ProximityComponent")
    
    public init(scene: RealityKit.Scene) {
        ADCProximityComponent.registerComponent()
        ADCProximitySourceComponent.registerComponent()
    }
    
    public func update(context: SceneUpdateContext) {
        let sourceEntities = context.entities(matching: Self.proxymitySourceQuery, updatingSystemWhen: .rendering).map({ $0 })
        let proximityEntities = context.entities(matching: Self.proxymityQuery, updatingSystemWhen: .rendering).map({ $0 })
        
//        os_log(.debug, "ITR..ProximitySystem(): sourceCount: \(sourceEntities.count), proximityCount: \(proximityEntities.count)")
        guard let sourceEntity = sourceEntities.first,
              !proximityEntities.isEmpty else {
            return
        }
             
        

        let sourcePosition = sourceEntity.position(relativeTo: nil)
//        let sourceOrientation = sourceEntity.orientation(relativeTo: nil)
        
        for targetEntity in proximityEntities{
            let targetPosition = targetEntity.position(relativeTo: nil)
            let dist = distance(sourcePosition, targetPosition)
            guard let proximity = targetEntity.components[ADCProximityComponent.self] else { continue }
            
//            os_log(.debug, "ITR..Proximity: \(dist)")
            
            // Scale interpolation
            var newScale: Float = dist * (proximity.maxScale - proximity.minScale) / (proximity.maxProximity - proximity.minProximity) + proximity.minScale
            newScale = max(proximity.minScale, min(newScale, proximity.maxScale))
            targetEntity.scale = .init(x: newScale, y: newScale, z: newScale)

//            // Rotation interpolation
//            if dist < proximity.minProximity {
//                targetEntity.orientation = sourceOrientation
//            } else if dist > proximity.maxProximity {
//                targetEntity.orientation = simd_quatf()
//            } else {
//                let t = max(0.0, min(1.0, 1.0 - (dist - proximity.minProximity) / (proximity.maxProximity - proximity.minProximity)))
//                let interpolatedOrientation = simd_slerp(targetEntity.orientation(relativeTo: nil), sourceOrientation, t)
//                targetEntity.orientation = interpolatedOrientation
//            }
        }
    }
}

```

File: ADC/ECS/ADCSimpleBillboardSystem.swift
```swift
import ARKit
import Foundation
import OSLog
@preconcurrency import RealityKit

struct ADCSimpleBillboardComponent: Component, Codable {
}

final class ADCSimpleBillboardSystem: System {
    static var dependencies: [SystemDependency] = [.before(ADCCameraSystem.self)]
    
    public init(scene: RealityKit.Scene) {
        ADCSimpleBillboardComponent.registerComponent()
    }
    
    public func update(context: SceneUpdateContext) {
        guard let cameraEntity = context.entities(matching: EntityQuery(where: .has(ADCCameraComponent.self)), updatingSystemWhen: .rendering).map({ $0 }).first else {
            return
        }

        for entity in context.entities(matching: EntityQuery(where: .has(ADCSimpleBillboardComponent.self)), updatingSystemWhen: .rendering) {
            entity.look(at: cameraEntity.scenePosition,
                        from: entity.scenePosition,
                        relativeTo: nil,
                        forward: .positiveZ)
        }
    }
}

```

File: ADC/Extensions/Gestures/ADCGestureExtensions.swift
```swift
import Foundation
import RealityKit
import SwiftUI

// MARK: - Rotate -

/// Gesture extension to support rotation gestures.
public extension Gesture where Value == EntityTargetValue<RotateGesture3D.Value> {
    
    /// Connects the gesture input to the `GestureComponent` code.
    func useADCGestureComponent() -> some Gesture {
        onChanged { value in
            guard var gestureComponent = value.entity.adcGestureComponent else { return }
            
            gestureComponent.onChanged(value: value)
            
            value.entity.components.set(gestureComponent)
        }
        .onEnded { value in
            guard var gestureComponent = value.entity.adcGestureComponent else { return }
            
            gestureComponent.onEnded(value: value)
            
            value.entity.components.set(gestureComponent)
        }
    }
}

// MARK: - Drag -

/// Gesture extension to support drag gestures.
public extension Gesture where Value == EntityTargetValue<DragGesture.Value> {
    
    /// Connects the gesture input to the `GestureComponent` code.
    func useADCGestureComponent() -> some Gesture {
        onChanged { value in
            guard var gestureComponent = value.entity.adcGestureComponent else { return }
            
            gestureComponent.onChanged(value: value)
            
            value.entity.components.set(gestureComponent)
        }
        .onEnded { value in
            guard var gestureComponent = value.entity.adcGestureComponent else { return }
            
            gestureComponent.onEnded(value: value)
            
            value.entity.components.set(gestureComponent)
        }
    }
}

// MARK: - Magnify (Scale) -

/// Gesture extension to support scale gestures.
public extension Gesture where Value == EntityTargetValue<MagnifyGesture.Value> {
    
    /// Connects the gesture input to the `GestureComponent` code.
    func useADCGestureComponent() -> some Gesture {
        onChanged { value in
            guard var gestureComponent = value.entity.adcGestureComponent else { return }
            
            gestureComponent.onChanged(value: value)
            
            value.entity.components.set(gestureComponent)
        }
        .onEnded { value in
            guard var gestureComponent = value.entity.adcGestureComponent else { return }
            
            gestureComponent.onEnded(value: value)
            
            value.entity.components.set(gestureComponent)
        }
    }
}

```

File: ADC/Extensions/Gestures/ADCRealityViewExtensions.swift
```swift
import Foundation
import RealityKit
import SwiftUI

// MARK: - RealityView Extensions
public extension RealityView {
    
    /// Apply this to a `RealityView` to pass gestures on to the component code.
    func installGestures() -> some View {
        simultaneousGesture(dragGesture)
            .simultaneousGesture(magnifyGesture)
            .simultaneousGesture(rotateGesture)
    }
    
    /// Builds a drag gesture.
    var dragGesture: some Gesture {
        DragGesture()
            .targetedToAnyEntity()
            .useADCGestureComponent()
    }
    
    /// Builds a magnify gesture.
    var magnifyGesture: some Gesture {
        MagnifyGesture()
            .targetedToAnyEntity()
            .useADCGestureComponent()
    }
    
    /// Buildsa rotate gesture.
    var rotateGesture: some Gesture {
        RotateGesture3D()
            .targetedToAnyEntity()
            .useADCGestureComponent()
    }
}

```

File: ADC/Extensions/Gestures/ADCEntityExtensions.swift
```swift
import Foundation
import RealityKit

public extension Entity {
    var adcGestureComponent: ADCGestureComponent? {
        get { components[ADCGestureComponent.self] }
        set { components[ADCGestureComponent.self] = newValue }
    }
    
    /// Returns the position of the entity specified in the app's coordinate system. On
    /// iOS and macOS, which don't have a device native coordinate system, scene
    /// space is often referred to as "world space".
    var scenePosition: SIMD3<Float> {
        get { position(relativeTo: nil) }
        set { setPosition(newValue, relativeTo: nil) }
    }
    
    /// Returns the orientation of the entity specified in the app's coordinate system. On
    /// iOS and macOS, which don't have a device native coordinate system, scene
    /// space is often referred to as "world space".
    var sceneOrientation: simd_quatf {
        get { orientation(relativeTo: nil) }
        set { setOrientation(newValue, relativeTo: nil) }
    }
}

```

File: ADC/Extensions/ADCColor+Extensions.swift
```swift
import SwiftUI

extension Color {
    init(hex: Int, opacity: Double = 1.0) {
        let red = Double((hex & 0xff0000) >> 16) / 255.0
        let green = Double((hex & 0xff00) >> 8) / 255.0
        let blue = Double((hex & 0xff) >> 0) / 255.0
        self.init(.sRGB, red: red, green: green, blue: blue, opacity: opacity)
    }
    
    static var adcDarkBlue: Color {
        Color(.sRGB, red: 0.0, green: 0.0, blue: 0.788, opacity: 1.0)
    }
    static var adcLightBlue: Color {
        Color(.sRGB, red: 0.0, green: 0.584, blue: 1.0, opacity: 1.0)
    }
    static var adcYellow: Color {
        Color(.sRGB, red: 1.0, green: 0.81, blue: 0.233, opacity: 1.0)
    }
    static var adcWhite: Color {
        Color(hex: 0xFFFFFF)
    }
    
    static var adcDarkBlueEmissive: Color {
        Color(.sRGB, red: 0.261, green: 0.261, blue: 0.788, opacity: 1.0)
    }
    static var adcLightBlueEmissive: Color {
        Color(.sRGB, red: 0.301, green: 0.709, blue: 1.0, opacity: 1.0)
    }
    static var adcYellowEmissive: Color {
        Color(.sRGB, red: 1.0, green: 1.0, blue: 0.656, opacity: 1.0)
    }
    static var adcWhiteEmissive: Color {
        Color(hex: 0xFFFFFF)
    }
    
    static var adc: [Color] {
        return [.adcDarkBlue, .adcLightBlue, .adcYellow, .adcWhite]
    }
    
    static var adcEmissive: [Color] {
        return [.adcDarkBlueEmissive, .adcLightBlueEmissive, .adcYellowEmissive, .adcWhiteEmissive]
    }
    
    var toUIColor: UIColor {
        return UIColor(self)
    }
}

extension UIColor {
    convenience init(hex: Int, opacity: Double = 1.0) {
        let red = Double((hex & 0xff0000) >> 16) / 255.0
        let green = Double((hex & 0xff00) >> 8) / 255.0
        let blue = Double((hex & 0xff) >> 0) / 255.0
        self.init(red: red, green: green, blue: blue, alpha: opacity)
    }
    
    static var adcDarkBlue: UIColor {
        UIColor(red: 0.0, green: 0.0, blue: 0.788, alpha: 1.0)
    }
    static var adcLightBlue: UIColor {
        UIColor(red: 0.0, green: 0.584, blue: 1.0, alpha: 1.0)
    }
    static var adcYellow: UIColor {
        UIColor(red: 1.0, green: 0.81, blue: 0.233, alpha: 1.0)
    }
    static var adcWhite: UIColor {
        UIColor(hex: 0xFFFFFF)
    }
    
    static var adcDarkBlueEmissive: UIColor {
        UIColor(red: 0.261, green: 0.261, blue: 0.788, alpha: 1.0)
    }
    static var adcLightBlueEmissive: UIColor {
        UIColor(red: 0.301, green: 0.709, blue: 1.0, alpha: 1.0)
    }
    static var adcYellowEmissive: UIColor {
        UIColor(red: 1.0, green: 1.0, blue: 0.656, alpha: 1.0)
    }
    static var adcWhiteEmissive: UIColor {
        UIColor(hex: 0xFFFFFF)
    }
    
    
    static var adc: [UIColor] {
        return [.adcDarkBlue, .adcLightBlue, .adcYellow, .adcWhite]
    }
    
    static var adcEmissive: [UIColor] {
        return [.adcDarkBlueEmissive, .adcLightBlueEmissive, .adcYellowEmissive, .adcWhiteEmissive]
    }
    
    var hex: Int {
        var red: CGFloat = 0
        var green: CGFloat = 0
        var blue: CGFloat = 0
        var alpha: CGFloat = 0
        
        getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        
        let rgb = Int(
            (Int(red * 255) << 16) |
            (Int(green * 255) << 8) |
            Int(blue * 255)
        )
        
        return rgb
    }
}

```

File: ADC/Extensions/ADCEntity+Extensions.swift
```swift
import RealityKit

/// The extension that enables entities to updates its materials.
extension Entity {
    
    public func updateMaterial(name: String?, _ update: (inout Material) -> Void) {
        guard let name else { return }
        
        // Call recursive function to all child entities.
        for child in children {
            if child.name == name {
                child.updateMaterial(name: name, update)
            }
        }

        // Apply the new values to the component material.
        if var comp = components[ModelComponent.self] {
            comp.materials = comp.materials.map { material in
                var copy = material
                update(&copy)
                return copy
            }
            components.set(comp)
        }
    }

    
    /// Finds all materials in a component, and update them with the custom closure.
    public func updateMaterials(_ update: (inout Material) -> Void) {
        // Call recursive function to all child entities.
        for child in children {
            child.updateMaterials(update)
        }

        // Apply the new values to the component material.
        if var comp = components[ModelComponent.self] {
            comp.materials = comp.materials.map { material in
                var copy = material
                update(&copy)
                return copy
            }
            components.set(comp)
        }
    }
    
    func findModelEntity(named name: String, in entity: Entity? = nil) -> ModelEntity? {
        let entity = entity ?? self
        
        if entity.name == name, let modelEntity = entity as? ModelEntity {
            return modelEntity
        } else {
            for child in entity.children {
                if let result = findModelEntity(named: name, in: child) {
                    return result
                }
            }
        }
        return nil
    }
    
    func findModelEntity(named name: String, from ancestor: String, in entity: Entity? = nil, foundAncestor: Bool = false) -> ModelEntity? {
        let entity = entity ?? self

        if entity.name == name && foundAncestor, let modelEntity = entity as? ModelEntity {
            return modelEntity
        } else {
            var didFoundAncestor = foundAncestor
            
            if entity.name == ancestor {
                didFoundAncestor = true
            }
            
            for child in entity.children {
                if let result = findModelEntity(named: name, from: ancestor, in: child, foundAncestor: didFoundAncestor) {
                    return result
                }
            }
        }
        return nil
    }
    

}

```

File: ADC/Extensions/ADCMath+Extensions.swift
```swift
// ADCMath+Extensions.swift

import RealityKit

extension SIMD3 where Scalar == Float {
    func distance(from other: SIMD3<Float>) -> Float {
        return simd_distance(self, other)
    }

    var printed: String {
        String(format: "(%.8f, %.8f, %.8f)", x, y, z)
    }

    var adcNormalized: SIMD3 {
        return self / simd_length(self)
    }
    
    static let x: Self = .init(1, 0, 0)
    static let up: Self = .init(0, 1, 0)
    static let z: Self = .init(0, 0, 1)

    static func magnitude(pointA: SIMD3<Float>, pointB: SIMD3<Float>) -> Float {
        return pointA.distance(from: pointB)
    }
    
    
    func normalize(to other: SIMD3<Float>) -> SIMD3<Float> {
        // Calculate the vector between the two points
        let directionVector = other - self
        
        // Change from:
        // let magnitude = length(directionVector)
        
        // To:
        let magnitude = simd_length(directionVector)

        // Avoid division by zero
        guard magnitude != 0 else {
            return .zero // No unit vector exists if the two points are the same
        }
        
        // Normalize the vector
        return directionVector / magnitude
    }

    
    func findCollinearPoint(to other: SIMD3<Float>, distance: Float) -> SIMD3<Float> {
        print("ITR..✅ findCollinearPoint(): PointA: \(self), PointB: \(other), distance: \(distance)")
        // Calculate the vector between the two points
        let directionVector = other - self
        
        // Compute the magnitude of the vector
        let magnitude = simd_length(directionVector)
        
        // Avoid division by zero
        guard magnitude != 0 else {
            return self // Return the same point if both points are identical
        }
        
        // Normalize the direction vector
        let unitVector = directionVector / magnitude
        
        // Scale the unit vector by the specified distance
        let scaledVector = unitVector * distance
        
        // Add the scaled vector to the original point to find the new point
        return self + scaledVector
    }

}

```

File: ADC/Extensions/ADCMaterialUtility.swift
```swift
import SwiftUI
import RealityKit

extension ModelEntity {
    /// Apply ADC color to entities using PBR material (antibody and linker)
    func applyADCColor(_ colorIndex: Int) {
//        updatePBRDiffuseColor(.adc[colorIndex])
        updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[colorIndex])
    }
    
    /// Apply ADC color to payload entities, handling both inner (PBR) and outer (ShaderGraph) spheres
    func applyPayloadColor(_ colorIndex: Int, isInner: Bool) {
        if isInner {
            updatePBREmissiveColor(.adcEmissive[colorIndex])
        } else {
            updateShaderGraphColor(parameterName: "glowColor", color: .adc[colorIndex])
        }
    }
}

```

File: ADC/Extensions/ADCView+Extensions.swift
```swift
import SwiftUI

struct SizePreferenceKey: PreferenceKey {
    static var defaultValue: CGSize = .zero
    static func reduce(value: inout CGSize, nextValue: () -> CGSize) {
        value = nextValue()
    }
}

extension View {
    func getSizeOfView(_ getSize: @escaping ((CGSize) -> Void)) -> some View {
        return self
            .background {
                GeometryReader { geometry in
                    Color.clear.preference(
                        key: SizePreferenceKey.self,
                        value: geometry.size
                    )
                    .onPreferenceChange(SizePreferenceKey.self) { value in
                        getSize(value)
                    }
                }
            }
    }
}

```

File: ADC/Models/ADCDataModel.swift
```swift
import Foundation
import RealityKit
import SwiftUI

@Observable
class ADCDataModel {
    // Positioning state
    var isRootSetupComplete = false
    var isEnvironmentSetupComplete = false
    var isHeadTrackingRootReady = false
    var shouldUpdateHeadPosition = false
    var isPositioningComplete = false
    
    var isReadyForInteraction: Bool {
        isRootSetupComplete && 
        isEnvironmentSetupComplete && 
        isHeadTrackingRootReady
    }
    
    // New Step State Management
    struct StepState {
        var colorSelected: Bool = false
        var checkmarkClicked: Bool = false
        var voPlayed: Bool = false
    }
    
    var stepStates: [StepState] = [
        StepState(), // Antibody
        StepState(), // Linker
        StepState(), // Payload
    ]
    
    // Color selections for ADC components
    var selectedADCAntibody: Int? = nil
    public var selectedADCLinker: Int? = nil
    public var selectedADCPayload: Int? = nil
    
    var selectedLinkerType: Int? = nil
    var selectedPayloadType: Int? = nil
    
    public var linkersWorkingIndex: Int = 0
    public var payloadsWorkingIndex: Int = 0
    
    public var adcBuildStep = 0
    
    var placedLinkerCount: Int = 0
    var placedPayloadCount: Int = 0
    
    public var isVOPlaying = false
    public var hasInitialVOCompleted = false
    public var antibodyVOCompleted = false
    public var antibodyStepCompleted = false
    public var showSelector = false
    
    public var manualStepTransition: Bool = false
    
    // Voice-over progress tracking
    public var voiceOverProgress: Double = 0.0
    let voiceOverDurations: [Int: TimeInterval] = [
        0: 18.0,  // VO1
        1: 22.0,  // VO2
        2: 28.0,  // VO3
        3: 16.0   // VO4
    ]
    
    // Updated Navigation Control
    var canMoveForward: Bool {
        if isVOPlaying { return false }
        
        let nextStep = adcBuildStep + 1
        if nextStep >= stepStates.count { return true }
        
        // If VO hasn't played for next step, require current step completion
        if !stepStates[nextStep].voPlayed {
            return stepStates[adcBuildStep].checkmarkClicked
        }
        
        // If VO has played for next step, allow navigation
        return true
    }
    
    var canMoveBack: Bool {
        return adcBuildStep > 0 && !isVOPlaying
    }
    
    var isCurrentStepComplete: Bool {
        guard adcBuildStep < stepStates.count else { return true }
        
        switch adcBuildStep {
        case 0:  // Antibody
            return selectedADCAntibody != nil && stepStates[0].checkmarkClicked
        case 1:  // Linker
            return selectedLinkerType != nil && 
                   linkersWorkingIndex == 3 && 
                   stepStates[1].checkmarkClicked
        case 2:  // Payload
            return selectedPayloadType != nil && 
                   payloadsWorkingIndex == 3 && 
                   stepStates[2].checkmarkClicked
        default:
            return true
        }
    }
    
    // VO Management
    func markVOCompleted(for step: Int) {
        // Only mark steps 0-2 in stepStates
        guard step < stepStates.count else { return }
        stepStates[step].voPlayed = true
        
        // Maintain compatibility with existing antibody flags
        if step == 0 {
            antibodyVOCompleted = true
        }
    }
    
    func shouldPlayVO(for step: Int) -> Bool {
        guard step < stepStates.count else { return false }
        return !stepStates[step].voPlayed
    }
    
    // Fill all linker positions with currently selected linker type
    func fillAllLinkers() {
        // set condition if VO is finished  
        guard let selectedType = selectedLinkerType else { return }
        selectedADCLinker = selectedType
        placedLinkerCount = 4
        linkersWorkingIndex = 4
        
        // Move to next step
        adcBuildStep = 2
        // selectedPayloadType = nil
    }
    
    // Fill all payload positions with currently selected payload type
    func fillAllPayloads() {
        guard let selectedType = selectedPayloadType else { return }
        selectedADCPayload = selectedType
        placedPayloadCount = 4
        payloadsWorkingIndex = 4
        
        // Move to next step
        adcBuildStep = 3
    }
    
    func getADCImageName() -> String {
        if let index = selectedADCAntibody {
            return "antibody\(index)"
        } else {
            return "antibody3"
        }
    }
    func getLinkerImageName() -> String {
        if let index = selectedLinkerType {
            return "linkers\(index)"
        } else {
            return "linkers3"
        }
    }
    func getPayloadImageName() -> String {
        if let index = selectedPayloadType {
            return "payload\(index)"
        } else {
            return "payload3"
        }
    }
    
    // MARK: - Cleanup
    func cleanup() {
        // Reset selections
        selectedADCAntibody = nil
        selectedADCLinker = nil
        selectedADCPayload = nil
        selectedLinkerType = nil
        selectedPayloadType = nil
        
        // Reset indices
        linkersWorkingIndex = 0
        payloadsWorkingIndex = 0
        
        // Reset build step
        adcBuildStep = 0
        
        // Reset counters
        placedLinkerCount = 0
        placedPayloadCount = 0
        
        // Reset flags
        isVOPlaying = false
        hasInitialVOCompleted = false
        showSelector = false
        
        // Reset step states
        stepStates = [StepState(), StepState(), StepState()]
        
        // Reset positioning state
        isPositioningComplete = false
    }
    
    // MARK: - Setup Methods
    func setupRoot() -> Entity {
        // Reset state tracking first
        isRootSetupComplete = false
        isEnvironmentSetupComplete = false
        isHeadTrackingRootReady = false
        isPositioningComplete = false
        
        Logger.info("🔄 Starting new ADC session: tracking states reset")
        Logger.info("📱 ADCDataModel: Setting up root")
        
        let root = Entity()
        root.name = "MainEntity"
        root.position = AppModel.PositioningDefaults.building.position
        
        root.components.set(PositioningComponent(
            offsetX: 0,
            offsetY: 0,
            offsetZ: -1.0,
            needsPositioning: false,
            shouldAnimate: false,
            animationDuration: 0.0
        ))
        
        Logger.info("""
        
        ✅ Root Setup Complete
        ├─ Root Entity: \(root.name)
        ├─ Position: \(root.position(relativeTo: nil))
        └─ Positioning: Ready for explicit updates
        """)
        
        isRootSetupComplete = true
        isHeadTrackingRootReady = true
        return root
    }
}

public enum ADCUIAttachments {
    static let adcSelectorView = "adcSelectorAttachment"
    static let linkerSelectorView = "linkerSelectorAttachment"
    static let payloadSelectorView = "payloadSelectorAttachment"
    static let mainADCView = "mainADCView"
}

```

File: ADC/Extensions/ADCModelEntity+Extensions.swift
```swift
import UIKit
import RealityKit
import os

extension ModelEntity {
    func updatePBRDiffuseColor(_ color: UIColor) {
        if var pbrMaterials = self.model?.materials as? [PhysicallyBasedMaterial],
           !pbrMaterials.isEmpty {
            var pbr = pbrMaterials[0]
            if let existingTexture = pbr.baseColor.texture {
                pbr.baseColor = .init(tint: color, texture: existingTexture)
            } else {
                pbr.baseColor.tint = color
            }
            pbrMaterials[0] = pbr
            self.model?.materials = pbrMaterials
            os_log(.debug, "ITR..updatePBRDiffuseColor(): ✅ Updated baseColor.tint to: \(String(describing: pbr.baseColor.tint))")
        } else {
            os_log(.error, "ITR..updatePBRDiffuseColor(): ❌ materials array is empty")
        }
    }
    
    func updatePBREmissiveColor(_ color: UIColor) {
        if var pbrMaterials = self.model?.materials as? [PhysicallyBasedMaterial],
           !pbrMaterials.isEmpty {
            var pbr = pbrMaterials[0]
            pbr.emissiveColor.color = color
            pbrMaterials[0] = pbr
            self.model?.materials = pbrMaterials
            os_log(.debug, "ITR..updatePBREmissiveColor(): ✅ Updated emissiveColor to: \(String(describing: pbr.emissiveColor.color))")
        } else {
            // For unplaced payloads with outline material, this is expected behavior
            os_log(.debug, "ITR..updatePBREmissiveColor(): ℹ️ Skipping color update - entity has outline material (normal for unplaced payload)")
        }
    }
    
    func updateShaderGraphColor(parameterName: String, color: UIColor) {
        if var materials = self.model?.materials {
            guard var shaderMaterial = materials[0] as? ShaderGraphMaterial else {
                os_log(.error, "ITR..updateShaderGraphColor(): ❌ Material is not ShaderGraphMaterial")
                return
            }
            
            do {
                try shaderMaterial.setParameter(name: parameterName, value: .color(color))
                materials[0] = shaderMaterial
                self.model?.materials = materials
                os_log(.debug, "ITR..updateShaderGraphColor(): ✅ Successfully updated \(parameterName) with color: \(String(describing: color))")
            } catch {
                // For unplaced payloads with outline material, this is expected behavior
                if error is ShaderGraphMaterial.Error {
                    os_log(.debug, "ITR..updateShaderGraphColor(): ℹ️ Parameter not found - entity has outline material (normal for unplaced payload)")
                } else {
                    os_log(.error, "ITR..updateShaderGraphColor(): ❌ Error setting parameter: \(error)")
                }
            }
        } else {
            // For unplaced payloads with outline material, this is expected behavior
            os_log(.debug, "ITR..updateShaderGraphColor(): ℹ️ Skipping color update - entity has outline material (normal for unplaced payload)")
        }
    }
    
    func updateShaderGraphValue(parameterName: String, value: Float) {
        if var materials = self.model?.materials {
            guard var shaderMaterial = materials[0] as? ShaderGraphMaterial else {
                os_log(.error, "ITR..updateShaderGraphColor(): ❌ Material is not ShaderGraphMaterial")
                return
            }
            
            do {
                try shaderMaterial.setParameter(name: parameterName, value: .float(value))
                materials[0] = shaderMaterial
                self.model?.materials = materials
                os_log(.debug, "ITR..updateShaderGraphColor(): ✅ Successfully updated \(parameterName) with color: \(String(describing: value))")
            } catch {
                os_log(.error, "ITR..updateShaderGraphColor(): ❌ Error setting parameter: \(error)")
            }
        } else {
            os_log(.error, "ITR..updateShaderGraphColor(): ❌ No materials found")
        }
    }
    
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive.swift
```swift
// ADCOptimizedImmersive.swift
//
//  ADCOptimizedImmersive
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/4/25.
//
//  This file contains the ADCImmersiveView, which is the immersive view
//  for the ADC Builder.  This view contains the main view hierarchy of the
//  ADC Builder, including the main view, the ADC attachment, and the
//  linker and payload attachment entities.


import SwiftUI
import RealityKit
import RealityKitContent
import OSLog
import ARKit

// MARK: - Types

enum ADCEntityType {
    case linker
    case payload
}

struct ADCOptimizedImmersive: View {
    
    @Environment(AppModel.self) var appModel
    @Environment(ADCDataModel.self) var dataModel
    
    // Audio system
    @State internal var bubblePopSound = false
    
    @State var mainEntity: Entity?
    @State var mainViewEntity = Entity()
    @State var antibodyRootEntity: Entity?
    @State var antibodyEntity: ModelEntity?
    @State var popAudioEntity: Entity?  // Audio source entity for pop sound
    @State var voiceOverAudioEntity: Entity?  // Audio source entity for voice-overs
    
    @State var linkerEntity: Entity?
    @State var payloadEntity: Entity?
    
    @State var workingLinker: ModelEntity?
    @State var workingPayloadInner: ModelEntity?
    @State var workingPayloadOuter: ModelEntity?
    
    // Sort group for managing render order of ADC components
    @State var adcSortGroup: ModelSortGroup?
    
    @State var adcLinkers: [ModelEntity] = .init()
    @State var adcPayloadsInner: [ModelEntity] = .init()
    @State var adcPayloadsOuter: [ModelEntity] = .init()
    
    @State var adcAttachmentEntity: ViewAttachmentEntity?
    @State var linkerAttachmentEntity: ViewAttachmentEntity?
    @State var payloadAttachmentEntity: ViewAttachmentEntity?
    
    @State var shouldAddADCAttachment: Bool = false
    @State var shouldAddLinkerAttachment: Bool = false
    @State var shouldAddPayloadAttachment: Bool = false
    @State var shouldAddMainViewAttachment: Bool = false
    
    @State var refreshFlag = false
    
    @State var popAudioFileResource: AudioFileResource?
    @State var audioEntity: Entity = Entity()
    @State var currentVOController: AudioPlaybackController?
    @State var popAudioPlaybackController: AudioPlaybackController?
    
    @State var vo1Audio: AudioFileResource?
    @State var vo2Audio: AudioFileResource?
    @State var vo3Audio: AudioFileResource?
    @State var vo4Audio: AudioFileResource?
    @State var completionAudio: AudioFileResource?
    @State var niceJobAudio: AudioFileResource?
    
    @State var timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
    @State var isCameraInitialized = false

    @State var useChannelAudioForVO: Bool = true
    
    // let antibodyAttachmentOffset: SIMD3<Float> = SIMD3(-0.5, 0, 0)
    let linkerAttachmentOffset: SIMD3<Float> = SIMD3(0.25, 0, 0)
    let payloadAttachmentOffset: SIMD3<Float> = SIMD3(0.35, 0, 0)
    let defaultZPosition: Float = -1.0
    let antibodyRootOffset: SIMD3<Float> = SIMD3(0, 0, 0)
    
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.openWindow) private var openWindow
    
    @State var originalLinkerMaterial: ShaderGraphMaterial?
    @State var originalPayloadInnerMaterial: PhysicallyBasedMaterial?
    @State var originalPayloadOuterMaterial: ShaderGraphMaterial?
    
    @State var initialLinkerPosition: SIMD3<Float>?
    @State var initialPayloadPosition: SIMD3<Float>?
    
    @State var outlineMaterial: ShaderGraphMaterial?
    
    @State var originalAntibodyMaterial: ShaderGraphMaterial?
    
    @State var targetLinkerEntity: Entity?
    @State var targetPayloadEntity: Entity?
    
    var body: some View {
        RealityView { content, attachments in
            let root = dataModel.setupRoot()
            mainEntity = root
            content.add(root)
            
            Task { @MainActor in
                await setupEntitiesAndMaterials(in: root)
                setupAttachments(attachments: attachments)
                await prepareAudioEntities()
                dataModel.isEnvironmentSetupComplete = true
                dataModel.shouldUpdateHeadPosition = true
            }
        } update: { content, attachments in
            // updateADC()
        } attachments: {
            Attachment(id: ADCUIAttachments.mainADCView) {
                ADCBuilderView()
            }
        }
        .installGestures()
        .onAppear {
            dismissWindow(id: AppModel.navWindowId)
        }
        .onDisappear {
            mainEntity?.removeFromParent()
            mainEntity = nil
        }
        .task {
            await appModel.trackingManager.processWorldTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.monitorTrackingEvents()
        }
        // Position update handler
        .onChange(of: dataModel.shouldUpdateHeadPosition) { _, shouldUpdate in
            if shouldUpdate && dataModel.isReadyForInteraction {
                if let root = mainEntity {
                    Logger.info("""
                    
                    🎯 Head Position Update Requested
                    ├─ Current World Position: \(root.position(relativeTo: nil))
                    ├─ Root Setup: \(dataModel.isRootSetupComplete ? "✅" : "❌")
                    ├─ Environment: \(dataModel.isEnvironmentSetupComplete ? "✅" : "❌")
                    └─ HeadTracking: \(dataModel.isHeadTrackingRootReady ? "✅" : "❌")
                    """)
                    
                    Task {
                        root.checkHeadPosition(animated: true, duration: 0.5)
                        dataModel.shouldUpdateHeadPosition = false
                        dataModel.isPositioningComplete = true  // Set after animation completes
                    }
                }
            }
        }
        // Setup continuation handler
        .onChange(of: dataModel.isPositioningComplete) { _, complete in
            if complete {
                Task { @MainActor in
                    
                    
                    shouldAddADCAttachment = true
                    shouldAddMainViewAttachment = true
                    
                    antibodyRootEntity?.isEnabled = true
                    antibodyEntity?.isEnabled = false
                    antibodyEntity?.opacity = 0
                    dataModel.adcBuildStep = 0
                    
                    // Play audio for initial step
                    do {
                        try await playSpatialAudio(step: 0)
                    } catch {
                        os_log(.error, "ITR..ADCOptimizedImmersive: ❌ Failed to play initial VO: \(error)")
                    }
                }
            }
        }
        .onChange(of: appModel.currentPhase) { oldPhase, newPhase in
            if oldPhase == .building && newPhase != .building {
                print("\n=== ADCOptimizedImmersive Phase Change Cleanup ===")
                print("Transitioning from .building to \(newPhase)")
                cleanup()  // Perform complete cleanup
                print("✅ ADCOptimizedImmersive cleanup complete\n")
            }
        }
        .onChange(of: dataModel.adcBuildStep) { oldValue, newValue in
            Task { @MainActor in
                // Log color summary at each step
                os_log(.debug, "ADC Build Step \(newValue) - Color Summary:")
                os_log(.debug, "- Antibody Color: \(dataModel.selectedADCAntibody ?? -1)")
                os_log(.debug, "- Linker Color: \(dataModel.selectedLinkerType ?? -1)")
                os_log(.debug, "- Payload Color: \(dataModel.selectedPayloadType ?? -1)")
                
                // Play step audio only if this is a natural transition
                if !dataModel.manualStepTransition {
                    Task { @MainActor in
                        do {
                            try await playSpatialAudio(step: newValue)
                        } catch {
                            os_log(.error, "ITR..createLinkerGestureComponent(): ❌ Failed to play VO: \(error)")
                        }
                    }
                }
//                else {
//                    // Reset manual flag for future transitions
//                    dataModel.manualStepTransition = false
//                }
                
                switch newValue {
                case 0:
                    // Starting case - select the antibody color
                    os_log(.debug, "ITR.. ✅ ADC build step 0")
                    // setAntibodyAttachmentPosition()
//                    self.adcLinkers.forEach { $0.isEnabled = false }
                    self.linkerEntity?.isEnabled = false
                    self.payloadEntity?.isEnabled = false

                    updateAttachmentEntities()
                    
                    
                    // Ensure all payloads are disabled in step 0
//                    self.adcPayloadsInner.forEach { $0.isEnabled = false }
//                    self.adcPayloadsOuter.forEach { $0.isEnabled = false }
                case 1:
                    os_log(.debug, "ITR.. ✅ ADC build step 1 - checkmark to move past antibody to linker")
                    self.antibodyRootEntity?.components.remove(ADCGestureComponent.self)
                    for (index, element) in adcLinkers.enumerated() {
                        element.isEnabled = index <= dataModel.linkersWorkingIndex
                        element.components.remove(ADCProximitySourceComponent.self)
                    }
                    adcLinkers[dataModel.linkersWorkingIndex].components.set(ADCProximitySourceComponent())
                    
                    print("going to look for linker entity")
                    if let linkerEntity = linkerEntity {
                        print("case 1, found linker entity")
                        if dataModel.isCurrentStepComplete {
                            print("current step is complete, linker entity = \(linkerEntity.isEnabled)")
//                            linkerEntity.opacity = 1
                            linkerEntity.isEnabled = false
                        } else {
                            print("linker step is not complete, enabling linker entity dataModel.isCurrentStepComplete = \(dataModel.isCurrentStepComplete)")
                            linkerEntity.isEnabled = true
                            linkerEntity.opacity = 1
                            print("setting linker opacity to \(linkerEntity.opacity)")
                        }
                        if !dataModel.manualStepTransition {
                            print("manualStepTransition = \(dataModel.manualStepTransition)")
                            linkerEntity.opacity = 0
                            print("setting linker opacity to \(linkerEntity.opacity)")
                        }
                    }
                    self.linkerAttachmentEntity?.isEnabled = true
                    self.payloadEntity?.isEnabled = false
                case 2:
                    // clicked checkmark to apply the material to all of the linkers
                    os_log(.debug, "ITR.. ✅ ADC build step 2 - checkmark to fill all linkers")
                    // If we came from checkmark button (all linkers filled)
                    if dataModel.linkersWorkingIndex == 4 {
                        Task { @MainActor in
                            // Play pop sound for successful placement
                            // bubblePopSound.toggle()
                            
                            // Apply original material and selected color to all linkers
                            for linker in adcLinkers {
                                if let originalMaterial = originalLinkerMaterial {
                                    linker.updateMaterials { material in
                                        material = originalMaterial
                                    }
                                }
                                // changed underlying shader to shaderGraph
                                linker.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[dataModel.selectedLinkerType ?? 0])
                                linker.isEnabled = true
                            }
                            
                            // Only advance step after visuals are complete
                            // dataModel.adcBuildStep = 3
                        }
                    }
                    
                    self.adcLinkers.forEach { $0.isEnabled = true }
                    self.linkerEntity?.isEnabled = false
                    self.linkerAttachmentEntity?.isEnabled = false
                    
//                    if let payloadEntity = payloadEntity {
//                        if dataModel.isCurrentStepComplete {
//                            payloadEntity.isEnabled = true
//                        }
//                        payloadEntity.isEnabled = false
//                        payloadEntity.opacity = 0
//                    }
                    
                    print("going to look for payload entity")
                    if let payloadEntity = payloadEntity {
                        print("case 1, found payloadEntity entity")
                        if dataModel.isCurrentStepComplete {
                            print("current step is complete, payloadEntity entity = \(payloadEntity.isEnabled)")
                            payloadEntity.isEnabled = false
                        } else {
                            print("payloadEntity step is not complete, enabling payloadEntity  dataModel.isCurrentStepComplete = \(dataModel.isCurrentStepComplete)")
                            payloadEntity.isEnabled = true
                            payloadEntity.opacity = 1
                            print("setting payloadEntity opacity to \(payloadEntity.opacity)")
                        }
                        if !dataModel.manualStepTransition {
                            print("manualStepTransition = \(dataModel.manualStepTransition)")
                            payloadEntity.opacity = 0
                            print("setting payloadEntity opacity to \(payloadEntity.opacity)")
                        }
                    }
                    
                    
                    // Restore payload setup code
                    for (index, element) in adcPayloadsInner.enumerated() {
                        element.isEnabled = index <= dataModel.payloadsWorkingIndex
                    }
                    for (index, element) in adcPayloadsOuter.enumerated() {
                        element.isEnabled = index <= dataModel.payloadsWorkingIndex
                        element.components.remove(ADCProximitySourceComponent.self)
                    }
                    adcPayloadsOuter[dataModel.payloadsWorkingIndex].components.set(ADCProximitySourceComponent())
                case 3:
                    // clicked checkmark to apply the material to all of the payloads
                    os_log(.debug, "ITR.. ✅ ADC build step 3 - checkmark to fill all payloads")
                    // If we came from checkmark button (all payloads filled)
                    // play animation sequence
                    if !dataModel.manualStepTransition {
                        print("dataModel.manualStepTransition = \(dataModel.manualStepTransition) Must play animation sequence")
                        Task { @MainActor in
                            if let antibodyRootEntity = antibodyRootEntity {
                                os_log(.debug, "ITR..🔍 Starting ADC animation sequence")
                                
                                if let adcComplexEntity = antibodyRootEntity.findEntity(named: "ADC_complex_001") {
                                    os_log(.debug, "ITR..Found ADC_complex_001, starting animation sequence")
                                    os_log(.debug, "ITR..Initial ADC position: %@", String(describing: adcComplexEntity.position))
                                    
                                    
                                    // Move antibody up
                                    await adcComplexEntity.animatePosition(
                                        to: SIMD3(-0.4, 0, 0),
                                        duration: 1.0,
                                        timing: .easeInOut,
                                        waitForCompletion: true
                                    )
                                    os_log(.debug, "ITR..ADC position after move: %@", String(describing: adcComplexEntity.position))
                                    
                                    // Start rotation
                                    os_log(.debug, "ITR..Starting ADC rotation")
                                    adcComplexEntity.startContinuousRotation(speed: 0.5, axis: .xAxis)
                                    
                                    // Move main view back
                                    os_log(.debug, "ITR..Moving main view back to original position")
                                    await mainViewEntity.animatePositionAndRotation(
                                        position: SIMD3(0.5, 0, -0.2),
                                        rotation: 0,
                                        duration: 1.0,
                                        timing: .easeInOut,
                                        waitForCompletion: true
                                    )
                                    os_log(.debug, "ITR..Main view returned to original position")
                                    
                                } else {
                                    os_log(.error, "ITR..❌ Could not find ADC_complex_001 entity")
                                }
                            } else {
                                os_log(.error, "ITR..❌ No antibody root entity found")
                            }
                        }
                    }
                    

                    if dataModel.payloadsWorkingIndex == 4 {
                        Task { @MainActor in
                            // Play pop sound for successful placement
                            bubblePopSound.toggle()
                            
                            // Apply original materials and selected color to all payloads
                            for (inner, outer) in zip(adcPayloadsInner, adcPayloadsOuter) {
                                if let originalInnerMaterial = originalPayloadInnerMaterial {
                                    inner.updateMaterials { material in
                                        material = originalInnerMaterial
                                    }
                                }
                                if let originalOuterMaterial = originalPayloadOuterMaterial {
                                    outer.model?.materials = [originalOuterMaterial]
                                }
                                
                                inner.updatePBREmissiveColor(.adcEmissive[dataModel.selectedPayloadType ?? 0])
                                outer.updateShaderGraphColor(parameterName: "glowColor", color: .adc[dataModel.selectedPayloadType ?? 0])
                                
                                inner.isEnabled = true
                                outer.isEnabled = true
                            }
                            
                            // Only advance step after visuals are complete
                            // dataModel.adcBuildStep = 4
                            
                        }
                    }
                    
                    self.linkerEntity?.isEnabled = false
                    self.linkerAttachmentEntity?.isEnabled = false
                    self.payloadEntity?.isEnabled = false
                    antibodyRootEntity?.components.set(createGestureComponent())
                default:
                    os_log(.debug, "ITR.. ✅ ADC build step \(newValue)")
                    self.linkerEntity?.isEnabled = false
                    self.linkerAttachmentEntity?.isEnabled = false
                    self.payloadEntity?.isEnabled = false
                    antibodyRootEntity?.components.set(createGestureComponent())
                }
                
                
                    // Reset manual flag for future transitions
                    dataModel.manualStepTransition = false
                
            }
        }
        // Change the Antibody 3D model material color to the selected color
        .onChange(of: dataModel.selectedADCAntibody) { oldValue, newValue in
            os_log(.debug, "ITR..onChange(of: selectedADCAntibody): new value: \(newValue ?? -1)")
            handleAntibodyColorChange(newValue: newValue)
        }
        .onChange(of: dataModel.isVOPlaying) { oldValue, newValue in
            if !newValue {  // VO finished playing
                Task { @MainActor in
                    os_log(.debug, "ITR..VO finished playing, current step: \(dataModel.adcBuildStep)")
                    // Fade in the appropriate entities based on current step
                    switch dataModel.adcBuildStep {
                    case 0:  // Initial fade in of antibody
                        // if dataModel.adcBuildStep == 0 && !dataModel.hasInitialVOCompleted {
                        //     dataModel.hasInitialVOCompleted = true
                        //     // dataModel.showSelector = true
                        // }
                        dataModel.hasInitialVOCompleted = true
                        dataModel.antibodyVOCompleted = true
                        
                        
//                        try? await mainEntity.animatePosition(to: SIMD3(-0.125, 0, 0), duration: 1.0, delay: 0.0)
//                        os_log(.debug, "ITR..Attempting to animate main view position")
                        await mainViewEntity.animatePositionAndRotation(
                            position: SIMD3(-0.5, 0, 0.2),
                            rotation: 30,
                            duration: 1.0,
                            delay: 0.5
                        )
                        
                        // After position animation, fade in antibody with delay
                        if let antibodyEntity = antibodyEntity {
                            os_log(.debug, "ITR..antibodyEntity exists, fading in")
                            await antibodyEntity.fadeOpacity(to: 1, duration: 1.0, delay: 1.0)
                            antibodyEntity.isEnabled = true
                            os_log(.debug, "ITR..antibodyEntity fade complete, isEnabled set to true")
                        }
                    case 1:  // Fade in linker
                        // dataModel.showSelector = true
                        os_log(.debug, "ITR..Attempting to fade in linker entities")
                        if let linkerEntity = linkerEntity {
                            os_log(.debug, "ITR..linkerEntity exists, isEnabled: \(linkerEntity.isEnabled)")
                            // Fade in entities
                            await linkerEntity.fadeOpacity(to: 1, duration: 1.0)
                            linkerEntity.isEnabled = true
                            os_log(.debug, "ITR..linkerEntity fade complete, isEnabled set to true")
                        } else {
                            os_log(.error, "ITR..❌ linkerEntity is nil")
                        }
                    case 2:  // Fade in payload
                        // dataModel.showSelector = true
                        if let payloadEntity = payloadEntity {
                            os_log(.debug, "ITR..Attempting to fade in payloadEntity")
                            os_log(.debug, "ITR..payload.isEnabled: \(payloadEntity.isEnabled)")
                            await payloadEntity.fadeOpacity(to: 1, duration: 1.0)
                            payloadEntity.isEnabled = true
                        }
                    default:
                        os_log(.debug, "ITR..No fade needed for step \(dataModel.adcBuildStep)")
                    }
                    
                    await checkAndAdvanceStep()
                }
            }
        }
        // Change the linker 3D model material color to the selected color
        .onChange(of: dataModel.selectedLinkerType) { oldValue, newValue in
            Task { @MainActor in
                if let newValue {
                    // Update working (target) linker first
                    if let workingLinker {
                        // First restore original material
                        if let originalMaterial = originalLinkerMaterial {
                            if var modelComponent = workingLinker.components[ModelComponent.self] {
                                modelComponent.materials = [originalMaterial]
                                workingLinker.components[ModelComponent.self] = modelComponent
                            }
                        }
                        // Then apply color
                        workingLinker.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[newValue])
                    }
                    
                    // Update all previously placed linkers (up to current working index)
                    for index in 0..<dataModel.linkersWorkingIndex {
                        if let originalMaterial = originalLinkerMaterial {
                            if var modelComponent = adcLinkers[index].components[ModelComponent.self] {
                                modelComponent.materials = [originalMaterial]
                                adcLinkers[index].components[ModelComponent.self] = modelComponent
                            }
                        }
                        adcLinkers[index].updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[newValue])
                    }

                    // Change all linkers to the same color
                    for linker in adcLinkers {
                        linker.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[newValue])
                    }
                }
            }
        }
        // Change the payload inner and outer 3D model material color to the selected color
        .onChange(of: dataModel.selectedPayloadType) { oldValue, newValue in
            os_log(.debug, "ITR..onChange(of: dataModel.selectedPayloadType): New change selected working payload: \(newValue ?? -1)")
            guard dataModel.adcBuildStep == 2  else {
                os_log(.error, "ITR..onChange(of: dataModel.selectedPayloadType): ❌ Error, got a new value for selectedPayloadType: \(newValue ?? -1) but adcBuildStep is not 2")
                return
            }
            Task { @MainActor in
                if let newValue {
                    // Update working (target) payload first
                    if let workingPayloadInner,
                       let workingPayloadOuter {
                        // First restore original materials
                        if let originalInnerMaterial = originalPayloadInnerMaterial {
                            if var modelComponent = workingPayloadInner.components[ModelComponent.self] {
                                modelComponent.materials = [originalInnerMaterial]
                                workingPayloadInner.components[ModelComponent.self] = modelComponent
                            }
                        }
                        if let originalOuterMaterial = originalPayloadOuterMaterial {
                            if var modelComponent = workingPayloadOuter.components[ModelComponent.self] {
                                modelComponent.materials = [originalOuterMaterial]
                                workingPayloadOuter.components[ModelComponent.self] = modelComponent
                            }
                        }
                        // Then apply colors
                        workingPayloadInner.updatePBREmissiveColor(.adcEmissive[newValue])
                        workingPayloadOuter.updateShaderGraphColor(parameterName: "glowColor", color: .adc[newValue])
                    }
                    
                    // Change all payloads to the same color
                    for (inner, outer) in zip(adcPayloadsInner, adcPayloadsOuter) {
                        inner.updatePBREmissiveColor(.adcEmissive[newValue])
                        outer.updateShaderGraphColor(parameterName: "glowColor", color: .adc[newValue])
                    }
                }
            }
        }
        .onChange(of: bubblePopSound) { oldValue, newValue in
            os_log(.debug, "ITR..onChange(bubblePopSound): 🔊 SYSTEM 1 - Playing through popAudioPlaybackController")
            self.popAudioPlaybackController?.play()
        }

    }
    
    // MARK: - Step Management
    
    /// Checks conditions and advances to the next step if appropriate
    private func checkAndAdvanceStep() async {
        // Don't advance if VO is still playing
        guard !dataModel.isVOPlaying else { return }
        
        switch dataModel.adcBuildStep {
        case 1:  // Linker step
            // Check if we're on the last linker and it's been placed
            if dataModel.linkersWorkingIndex >= (adcLinkers.count - 1) {
                try? await Task.sleep(for: .milliseconds(500))
                dataModel.adcBuildStep = 2
                dataModel.selectedPayloadType = nil
            }
        case 2:  // Payload step
            // Check if we're on the last payload and it's been placed
            if dataModel.payloadsWorkingIndex >= (adcPayloadsInner.count - 1) {
                try? await Task.sleep(for: .milliseconds(500))
                dataModel.adcBuildStep = 3
            }
        default:
            break  // No auto-advancement for other steps
        }
    }
    
    // MARK: - Preparation

    private func handleAntibodyColorChange(newValue: Int?) {
        Task { @MainActor in
            guard let newValue = newValue,
                  let antibodyEntity = antibodyEntity else {
                os_log(.error, "ITR..handleAntibodyColorChange: ❌ Missing newValue or antibodyEntity")
                return
            }
            
            if var modelComponent = antibodyEntity.components[ModelComponent.self] {
                // First restore original material
                if let originalMaterial = originalAntibodyMaterial {
                    modelComponent.materials = [originalMaterial]
                    antibodyEntity.components[ModelComponent.self] = modelComponent
                    os_log(.debug, "ITR..handleAntibodyColorChange: ✅ Restored original material")
                }
                
                // Then apply the color
                antibodyEntity.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[newValue])
                os_log(.debug, "ITR..handleAntibodyColorChange: ✅ Applied color \(newValue)")
            }
        }
    }

    private func updateAttachmentEntities() {
        print("dataModel.isCurrentStepComplete: \(dataModel.isCurrentStepComplete)")
        let currentStepComplete = dataModel.isCurrentStepComplete
        linkerAttachmentEntity?.isEnabled = !currentStepComplete
        payloadAttachmentEntity?.isEnabled = !currentStepComplete
    }
    
    private func setupEntitiesAndMaterials(in root: Entity) async {
        // Add IBL setup first
        do {
            try await IBLUtility
                .addImageBasedLighting(
                    to: root,
                    imageName: "metro_noord_2k",
                    intensity: 0.5
                )
            os_log(.debug, "ADCOptimizedImmersive: Successfully setup IBL lighting")
        } catch {
            os_log(.error, "ADCOptimizedImmersive: Failed to setup IBL with error: %@", error.localizedDescription)
        }
        // Get outline material
        do {
            let materialEntity = try await Entity(named: "Materials/M_outline.usda", in: realityKitContentBundle)
            if let sphereEntity = materialEntity.findEntity(named: "Sphere"),
               let material = sphereEntity.components[ModelComponent.self]?.materials.first as? ShaderGraphMaterial {
                os_log(.debug, "ADCOptimizedImmersive: Successfully loaded outline material")
                self.outlineMaterial = material
            } else {
                os_log(.error, "ADCOptimizedImmersive: Could not find sphere or material in M_outline.usda")
            }
        } catch {
            os_log(.error, "ADCOptimizedImmersive: Failed to load outline material with error: %@", error.localizedDescription)
        }
        
        // Get antibody scene from asset manager
        do {
            let antibodyScene = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "antibody_scene",
                category: .buildADCEnvironment
            )
            os_log(.debug, "ADCOptimizedImmersive: Antibody scene loaded successfully")
            self.antibodyRootEntity = antibodyScene
            // Optionally log some identifying property:
            if let name = antibodyScene.name as String? {
                os_log(.debug, "ADCOptimizedImmersive: Antibody scene name: %@", name)
            }
            prepareAntibodyEntities()
            
            await prepareLinkerEntities()
            await preparePayloadEntities()
            if let rootEntity = antibodyRootEntity {
                prepareTargetEntities(antibodyScene: rootEntity)
            }
            
            self.adcLinkers.forEach { $0.isEnabled = false }
            
            // Create sort group for all ADC components
            self.adcSortGroup = ModelSortGroup(depthPass: .postPass)
            os_log(.debug, "ADCOptimizedImmersive: Created ADC sort group successfully")
        } catch {
            os_log(.error, "ADCOptimizedImmersive: Failed to load antibody scene with error: %@", error.localizedDescription)
        }
    }
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Attachments.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import OSLog

extension ADCOptimizedImmersive {
//        func calculateMainViewPosition() -> SIMD3<Float> {
////        let cameraPosition = cameraEntity.position(relativeTo: nil)
////         let antibodyPosition = antibodyEntity?.position(relativeTo: nil) ?? [0, 0, defaultZPosition]  
////        
////        return SIMD3<Float>(
////            antibodyPosition.x + -0.5,
////            antibodyPosition.y + 0,
////            antibodyPosition.z + 0
////        )
//        // calculateRadialPosition(cameraPosition: cameraPosition, 
//        //                              antibodyPosition: antibodyPosition, 
//        //                              angleDegrees: -35, 
//        //                              yOffset: antibodyPosition.y, 
//        //                              radiusOffset: 0.1)
//    }
    
   func calculateTargetLinkerPosition() -> SIMD3<Float> {
        let antibodyPosition = antibodyEntity?.position(relativeTo: nil) ?? SIMD3<Float>(0, 0, defaultZPosition)
       
       // Return position 0.5 meters to the right of the antibody
       return SIMD3<Float>(
           antibodyPosition.x + linkerAttachmentOffset.x,  // 0.5 meters to the right
           antibodyPosition.y + linkerAttachmentOffset.y,        // same height
           antibodyPosition.z + linkerAttachmentOffset.z         // same depth
       )
   }
   func calculateTargetPayloadsPosition() -> SIMD3<Float> {
       
    //    let cameraPosition = cameraEntity.position(relativeTo: nil)
        let antibodyPosition = antibodyEntity?.position(relativeTo: nil) ?? [0, 0, defaultZPosition]
       
       return SIMD3<Float>(
           antibodyPosition.x + payloadAttachmentOffset.x,  // 0.5 meters to the right
           antibodyPosition.y + payloadAttachmentOffset.y,        // same height
           antibodyPosition.z + payloadAttachmentOffset.z         // same depth
       )
    //    calculateRadialPosition(cameraPosition: cameraPosition, antibodyPosition: antibodyPosition, angleDegrees: 35, yOffset: antibodyPosition.y, radiusOffset: 0.1)

   }
    
    func setAntibodyAttachmentPosition() {
        
        // let cameraPosition = cameraEntity.position(relativeTo: nil)
        // let antibodyPosition = antibodyEntity?.position(relativeTo: nil) ?? [0, 1.5, defaultZPosition]
        
        // let newPosition = calculateRadialPosition(cameraPosition: cameraPosition, antibodyPosition: antibodyPosition, angleDegrees: 35, yOffset: antibodyPosition.y, radiusOffset: 0.1)
        // adcAttachmentEntity?.position = newPosition
    }
    
    func setLinkerAttachmentPosition() {
        if let linkerAttachmentEntity = linkerAttachmentEntity,
           let linkerEntity = linkerEntity {
            // Get the world position of the linker entity
            let linkerPosition = linkerEntity.position(relativeTo: nil)
            // Set the attachment position with offset
            linkerAttachmentEntity.position = linkerPosition + linkerAttachmentOffset
        }
    }
    
    // func calculateRadialPosition(cameraPosition camera: SIMD3<Float>, antibodyPosition antibody: SIMD3<Float>, angleDegrees: Float, yOffset: Float, radiusOffset: Float = 0.0) -> SIMD3<Float>  {
    //      let c: SIMD3<Float> = [camera.x,0,camera.z]
    //      let a: SIMD3<Float> = [antibody.x ,0,antibody.z]

    //      let directionVector = a - c
    //      let radius = length(directionVector)
    //      let normalizedAC = directionVector.adcNormalized

    //      let aAngleRadians = atan2(normalizedAC.z, normalizedAC.x)
    //      let aAngleDegrees = aAngleRadians * 180 / .pi

    //      let newAngleDegrees = (aAngleDegrees + angleDegrees)
    //      let newAngleRadians = newAngleDegrees * .pi / 180

    //      let x = (radius + radiusOffset) * cos(newAngleRadians)
    //      let z = (radius + radiusOffset) * sin(newAngleRadians)

    //      let b: SIMD3<Float> = [x,yOffset,z] + c
        
    //      return b
    // }
    
    
    func updateADC() {
//        os_log(.debug, "ITR..updateADC() called")
        mainViewEntity.isEnabled = shouldAddMainViewAttachment
        if shouldAddMainViewAttachment {
            //Calculate the new position of mainViewEntity
            // mainViewEntity.position = calculateMainViewPosition()
        }
        if (dataModel.adcBuildStep == 0) {
            if let adcAttachmentEntity {
                if shouldAddADCAttachment {
                    mainEntity?.addChild(adcAttachmentEntity)
                    
//                    if let antibodyEntity {
//                        self.adcAttachmentEntity?.position = antibodyEntity.position(relativeTo: nil) + antibodyAttachmentOffset
//                    }
                    // setAntibodyAttachmentPosition()
                    
                } else {
                    mainEntity?.removeChild(adcAttachmentEntity)
                }
            }
            self.linkerAttachmentEntity?.isEnabled = false
            if let payloadAttachmentEntity { payloadEntity?.removeChild(payloadAttachmentEntity) }
        }
        if (dataModel.adcBuildStep == 1) {
            // if let adcAttachmentEntity { mainEntity?.removeChild(adcAttachmentEntity) }
            setLinkerAttachmentPosition()
            if shouldAddLinkerAttachment {
                self.linkerAttachmentEntity?.isEnabled = true

            } else {
                self.linkerAttachmentEntity?.isEnabled = false
            }
            if let payloadAttachmentEntity { payloadEntity?.removeChild(payloadAttachmentEntity) }
        }
        if (dataModel.adcBuildStep == 2) {
            // if let adcAttachmentEntity { mainEntity?.removeChild(adcAttachmentEntity) }
            self.linkerAttachmentEntity?.isEnabled = false
            if let payloadAttachmentEntity {
                if shouldAddPayloadAttachment {
                    payloadEntity?.addChild(payloadAttachmentEntity)
                } else {
                    payloadEntity?.removeChild(payloadAttachmentEntity)
                }
            }
        }
    }
    
    func setupAttachments(attachments: RealityViewAttachments) {
        if let viewAttachment = attachments.entity(for: ADCUIAttachments.mainADCView) {
            viewAttachment.name = ADCUIAttachments.mainADCView
//            viewAttachment.scale = SIMD3<Float>(0.6, 0.6, 0.6)
            viewAttachment.scale = .one
            //  viewAttachment.components[BillboardComponent.self] = BillboardComponent()
            mainViewEntity.addChild(viewAttachment)
        }
    }
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Audio.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import OSLog

extension ADCOptimizedImmersive {
    
    // MARK: - Audio Functions
    
    func prepareAudioEntities() async {
        // Load audio resources
        if let resource = try? await AudioFileResource(named: "/Root/bubblepop_mp3", from: "antibodyScene.usda", in: realityKitContentBundle) {
            popAudioFileResource = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded pop sound")
            
            // Create pop sound entity with spatial audio
            let popSource = Entity()
            popSource.name = "PopSource"
            popSource.components.set(SpatialAudioComponent(
                gain: 0.5,  // Reduce volume to 50%
                directivity: .beam(focus: 1.0)
            ))
            if let popAudioFileResource = popAudioFileResource {
                popAudioPlaybackController = popSource.prepareAudio(popAudioFileResource)
                if popAudioPlaybackController != nil {
                    os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully prepared pop sound controller")
                } else {
                    os_log(.error, "ITR..ADCOptimizedImmersive: ❌ Failed to create pop sound controller")
                }
            }
            self.popAudioEntity = popSource
            
            // Detach pop sound from main entity
            if let mainEntity {
                mainEntity.removeChild(popSource)
                os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully detached pop sound from main entity")
            }
        } else {
            os_log(.error, "ITR..ADCOptimizedImmersive: ❌ Error loading pop sound from antibodyScene.usda")
        }

        if let resource = try? await AudioFileResource(named: "/Root/BuildADC_VO_1_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            vo1Audio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded VO1")
        }
        if let resource = try? await AudioFileResource(named: "/Root/BuildADC_VO_2_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            vo2Audio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded VO2")
        }
        if let resource = try? await AudioFileResource(named: "/Root/BuildADC_VO_3_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            vo3Audio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded VO3")
        }
        if let resource = try? await AudioFileResource(named: "/Root/BuildADC_VO_4_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            vo4Audio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded VO4")
        }
        if let resource = try? await AudioFileResource(named: "/Root/ADC_Build_Complete_1_wav", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            completionAudio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded completion sound")
        }
        if let resource = try? await AudioFileResource(named: "/Root/niceJob_mp3", from: "BuildADC_VO.usda", in: realityKitContentBundle) {
            niceJobAudio = resource
            os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully loaded nice job sound")
        }

        // Create voice-over entity with spatial audio - attached to main view entity
        let voiceOverSource = Entity()
        voiceOverSource.name = "VoiceOverSource"

        // Conditionally set up the audio entity to be spatial or channel-based
        if !useChannelAudioForVO { // Only add the spatial component if NOT using channel audio
            voiceOverSource.components.set(SpatialAudioComponent(directivity: .beam(focus: 1.0)))
        }

        if let mainEntity {
            mainEntity.addChild(voiceOverSource)
        }
        self.voiceOverAudioEntity = voiceOverSource
        os_log(.debug, "ITR..ADCOptimizedImmersive: ✅ Successfully set up voice over entity")
    }

    func attachPopSoundToTarget(_ target: Entity) {
        if let popSound = popAudioEntity {
            // Remove from current parent if any
            popSound.removeFromParent()
            
            // Add to new target and set transform
            target.addChild(popSound)
            popSound.transform = .init(scale: .one, rotation: .init(), translation: .zero)
            
            // Ensure spatial audio component is set
            if !popSound.components.has(SpatialAudioComponent.self) {
                popSound.components.set(SpatialAudioComponent(
                    gain: 1.0,
                    directivity: .beam(focus: 1.0)
                ))
                os_log(.debug, "ITR..attachPopSoundToTarget(): Added spatial audio component")
            }
            
            os_log(.debug, "ITR..attachPopSoundToTarget(): Successfully attached pop sound to target at position: \(target.position)")
        } else {
            os_log(.error, "ITR..attachPopSoundToTarget(): No pop sound entity available")
        }
    }

    func playPopSound() {
        os_log(.debug, "ITR..playPopSound(): Starting pop sound playback...")
        
        if let controller = popAudioPlaybackController {
            if let popSound = popAudioEntity {
                os_log(.debug, "ITR..playPopSound(): Pop sound entity position: \(popSound.position)")
            }
            
            // Stop any currently playing pop sound
            controller.stop()
            
            // Play the sound
            controller.play()
            os_log(.debug, "ITR..playPopSound(): Started playing pop sound")
        } else {
            os_log(.error, "ITR..playPopSound(): ❌ No popAudioPlaybackController")
        }
    }

    @MainActor
    func playSpatialAudio(step: Int) async throws {
        os_log(.debug, "ITR..playSpatialAudio(): Playing spatial audio for step \(step)")
        
        // Only check VO played state for steps 0-2
        if step != 3 {  // Skip check for step 3
            if step < dataModel.stepStates.count && dataModel.stepStates[step].voPlayed {
                return
            }
        }

        dataModel.isVOPlaying = true
        dataModel.voiceOverProgress = 0.0
        
        // Stop any currently playing VO
        if let controller = currentVOController {
            controller.stop()
            currentVOController = nil
        }
        
        // For step 3, play completion sound first
        if step == 3 {
            guard let completionAudio,
                  let niceJobAudio,
                  let vo4Audio,
                  let voEntity = voiceOverAudioEntity else {
                os_log(.error, "ITR..playSpatialAudio(): Missing required audio or entity for step 3")
                throw NSError(domain: "ADCOptimizedImmersive", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing required audio or entity for step 3"])
            }
            
            // 1. Play completion sound and wait for it to finish
            await withCheckedContinuation { continuation in
                let completionController = voEntity.prepareAudio(completionAudio)
                completionController.completionHandler = {
                    os_log(.debug, "ITR..playSpatialAudio(): Completion sound finished")
                    continuation.resume()
                }
                completionController.play()
                os_log(.debug, "ITR..playSpatialAudio(): Started playing completion sound")
            }
            
            // 2. Play nice job audio and wait for it to finish
            await withCheckedContinuation { continuation in
                let niceJobController = voEntity.prepareAudio(niceJobAudio)
                niceJobController.completionHandler = {
                    os_log(.debug, "ITR..playSpatialAudio(): Nice job audio finished")
                    continuation.resume()
                }
                niceJobController.play()
                os_log(.debug, "ITR..playSpatialAudio(): Started playing nice job audio")
            }
            
            // 3. Play VO 4 with progress
            return await withCheckedContinuation { continuation in
                currentVOController = voEntity.prepareAudio(vo4Audio)
                currentVOController?.completionHandler = {
                    dataModel.voiceOverProgress = 0.0
                    dataModel.isVOPlaying = false
                    dataModel.markVOCompleted(for: step)  // Mark VO as completed
                    continuation.resume()
                }
                currentVOController?.play()
                
                // Start progress timer
                let duration = dataModel.voiceOverDurations[3] ?? 16.0
                Task {
                    let startTime = Date()
                    while dataModel.isVOPlaying {
                        let elapsed = Date().timeIntervalSince(startTime)
                        dataModel.voiceOverProgress = min(elapsed / duration, 1.0)
                        try? await Task.sleep(for: .milliseconds(16)) // ~60fps
                    }
                }
                
                os_log(.debug, "ITR..playSpatialAudio(): Started playing VO 4")
            }
        }
        
        // Get appropriate VO resource for other steps
        let voResource: AudioFileResource? = switch step {
            case 0: vo1Audio
            case 1: vo2Audio
            case 2: vo3Audio
            default: nil
        }
        
        guard let voResource,
              let voEntity = voiceOverAudioEntity else {
            os_log(.error, "ITR..playSpatialAudio(): Missing VO resource or entity for step \(step)")
            throw NSError(domain: "ADCOptimizedImmersive", code: -1, userInfo: [NSLocalizedDescriptionKey: "Missing VO resource or entity"])
        }
        
        // Create and play VO with completion handling
        return await withCheckedContinuation { continuation in
            currentVOController = voEntity.prepareAudio(voResource)
            currentVOController?.completionHandler = {
                dataModel.voiceOverProgress = 0.0
                dataModel.isVOPlaying = false
                dataModel.markVOCompleted(for: step)  // Mark VO as completed
                continuation.resume()
            }
            currentVOController?.play()
            
            // Start progress timer
            let duration = dataModel.voiceOverDurations[step] ?? 18.0
            Task {
                let startTime = Date()
                while dataModel.isVOPlaying {
                    let elapsed = Date().timeIntervalSince(startTime)
                    dataModel.voiceOverProgress = min(elapsed / duration, 1.0)
                    try? await Task.sleep(for: .milliseconds(16)) // ~60fps
                }
            }
            
            os_log(.debug, "ITR..playSpatialAudio(): Started playing VO for step \(step)")
        }
    }

    func playVO1() async {
        os_log(.debug, "ITR..playVO1(): Starting...")
        if let voiceOverAudioEntity {
            os_log(.debug, "ITR..playVO1(): ✅ Found voiceOverAudioEntity")
            if let vo1Audio {
                os_log(.debug, "ITR..playVO1(): ✅ Found vo1Audio")
                let controller = voiceOverAudioEntity.prepareAudio(vo1Audio)
                currentVOController = controller
                if let controller = currentVOController {
                    controller.play()
                    os_log(.debug, "ITR..playVO1(): ✅ Play called successfully")
                } else {
                    os_log(.error, "ITR..playVO1(): ❌ No controller")
                }
            } else {
                os_log(.error, "ITR..playVO1(): ❌ No vo1Audio")
            }
        } else {
            os_log(.error, "ITR..playVO1(): ❌ No voiceOverAudioEntity")
        }
    }

    func playVO2() async {
        os_log(.debug, "ITR..playVO2(): Starting...")
        if let voiceOverAudioEntity {
            os_log(.debug, "ITR..playVO2(): ✅ Found voiceOverAudioEntity")
            if let vo2Audio {
                os_log(.debug, "ITR..playVO2(): ✅ Found vo2Audio")
                let controller = voiceOverAudioEntity.prepareAudio(vo2Audio)
                currentVOController = controller
                if let controller = currentVOController {
                    controller.play()
                    os_log(.debug, "ITR..playVO2(): ✅ Play called successfully")
                } else {
                    os_log(.error, "ITR..playVO2(): ❌ No controller")
                }
            } else {
                os_log(.error, "ITR..playVO2(): ❌ No vo2Audio")
            }
        } else {
            os_log(.error, "ITR..playVO2(): ❌ No voiceOverAudioEntity")
        }
    }

    func playVO3() async {
        os_log(.debug, "ITR..playVO3(): Starting...")
        if let voiceOverAudioEntity {
            os_log(.debug, "ITR..playVO3(): ✅ Found voiceOverAudioEntity")
            if let vo3Audio {
                os_log(.debug, "ITR..playVO3(): ✅ Found vo3Audio")
                let controller = voiceOverAudioEntity.prepareAudio(vo3Audio)
                currentVOController = controller
                if let controller = currentVOController {
                    controller.play()
                    os_log(.debug, "ITR..playVO3(): ✅ Play called successfully")
                } else {
                    os_log(.error, "ITR..playVO3(): ❌ No controller")
                }
            } else {
                os_log(.error, "ITR..playVO3(): ❌ No vo3Audio")
            }
        } else {
            os_log(.error, "ITR..playVO3(): ❌ No voiceOverAudioEntity")
        }
    }

    func playVO4() async {
        os_log(.debug, "ITR..playVO4(): Starting...")
        if let voiceOverAudioEntity {
            os_log(.debug, "ITR..playVO4(): ✅ Found voiceOverAudioEntity")
            if let vo4Audio {
                os_log(.debug, "ITR..playVO4(): ✅ Found vo4Audio")
                let controller = voiceOverAudioEntity.prepareAudio(vo4Audio)
                currentVOController = controller
                if let controller = currentVOController {
                    controller.play()
                    os_log(.debug, "ITR..playVO4(): ✅ Play called successfully")
                } else {
                    os_log(.error, "ITR..playVO4(): ❌ No controller")
                }
            } else {
                os_log(.error, "ITR..playVO4(): ❌ No vo4Audio")
            }
        } else {
            os_log(.error, "ITR..playVO4(): ❌ No voiceOverAudioEntity")
        }
    }
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Entities.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import OSLog


extension ADCOptimizedImmersive {
    func prepareAntibodyEntities() {
        guard let antibodyRoot = antibodyRootEntity else { 
            os_log(.error, "ITR..prepareAntibodyEntities(): ❌ No antibody root entity")
            return 
        }
        
        if let antibody = antibodyRoot.findModelEntity(named: "ADC_complex") {
            self.antibodyEntity = antibody
            antibody.isEnabled = false
            
            // Add to main entity with proper hierarchy
            if let mainEntity = self.mainEntity {
                mainEntity.addChild(antibodyRoot)
                
                // Set initial position with proper transform
                antibodyRoot.position = antibodyRoot.position + antibodyRootOffset
                // Commenting out second transform to avoid double-application
                // antibodyRoot.transform.translation = [antibodyRoot.transform.translation.x,
                //                                    antibodyRoot.transform.translation.y,
                //                                    antibodyRoot.transform.translation.z]
                
                // Add mainViewEntity as child with proper transform
                mainViewEntity.position = mainViewEntity.position //  + antibodyAttachmentOffset
                // Commenting out second transform to avoid double-application
                // mainViewEntity.transform.translation = [mainViewEntity.transform.translation.x,
                //                                      mainViewEntity.transform.translation.y,
                //                                      mainViewEntity.transform.translation.z]
                antibodyRoot.addChild(mainViewEntity)
                
                // Set up gesture component with proper configuration
                let gestureComponent = createGestureComponent()
                antibodyRoot.components.set(gestureComponent)
                
                // Set up audio with proper resource handling
                if let resource = popAudioFileResource {
                    self.popAudioPlaybackController = popAudioEntity?.prepareAudio(resource)
                    os_log(.debug, "ITR..prepareAntibodyEntities(): ✅ Audio prepared successfully")
                }
                
                // Store original material with proper type checking
                if let modelComponent = antibody.components[ModelComponent.self],
                   let originalMaterial = modelComponent.materials.first as? ShaderGraphMaterial {
                    self.originalAntibodyMaterial = originalMaterial
                    os_log(.debug, "ITR..prepareAntibodyEntities(): ✅ Stored original antibody material")
                }
                
                // Apply outline material with proper component handling
                if let material = outlineMaterial,
                   var modelComponent = antibody.components[ModelComponent.self] {
                    modelComponent.materials = [material]
                    antibody.components[ModelComponent.self] = modelComponent
                    os_log(.debug, "ITR..prepareAntibodyEntities(): ✅ Applied outline material")
                    
                    // Add sort component for render order
                    if let sortGroup = adcSortGroup {
                        let sortComponent = ModelSortGroupComponent(group: sortGroup, order: 10)
                        antibody.components.set(sortComponent)
                        os_log(.debug, "ITR..prepareAntibodyEntities(): ✅ Added sort component with order 10")
                    }
                }
            } else {
                os_log(.error, "ITR..prepareAntibodyEntities(): ❌ No main entity to attach to")
            }
        } else {
            os_log(.error, "ITR..prepareAntibodyEntities(): ❌ Could not find ADC_complex entity")
        }
    }
    

    
    func prepareLinkerEntities() async {
        guard let antibodyRoot = antibodyRootEntity else { return }
        
        if let linker0 = antibodyRoot.findModelEntity(named: "linker", from: "linker01_offset"),
           let linker1 = antibodyRoot.findModelEntity(named: "linker", from: "linker02_offset"),
           let linker2 = antibodyRoot.findModelEntity(named: "linker", from: "linker03_offset"),
           let linker3 = antibodyRoot.findModelEntity(named: "linker", from: "linker04_offset") {
            
            self.adcLinkers = [linker0, linker1, linker2, linker3]
            
            // Store original material from first linker
            if let originalMaterial = linker0.components[ModelComponent.self]?.materials.first as? ShaderGraphMaterial {
                self.originalLinkerMaterial = originalMaterial
                os_log(.debug, "ITR..prepareLinkerEntities(): ✅ Stored original ShaderGraphMaterial")
            }
            
            // Apply stored outline material to all linkers
            if let material = outlineMaterial {
                self.adcLinkers.forEach { linker in
                    if var modelComponent = linker.components[ModelComponent.self] {
                        os_log(.debug, "ITR..prepareLinkerEntities(): Applying outline material to linker")
                        modelComponent.materials = [material]
                        linker.components[ModelComponent.self] = modelComponent
                        linker.isEnabled = false
                    }
                    
                    // Add sort component for render order
                    if let sortGroup = adcSortGroup {
                        let sortComponent = ModelSortGroupComponent(group: sortGroup, order: 20)
                        linker.components.set(sortComponent)
                    }
                }
                os_log(.debug, "ITR..prepareLinkerEntities(): ✅ Added sort components to linkers with order 20")
            } else {
                os_log(.error, "ITR..prepareLinkerEntities(): ❌ No outline material available")
            }
        }
    }
    
    func preparePayloadEntities() async {
        guard let antibodyRoot = antibodyRootEntity else {
            os_log(.error, "ITR..preparePayloadEntities(): ❌ No antibody root entity")
            return
        }
        
        // Find all payload entities with proper error handling
        let payloadPairs: [(inner: ModelEntity?, outer: ModelEntity?)] = [
            (antibodyRoot.findModelEntity(named: "InnerSphere", from: "linker01_offset"),
             antibodyRoot.findModelEntity(named: "OuterSphere", from: "linker01_offset")),
            (antibodyRoot.findModelEntity(named: "InnerSphere", from: "linker02_offset"),
             antibodyRoot.findModelEntity(named: "OuterSphere", from: "linker02_offset")),
            (antibodyRoot.findModelEntity(named: "InnerSphere", from: "linker03_offset"),
             antibodyRoot.findModelEntity(named: "OuterSphere", from: "linker03_offset")),
            (antibodyRoot.findModelEntity(named: "InnerSphere", from: "linker04_offset"),
             antibodyRoot.findModelEntity(named: "OuterSphere", from: "linker04_offset"))
        ]
        
        // Process payload pairs with proper component handling
        for (inner, outer) in payloadPairs {
            if let innerPayload = inner, let outerPayload = outer {
                // Set up inner payload
                innerPayload.isEnabled = false
                if var modelComponent = innerPayload.components[ModelComponent.self] {
                    // Store original inner material
                    if let originalMaterial = modelComponent.materials.first as? PhysicallyBasedMaterial {
                        self.originalPayloadInnerMaterial = originalMaterial
                        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Stored original inner PBR material for payload %{public}@", String(describing: innerPayload.name))
                    } else {
                        os_log(.error, "ITR..preparePayloadEntities(): ❌ Failed to get original PBR material for inner payload %{public}@", String(describing: innerPayload.name))
                    }
                    modelComponent.materials = [outlineMaterial].compactMap { $0 }
                    innerPayload.components[ModelComponent.self] = modelComponent
                    
                    // Add sort component for inner payload
                    if let sortGroup = adcSortGroup {
                        let sortComponent = ModelSortGroupComponent(group: sortGroup, order: 30)
                        innerPayload.components.set(sortComponent)
                        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Added sort component to inner payload with order 30")
                    }
                } else {
                    os_log(.error, "ITR..preparePayloadEntities(): ❌ No ModelComponent found for inner payload %{public}@", String(describing: innerPayload.name))
                }
                adcPayloadsInner.append(innerPayload)
                
                // Set up outer payload
                outerPayload.isEnabled = false
                if var modelComponent = outerPayload.components[ModelComponent.self] {
                    // Store original outer material
                    if let originalMaterial = modelComponent.materials.first as? ShaderGraphMaterial {
                        self.originalPayloadOuterMaterial = originalMaterial
                        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Stored original outer shader material for payload %{public}@", String(describing: outerPayload.name))
                        
                        // Log available parameters for debugging
                        let parameters = originalMaterial.parameterNames
                        os_log(.debug, "ITR..preparePayloadEntities(): 📝 Available shader parameters for %{public}@: %{public}@", String(describing: outerPayload.name), parameters.joined(separator: ", "))
                    } else {
                        os_log(.error, "ITR..preparePayloadEntities(): ❌ Failed to get original shader material for outer payload %{public}@", String(describing: outerPayload.name))
                    }
                    modelComponent.materials = [outlineMaterial].compactMap { $0 }
                    outerPayload.components[ModelComponent.self] = modelComponent
                    
                    // Add sort component for outer payload
                    if let sortGroup = adcSortGroup {
                        let sortComponent = ModelSortGroupComponent(group: sortGroup, order: 40)
                        outerPayload.components.set(sortComponent)
                        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Added sort component to outer payload with order 40")
                    }
                } else {
                    os_log(.error, "ITR..preparePayloadEntities(): ❌ No ModelComponent found for outer payload %{public}@", String(describing: outerPayload.name))
                }
                adcPayloadsOuter.append(outerPayload)
                
                // Ensure proper transform binding
                innerPayload.transform = Transform(scale: .one,
                                                rotation: .init(),
                                                translation: innerPayload.position)
                outerPayload.transform = Transform(scale: .one,
                                                rotation: .init(),
                                                translation: outerPayload.position)
            } else {
                os_log(.error, "ITR..preparePayloadEntities(): ❌ Failed to find payload pair")
            }
        }
        
        os_log(.debug, "ITR..preparePayloadEntities(): ✅ Found \(adcPayloadsInner.count) inner payloads and \(adcPayloadsOuter.count) outer payloads")
    }
    
    func prepareTargetEntities(antibodyScene: Entity) {
        guard adcLinkers.count > 0 else {
            os_log(.error, "ITR..prepareTargetEntities(): ❌ Error, self.adcLinkers is empty. It should have content at this point.")
            return
        }

        guard !adcPayloadsInner.isEmpty else {
            os_log(.error, "ITR..prepareTargetEntities(): ❌ Error, self.adcPayloadsInner is empty. It should have content at this point.")
            return
        }

        if let linker = antibodyScene.findEntity(named: "targetLinker"),
           let payload = antibodyScene.findEntity(named: "targetPayload"),
           let workingLinker = linker.findModelEntity(named: "linker"),
           let workingPayloadInner = payload.findModelEntity(named: "InnerSphere"),
           let workingPayloadOuter = payload.findModelEntity(named: "OuterSphere") {
            
            // Attach audio to target entities
            attachPopSoundToTarget(linker)
            attachPopSoundToTarget(payload)
            
            linkerEntity = linker
            antibodyRootEntity?.addChild(linker)
            linker.position = linker.position + linkerAttachmentOffset
            initialLinkerPosition = linker.position  // Save initial position
            
            linker.isEnabled = false
            linker.components.set(createLinkerGestureComponent(linkerEntity: linker, linkerTarget: adcLinkers[dataModel.linkersWorkingIndex]))
            workingLinker.components.set(ADCProximityComponent(minScale: 0.3, maxScale: 1.0, minProximity: 0.1, maxProximity: 0.5))
            
            payloadEntity = payload
            payload.isEnabled = false
            payload.components.set(createPayloadGestureComponent(payloadEntity: payload, payloadTarget: adcPayloadsInner[dataModel.payloadsWorkingIndex]))
            
            antibodyRootEntity?.addChild(payload)
            payload.position = payload.position + payloadAttachmentOffset
            initialPayloadPosition = payload.position  // Save initial position
            
            // Apply outline material to draggable linker
            if let material = outlineMaterial {
                if var modelComponent = workingLinker.components[ModelComponent.self] {
                    modelComponent.materials = [material]
                    workingLinker.components[ModelComponent.self] = modelComponent
                    os_log(.debug, "ITR..prepareTargetEntities(): ✅ Applied outline material to draggable linker")
                }
                
                // Apply to both inner and outer payload
                if var innerComponent = workingPayloadInner.components[ModelComponent.self],
                   var outerComponent = workingPayloadOuter.components[ModelComponent.self] {
                    innerComponent.materials = [material]
                    outerComponent.materials = [material]
                    workingPayloadInner.components[ModelComponent.self] = innerComponent
                    workingPayloadOuter.components[ModelComponent.self] = outerComponent
                    os_log(.debug, "ITR..prepareTargetEntities(): ✅ Applied outline material to draggable payload")
                }
            }
            
            // Add sort components for draggable payloads
            if let sortGroup = adcSortGroup {
                let innerSortComponent = ModelSortGroupComponent(group: sortGroup, order: 50)
                workingPayloadInner.components.set(innerSortComponent)
                
                let outerSortComponent = ModelSortGroupComponent(group: sortGroup, order: 60)
                workingPayloadOuter.components.set(outerSortComponent)
                os_log(.debug, "ITR..prepareTargetEntities(): ✅ Added sort components to draggable payloads (inner: 50, outer: 60)")
            }
            
            // Rest stays the same...
            self.workingLinker = workingLinker
            self.workingPayloadInner = workingPayloadInner
            self.workingPayloadOuter = workingPayloadOuter
            workingPayloadOuter.components.set(ADCProximityComponent(minScale: 2.0, maxScale: 15.0, minProximity: 0.15, maxProximity: 0.6))
            workingPayloadInner.components.set(ADCProximityComponent(minScale: 2.0, maxScale: 15.0, minProximity: 0.15, maxProximity: 0.6))
        }
    }
    
    func cleanup() {
        os_log(.debug, "ITR..reset() called")
        
        // Reset dataModel state
        dataModel.selectedADCAntibody = nil
        dataModel.selectedADCLinker = nil
        dataModel.selectedADCPayload = nil
        dataModel.selectedLinkerType = nil
        dataModel.selectedPayloadType = nil
        dataModel.linkersWorkingIndex = 0
        dataModel.payloadsWorkingIndex = 0
        dataModel.placedLinkerCount = 0
        dataModel.placedPayloadCount = 0
        
        // Reset audio
        currentVOController?.stop()
        currentVOController = nil
        popAudioPlaybackController?.stop()
        popAudioPlaybackController = nil
//        audioStorage?.cleanup()
        
        // Reset entities
        mainEntity?.removeFromParent()
        mainViewEntity.removeFromParent()
        antibodyRootEntity?.removeFromParent()
        
        // Remove all components before removing entities
        antibodyEntity?.components.remove(ModelComponent.self)
        antibodyEntity?.components.remove(CollisionComponent.self)
        antibodyEntity?.components.remove(InputTargetComponent.self)
        
        // Clear all entities
        mainEntity = nil
        mainViewEntity = Entity()
        antibodyRootEntity = nil
        antibodyEntity = nil
        linkerEntity = nil
        payloadEntity = nil
        
        // Clear working entities
        workingLinker = nil
        workingPayloadInner = nil
        workingPayloadOuter = nil
        
        // Clear arrays
        adcLinkers.removeAll(keepingCapacity: false)
        adcPayloadsInner.removeAll(keepingCapacity: false)
        adcPayloadsOuter.removeAll(keepingCapacity: false)
        
        // Clear attachments
        adcAttachmentEntity = nil
        linkerAttachmentEntity = nil
        payloadAttachmentEntity = nil
        
        // Reset flags
        shouldAddADCAttachment = false
        shouldAddLinkerAttachment = false
        shouldAddPayloadAttachment = false
        shouldAddMainViewAttachment = false
        refreshFlag = false
        bubblePopSound = false
        
        // Reset audio resources
        popAudioFileResource = nil
        vo1Audio = nil
        vo2Audio = nil
        vo3Audio = nil
        vo4Audio = nil
        
        // Ensure cleanup happens on main actor
        Task { @MainActor in
            await Task.yield()
            // Release any strong references
            originalAntibodyMaterial = nil
            originalPayloadInnerMaterial = nil
            originalPayloadOuterMaterial = nil
            outlineMaterial = nil
        }
    }
}

```

File: ADC/Views/ADCBuilder/ADCOptimizedImmersive/ADCOptimizedImmersive+Gestures.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import OSLog


extension ADCOptimizedImmersive {
    // MARK: - Gestures
    
    func createGestureComponent() -> ADCGestureComponent {
        var gestureComponent = ADCGestureComponent(canDrag: true,
                                                      pivotOnDrag: false,
                                                      canScale: false,
                                                      canRotate: true)
        gestureComponent.onDragStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddMainViewAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onDragEnded = { entity in
            shouldAddADCAttachment = true
            shouldAddMainViewAttachment = true
            shouldAddLinkerAttachment = true
            shouldAddPayloadAttachment = true
        }
        gestureComponent.onRotateStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddMainViewAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onRotateEnded = { entity in
            shouldAddADCAttachment = true
            shouldAddMainViewAttachment = true
            shouldAddLinkerAttachment = true
            shouldAddPayloadAttachment = true
        }
        return gestureComponent
    }
    
    func createLinkerGestureComponent(linkerEntity: Entity, linkerTarget: Entity) -> ADCGestureComponent {
        var gestureComponent = ADCGestureComponent(canDrag: true,
                                                pivotOnDrag: false,
                                                canScale: false,
                                                canRotate: false)
        gestureComponent.onDragStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onDragEnded = { entity in
            if let finishedEntity = entity {
//                os_log(.debug, "ITR..createLinkerGestureComponent(): Drag ended on entity \(finishedEntity.name)")
                shouldAddADCAttachment = true
                shouldAddLinkerAttachment = true
                shouldAddPayloadAttachment = true
                
                let currentPosition = finishedEntity.position(relativeTo: nil)
                let targetPosition = linkerTarget.position(relativeTo: nil)
                let dist = distance(currentPosition, targetPosition)
                
//                os_log(.debug, "ITR..createLinkerGestureComponent(): LinkerEntity Position: \(currentPosition), \n     LinkerTargetPosition: \(targetPosition),    Distance: \(dist)")
                if dist < 0.2 {
                    os_log(.debug, "ITR..createLinkerGestureComponent(): Entity \(finishedEntity.name) is close enough to the target linker, dataModel.linkersWorkingIndex: \(dataModel.linkersWorkingIndex)")
                    // Set default color to 0 if none selected
                    if dataModel.selectedLinkerType == nil {
                        dataModel.selectedLinkerType = 0
                    }
                    dataModel.selectedADCLinker = dataModel.selectedLinkerType
                    dataModel.placedLinkerCount += 1
                    Task { @MainActor in
                        attachPopSoundToTarget(finishedEntity)
                        playPopSound()
                    }
                    
                    Task { @MainActor in
                        // Only apply color if one has been chosen
                        if let selectedType = dataModel.selectedLinkerType {
                            // Update all previously placed linkers
                            for index in 0..<dataModel.linkersWorkingIndex {
                                if let originalMaterial = originalLinkerMaterial {
                                    if var modelComponent = adcLinkers[index].components[ModelComponent.self] {
                                        modelComponent.materials = [originalMaterial]
                                        adcLinkers[index].components[ModelComponent.self] = modelComponent
                                    }
                                }
                                adcLinkers[index].updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[selectedType])
                            }
                            
                            // Update current linker
                            if let originalMaterial = originalLinkerMaterial {
                                adcLinkers[dataModel.linkersWorkingIndex].updateMaterials { material in
                                    material = originalMaterial
                                }
                            }
                            adcLinkers[dataModel.linkersWorkingIndex].updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[selectedType])
                        }
                        
                        // If there's a next linker, give it the outline material
                        if dataModel.linkersWorkingIndex < (adcLinkers.count - 1) {
                            if let material = outlineMaterial {
                                adcLinkers[dataModel.linkersWorkingIndex + 1].model?.materials = [material]
                            }
                        }
                        
                        adcLinkers.forEach {
                            $0.components.remove(ADCProximitySourceComponent.self)
                        }
                        
                        let isFinalLinker = dataModel.linkersWorkingIndex >= (adcLinkers.count - 1)
                        if isFinalLinker {
                            await handleFinalEntityPlacement(
                                entityType: .linker,
                                workingEntity: linkerEntity,
                                savedPosition: initialLinkerPosition,
                                nextStep: 2
                            )
                        } else {
                            if let linkerEntity = self.linkerEntity,
                               let savedPosition = initialLinkerPosition {
                                linkerEntity.position = savedPosition  // Restore to original position
                            }

                            dataModel.linkersWorkingIndex += 1

                            for (index, element) in adcLinkers.enumerated() {
                                element.isEnabled = index <= dataModel.linkersWorkingIndex
                            }
                            
                            adcLinkers[dataModel.linkersWorkingIndex].components.set(ADCProximitySourceComponent())

                        }
                        updateADC()
                    }
                } else {
//                    os_log(.debug, "ITR..createLinkerGestureComponent(): Entity \(finishedEntity.name) distance: \(dist)")
                }
            }
        }
        gestureComponent.onRotateStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onRotateEnded = { entity in
            shouldAddADCAttachment = true
            shouldAddLinkerAttachment = true
            shouldAddPayloadAttachment = true
        }
        return gestureComponent
    }
    
    /// Handles the final placement of an entity (linker or payload)
    /// - Parameters:
    ///   - entityType: Type of entity being placed
    ///   - workingEntity: The current working entity to reset
    ///   - savedPosition: Original position to reset to
    ///   - nextStep: Step to advance to when complete
    func handleFinalEntityPlacement(entityType: ADCEntityType,
                                  workingEntity: Entity?,
                                  savedPosition: SIMD3<Float>?,
                                  nextStep: Int) async {
        // Play pop sound while entity is still in final position
        if let workingEntity = workingEntity {
            attachPopSoundToTarget(workingEntity)
            playPopSound()
            workingEntity.opacity = 0
        }
        // Removed auto advancement logic.
        // The user must press the checkmark button to advance to the next step.
    }
    
    func createPayloadGestureComponent(payloadEntity: Entity, payloadTarget: Entity) -> ADCGestureComponent {
        var gestureComponent = ADCGestureComponent(canDrag: true,
                                                pivotOnDrag: false,
                                                canScale: false,
                                                canRotate: false)
        gestureComponent.onDragStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onDragEnded = { entity in
            if let finishedEntity = entity {
//                os_log(.debug, "ITR..createPayloadGestureComponent(): Drag ended on entity \(finishedEntity.name)")
                shouldAddADCAttachment = true
                shouldAddLinkerAttachment = true
                shouldAddPayloadAttachment = true
                
                //TODO: check if entity is close enough to the target linker, if so then remove the working linker and set the selected Linker
                let currentPosition = finishedEntity.position(relativeTo: nil)
                let targetPosition = payloadTarget.position(relativeTo: nil)
                let dist = distance(currentPosition, targetPosition)
                
//                os_log(.debug, "ITR..createPayloadGestureComponent(): PayloadEntity Position: \(currentPosition), \n     PayloadTargetPosition: \(targetPosition),    Distance: \(dist)")
                if dist < 0.2 {
                    os_log(.debug, "ITR..createPayloadGestureComponent(): Entity \(finishedEntity.name) is close enough to the target payload, dataModel.payloadsWorkingIndex: \(dataModel.payloadsWorkingIndex)")
                    // Set default color to 0 if none selected
                    if dataModel.selectedPayloadType == nil {
                        dataModel.selectedPayloadType = 0
                    }
                    dataModel.selectedADCPayload = dataModel.selectedPayloadType
                    Task { @MainActor in
                        attachPopSoundToTarget(finishedEntity)
                        playPopSound()
                    }
                    dataModel.placedPayloadCount += 1
                    
                    Task { @MainActor in
                        // Only apply color if one has been chosen
                        if let selectedType = dataModel.selectedPayloadType {
                            // Update all previously placed payloads
                            for index in 0..<dataModel.payloadsWorkingIndex {
                                // Inner sphere
                                if let originalInnerMaterial = originalPayloadInnerMaterial {
                                    if var modelComponent = adcPayloadsInner[index].components[ModelComponent.self] {
                                        modelComponent.materials = [originalInnerMaterial]
                                        adcPayloadsInner[index].components[ModelComponent.self] = modelComponent
                                    }
                                }
                                adcPayloadsInner[index].updatePBREmissiveColor(.adcEmissive[selectedType])
                                
                                // Outer sphere
                                if let originalOuterMaterial = originalPayloadOuterMaterial {
                                    if var modelComponent = adcPayloadsOuter[index].components[ModelComponent.self] {
                                        modelComponent.materials = [originalOuterMaterial]
                                        adcPayloadsOuter[index].components[ModelComponent.self] = modelComponent
                                    }
                                }
                                adcPayloadsOuter[index].updateShaderGraphColor(parameterName: "glowColor", color: .adc[selectedType])
                            }
                            
                            // Update current payload
                            if let originalInnerMaterial = originalPayloadInnerMaterial {
                                adcPayloadsInner[dataModel.payloadsWorkingIndex].updateMaterials { material in
                                    material = originalInnerMaterial
                                }
                            }
                            if let originalOuterMaterial = originalPayloadOuterMaterial {
                                adcPayloadsOuter[dataModel.payloadsWorkingIndex].updateMaterials { material in
                                    material = originalOuterMaterial
                                }
                            }
                            adcPayloadsInner[dataModel.payloadsWorkingIndex].updatePBREmissiveColor(.adcEmissive[selectedType])
                            adcPayloadsOuter[dataModel.payloadsWorkingIndex].updateShaderGraphColor(parameterName: "glowColor", color: .adc[selectedType])
                        }
                        
                        // If there's a next payload, give it the outline material
                        let nextIndex = dataModel.payloadsWorkingIndex + 1
                        if nextIndex < adcPayloadsInner.count && nextIndex < adcPayloadsOuter.count {
                            if let material = outlineMaterial {
                                adcPayloadsInner[nextIndex].model?.materials = [material]
                                adcPayloadsOuter[nextIndex].model?.materials = [material]
                            }
                        }
                        
                        adcPayloadsOuter.forEach {
                            $0.components.remove(ADCProximitySourceComponent.self)
                        }
                        
                        let isFinalPayload = dataModel.payloadsWorkingIndex >= (adcPayloadsInner.count - 1)
                        if isFinalPayload {
                            await handleFinalEntityPlacement(
                                entityType: .payload,
                                workingEntity: payloadEntity,
                                savedPosition: initialPayloadPosition,
                                nextStep: 3
                            )
                        } else {
                            if let payloadEntity = self.payloadEntity,
                               let savedPosition = initialPayloadPosition {
                                payloadEntity.position = savedPosition  // Restore to original position
                            }
                            
                            dataModel.payloadsWorkingIndex += 1
                            
                            for (index, element) in adcPayloadsInner.enumerated() {
                                element.isEnabled = index <= dataModel.payloadsWorkingIndex
                            }
                            for (index, element) in adcPayloadsOuter.enumerated() {
                                element.isEnabled = index <= dataModel.payloadsWorkingIndex
                            }
                            
                            adcPayloadsOuter[dataModel.payloadsWorkingIndex].components.set(ADCProximitySourceComponent())
                        }
                        updateADC()
                    }
                } else {
//                    os_log(.debug, "ITR..createPayloadGestureComponent(): Entity \(finishedEntity.name) distance: \(dist)")
                }
            }
        }
        gestureComponent.onRotateStarted = { entity in
            shouldAddADCAttachment = false
            shouldAddLinkerAttachment = false
            shouldAddPayloadAttachment = false
        }
        gestureComponent.onRotateEnded = { entity in
            shouldAddADCAttachment = true
            shouldAddLinkerAttachment = true
            shouldAddPayloadAttachment = true
        }
        return gestureComponent
    }
}

```

File: ADC/Views/ADCBuilder/ADCBuilderView.swift
```swift
import SwiftUI
import OSLog

struct ADCBuilderView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel
    @Environment(\.openWindow) private var openWindow
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
    
    @FocusState private var isFocused: Bool


    let titles = ["Antibodies", "Linker", "Payload", "ADC Ready"]
    
    let descriptions = [
        "First, the journey begins with creating monoclonal antibodies in cell cultures. These antibodies are like precision-guided missiles designed to seek out and bind to cancer cells. They are the key to ensuring that the treatment targets only the cancer cells, leaving healthy cells unharmed.",
        "Next, a special chemical linker is attached to the antibodies. This linker acts as a smart bridge, ensuring that the powerful cancer-fighting drug is only released when the antibody reaches the cancer cell. This step is crucial for delivering the treatment directly to the cancer cells, minimizing side effects.",
        "Finally, the cytotoxic drug, which is designed to kill cancer cells, is chemically linked to the antibodies through a process called conjugation. This creates the antibody-drug conjugate (ADC). The ADC is then purified and rigorously tested to ensure it is effective and safe. Once it passes all tests, it is formulated, sterilized, and packaged into vials or syringes.",
        "When administered to patients, the ADC travels through the bloodstream, finds the cancer cells, and releases the drug to destroy them. This targeted approach helps to outdo cancer by attacking it directly while sparing healthy cells."
    ]
    
    var body: some View {
        VStack(spacing: 0) {
            // Header with logo and title
            ZStack {
                HStack {
                        Image("Pfizer_Logo_White_RGB")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 100)
                        Spacer()
                    }
                    
                    // The title/text area
                    switch dataModel.adcBuildStep {
                        case 0:
                            Text("Antibody")
                                .font(.largeTitle)
                                .transition(.opacity)
                        case 1:
                            // In step 1, only the "+ Linker" part glows.
                            HStack(spacing: 0) {
                                Text("Antibody ")
                                    .font(.largeTitle)
                                Text("+ Linker")
                                    .font(.largeTitle)
                                    .glowing(if: true, color: Color("LightGreen800")) // Always glowing in step 1.
                                    .transition(.opacity)
                            }
                        case 2:
                            // In step 2, only the "+ Payload" part glows.
                            HStack(spacing: 0) {
                                Text("Antibody + Linker ")
                                    .font(.largeTitle)
                                Text("+ Payload")
                                    .font(.largeTitle)
                                    .glowing(if: true, color: Color("LightGreen800")) // Always glowing in step 2.
                                    .transition(.opacity)
                            }
                        default:
                            Text("Your ADC is ready")
                                .font(.largeTitle)
                                .transition(.opacity)
                        }
                    
            }
            .padding(30)
            .background(.black.opacity(0.4))
            .frame(width: 800)

            // Description text and progress
            VStack(spacing: 0) {
                HStack {
                    Text(descriptions[dataModel.adcBuildStep])
                        .font(.title3)
                        .multilineTextAlignment(appModel.immersiveSpaceState == .closed ? .center : .leading)
                        .fixedSize(horizontal: false, vertical: true)
                }
                .frame(width: 600)
                .padding(.horizontal, 30)
                .padding(.top, 30)
                .padding(.bottom, 12)
                
                if dataModel.isVOPlaying {
                    VOProgressBar(progress: dataModel.voiceOverProgress)
                        .frame(width: 600)
                        .padding(.horizontal, 30)
                        .padding(.vertical, 8)
                }
            }
            .padding(.bottom, !dataModel.isVOPlaying ? 30 : 20)
            

                
            
            // Selector views or navigation button
            if !dataModel.isVOPlaying { // && dataModel.hasInitialVOCompleted
                        switch dataModel.adcBuildStep {
                        case 0:
                                ADCSelectorView()
                                    .opacity(dataModel.hasInitialVOCompleted ? 1 : 0)
                                    .opacity(dataModel.adcBuildStep == 0 ? 1 : 0)
                                    .allowsHitTesting(dataModel.adcBuildStep == 0 ? true : false)
                                    .transition(Appear())
                        case 1:
                            ADCLinkerSelectorView()
                                    .opacity(dataModel.adcBuildStep == 1 ? 1 : 0)
                                    .allowsHitTesting(dataModel.adcBuildStep == 1 ? true : false)
                                    .transition(Appear())
                        case 2:
                            ADCPayloadSelectorView()
                                    .opacity(dataModel.adcBuildStep == 2 ? 1 : 0)
                                    .allowsHitTesting(dataModel.adcBuildStep == 2 ? true : false)
                                    .transition(Appear())
                        default:
                            EmptyView()
                        }
                    }

            // Updated navigation chevrons
             if dataModel.adcBuildStep > 0 || dataModel.adcBuildStep < 3 {
                 HStack {
                     // Back Chevron
                     if dataModel.adcBuildStep > 0 && dataModel.adcBuildStep < 3 {
                         Button(action: {
                             withAnimation {
                                 // Back navigation is always manual (no VO)
                                 dataModel.manualStepTransition = true
                                 dataModel.adcBuildStep -= 1
                             }
                         }) {
                             Image(systemName: "chevron.left")
                                 .font(.largeTitle)
                                 .foregroundColor(.white)
                                 .hoverEffect { effect, isActive, proxy in
                                     effect.scaleEffect(!isActive ? 1.0 : AppModel.UIConstants.buttonExpandScale)
                                 }
                         }
                         .glassBackgroundEffect()
                         .opacity(dataModel.canMoveBack ? 1.0 : 0.1)
                         .disabled(!dataModel.canMoveBack)
                     }
                    
                     Spacer()
                    
                     // Forward Chevron
                     if dataModel.adcBuildStep < 3 && !dataModel.isVOPlaying {
                         Button(action: {
                             withAnimation {
                                 let nextStep = dataModel.adcBuildStep + 1
                                 
                                 // If this step is complete and next step's VO hasn't been played,
                                 // do a natural transition (will play VO)
                                 if dataModel.stepStates[dataModel.adcBuildStep].checkmarkClicked {
                                     if !dataModel.stepStates[nextStep].voPlayed {
                                         dataModel.manualStepTransition = false
                                     } else {
                                         // VO has been played, do manual transition
                                         dataModel.manualStepTransition = true
                                     }
                                     dataModel.adcBuildStep += 1
                                 }
                             }
                         }) {
                             Image(systemName: "chevron.right")
                                 .font(.largeTitle)
                                 .foregroundColor(.white)
                                 .hoverEffect { effect, isActive, proxy in
                                     effect.scaleEffect(!isActive ? 1.0 : AppModel.UIConstants.buttonExpandScale)
                                 }
                         }
                         .glassBackgroundEffect()
                         .opacity(dataModel.canMoveForward ? 1.0 : 0.1)
                         .disabled(!dataModel.canMoveForward)
                     }
                 }
                 .padding(20)
                 .zIndex(0)
             }
            
            if !dataModel.isVOPlaying && dataModel.adcBuildStep == 3 {
                NavigationButton(
                    title: "Attack Cancer",
                    action: {
                        Task {
                            // Log final color summary before attack
                            os_log(.debug, "ADC Final Color Summary (Attack Button Pressed):")
                            os_log(.debug, "- Antibody Color: \(dataModel.selectedADCAntibody ?? -1)")
                            os_log(.debug, "- Linker Color: \(dataModel.selectedLinkerType ?? -1)")
                            os_log(.debug, "- Payload Color: \(dataModel.selectedPayloadType ?? -1)")
                            
                            appModel.hasBuiltADC = true
                            
                            if !appModel.isMainWindowOpen {
                                openWindow(id: AppModel.mainWindowId)
                                appModel.isMainWindowOpen = true
                                appModel.isInstructionsWindowOpen = true
                            }
                            await dismissImmersiveSpace()
                            await appModel.transitionToPhase(.playing, adcDataModel: dataModel)
                        }
                    },
                    font: .title,
                    scaleEffect: AppModel.UIConstants.buttonExpandScale,
                    width: 250
                )
                .fontWeight(.bold)
                // .padding(.top, 10)
                .padding(.bottom, 30)
                .contentShape(Capsule())
                .zIndex(1)
                .opacity(dataModel.adcBuildStep == 3 ? 1 : 0)
            }
        }
        .frame(width: 800)
        .frame(alignment: .top) // height: dataModel.isVOPlaying ? 350 : 700,
        .glassBackgroundEffect() // must have this for the background glass and rounded corners
        .animation(.spring(response: 0.5, dampingFraction: 0.7), value: dataModel.isVOPlaying)
    }
}

import SwiftUI

struct GlowingModifier: ViewModifier {
    /// When true, the glow effect is active.
    var isGlowing: Bool
    /// The glow color.
    var color: Color = .blue
    /// The base blur radius for the glow.
    var baseBlur: CGFloat = 20
    /// How much extra blur to add when the effect is at its peak.
    var blurVariation: CGFloat = 10
    /// How much blur to apply to the glowing copy.
    var glowBlur: CGFloat = 20
    /// How much to scale the glowing copy to emphasize the effect.
    var glowScale: CGFloat = 1.2
    /// The base opacity for the glow.
    var baseOpacity: Double = 0.0
    /// Additional opacity added at the peak of the pulsation.
    var opacityVariation: Double = 1.0
    /// The opacity (intensity) of the glow.
    var glowIntensity: Double = 1.0

    @State private var pulsate = false

    func body(content: Content) -> some View {
        ZStack {
            if isGlowing {
                // The glow copy behind the text.
                content
                    .foregroundColor(color)
//                    .scaleEffect(pulsate ? glowScale : 1.0)
//                    .blur(radius: pulsate ? baseBlur + blurVariation : baseBlur)
                    .blur(radius: glowBlur)
                    // Animate the opacity.
                    .opacity(pulsate ? baseOpacity + opacityVariation : baseOpacity)
                    // Use an additive blend so the glow intensifies without obscuring the text.
                    .blendMode(.plusLighter)
                    .animation(Animation.easeInOut(duration: 1).repeatForever(autoreverses: true), value: pulsate)
                content
                    .foregroundColor(color)
//                    .scaleEffect(pulsate ? glowScale : 1.0)
//                    .blur(radius: pulsate ? baseBlur + blurVariation : baseBlur)
                    .blur(radius: glowBlur * 0.5)
                    // Animate the opacity.
                    .opacity(pulsate ? baseOpacity + opacityVariation : baseOpacity)
                    // Use an additive blend so the glow intensifies without obscuring the text.
                    .blendMode(.plusLighter)
                    .animation(Animation.easeInOut(duration: 1).repeatForever(autoreverses: true), value: pulsate)
                content
                    .foregroundColor(color)
//                    .scaleEffect(pulsate ? glowScale : 1.0)
//                    .blur(radius: pulsate ? baseBlur + blurVariation : baseBlur)
                    .blur(radius: glowBlur).blur(radius: glowBlur * 0.1)
                    // Animate the opacity.
                    .opacity(pulsate ? baseOpacity + opacityVariation : baseOpacity)
                    // Use an additive blend so the glow intensifies without obscuring the text.
                    .blendMode(.plusLighter)
                    .animation(Animation.easeInOut(duration: 1).repeatForever(autoreverses: true), value: pulsate)
            }
            // The original content on top.
            content
        }
        .onAppear {
            if isGlowing {
                pulsate = true
            }
        }
    }
}

extension View {
    /// Applies a glowing effect if the condition is true.
    func glowing(if condition: Bool, color: Color = .blue, glowBlur: CGFloat = 20, glowScale: CGFloat = 1.2, glowIntensity: Double = 1.0) -> some View {
        self.modifier(GlowingModifier(isGlowing: condition, color: color, glowBlur: glowBlur, glowScale: glowScale, glowIntensity: glowIntensity))
    }
}

extension View {
    /// A convenient helper to apply the glow effect conditionally.
    func glowing(if condition: Bool, color: Color = .blue) -> some View {
        self.modifier(GlowingModifier(isGlowing: condition, color: color))
    }
}

// MARK: - VOProgressBar
struct VOProgressBar: View {
    let progress: Double
    
    var body: some View {
        ProgressView(value: progress)
            .progressViewStyle(.linear)
            .tint(
                LinearGradient(
                    colors: [
                        Color("gradient600"),
                        Color("gradient200")
                    ],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .frame(height: 2)
    }
}

```

File: ADC/Views/ADCBuilder/ADCButtonSquareWithOutline.swift
```swift
import SwiftUI

struct ADCButtonSquareWithOutline: View {
    @Environment(AppModel.self) var appModel
    @Environment(ADCDataModel.self) var dataModel
    
    let imageName: String
    let outlineColor: Color
    let description: String
    let index: Int
    let isSelected: () -> Bool
    let action: () -> Void
    let buttonSize: CGFloat = 110.0
    let cornerRadius: CGFloat = 12.0
    
    
    var body: some View {
        VStack (alignment: .center) {
            Button {
                action()
            } label: {
               Image(imageName)
                   .resizable()
                   .aspectRatio(contentMode: .fit)
                   .frame(width: buttonSize, height: buttonSize)
                   .clipShape(RoundedRectangle(cornerRadius: cornerRadius))
                   .overlay {
                       RoundedRectangle(cornerRadius: cornerRadius)
                           .stroke(isSelected() ? Color.white : Color.clear, lineWidth: 4)
                   }
           }
           .frame(width: buttonSize, height: buttonSize)
           .buttonBorderShape(ButtonBorderShape.roundedRectangle(radius: cornerRadius))
            
            Text(description)
                .multilineTextAlignment(.center)
                .font(.system(size: 10))
                .padding(.horizontal,2)
                .padding(.top, 2)
                .frame(maxWidth: buttonSize)
        }
    }
    
}


```

File: ADC/Views/ADCBuilder/ADCCheckmarkButton.swift
```swift
import SwiftUI

struct ADCCheckmarkButton: View {
    let action: () -> Void
    let isEnabled: Bool

    // State variable to drive the pulsing scale effect
    @State private var pulseScale: CGFloat = 1.0

    var body: some View {
        Button(action: action) {
            ZStack {
                // Circle that changes appearance based on isEnabled
                Image(systemName: "circle")
                    .font(.system(size: 60))
                    .symbolVariant(isEnabled ? .fill : .none)
                    .foregroundStyle(isEnabled ? .green : .white.opacity(0.3))
                    .animation(.easeInOut(duration: 0.3), value: isEnabled)
                
                // Checkmark that appears when enabled, with a pulsing scale effect
                Image(systemName: "checkmark")
                    .font(.system(size: 30))
                    .bold()
                    .foregroundStyle(.white)
                    .opacity(isEnabled ? 1 : 0.3)
                    // .scaleEffect(isEnabled ? pulseScale : 0.9)
                    // We handle pulsing via pulseScale, so no extra animation modifier here.
            }
            // .hoverEffect { effect, isActive, _ in
            //     effect.scaleEffect(isActive ? 1.15 : 1.0)
            // }
            .scaleEffect(isEnabled ? pulseScale : 0.9)
        }
        .frame(width: 60, height: 60)
        .contentShape(Rectangle())
        .disabled(!isEnabled)
        .onAppear {
            // Start pulsing if enabled on appear.
            if isEnabled {
                startPulsing()
            }
        }
        .onChange(of: isEnabled) { _, newValue in
            // When isEnabled changes, start or stop pulsing accordingly.
            if newValue {
                startPulsing()
            } else {
                // Reset to the non-animated scale when disabled.
                pulseScale = 0.9
            }
        }
    }
    
    private func startPulsing() {
        // Reset pulseScale to the base value.
        pulseScale = 1.0
        // Animate pulseScale to 1.1 with a repeating animation.
        withAnimation(Animation.easeInOut(duration: 0.8).repeatForever(autoreverses: true)) {
            pulseScale = 1.1
        }
    }
}

//struct ADCCheckmarkButton_Previews: PreviewProvider {
//    static var previews: some View {
//        // Toggle isEnabled to see the pulsing effect in action.
//        VStack(spacing: 40) {
//            ADCCheckmarkButton(action: { print("Tapped!") }, isEnabled: true)
//            ADCCheckmarkButton(action: { print("Tapped!") }, isEnabled: false)
//        }
//        .padding()
//        .background(Color.gray.opacity(0.2))
//    }
//}

```

File: ADC/Views/ADCBuilder/ADCLinkerSelectorView.swift
```swift
import SwiftUI

struct ADCLinkerSelectorView: View {
    @Environment(AppModel.self) var appModel
    @Environment(ADCDataModel.self) var dataModel
    
    var noButton: Bool = true
    
    var body: some View {
        VStack (spacing:30) {
            HStack(spacing: 10) {
                Text("Select Linker color and place Linker")
                    .font(.title)
                    .frame(maxWidth: .infinity, alignment: .leading)
                if dataModel.placedLinkerCount > 0 {
                    Text("\(dataModel.placedLinkerCount) of 4")
                        .font(.title2)
                        .foregroundColor(.gray)
                        .frame(alignment: .trailing)
                }
                
                
                ADCCheckmarkButton(
                    action: {
                        // Update step state and advance
                        dataModel.stepStates[1].checkmarkClicked = true
                        dataModel.adcBuildStep = 2
                    },
                    isEnabled: dataModel.selectedLinkerType != nil && dataModel.placedLinkerCount == 4
                )
                // .disabled(noButton)
                
                
            }
            .padding(.vertical, 30)
            .padding(.horizontal, 30)
            .background(.black.opacity(0.4))
            HStack (alignment: .top, spacing: 20){
                    ADCButtonSquareWithOutline(imageName: "linkers0",
                                            outlineColor: Color.white,
                                            description: "",
                                            index: 0,
                                            isSelected: {
                        dataModel.selectedLinkerType == 0
                    }) {
                        print("ITR..Button 0 pressed")
                        dataModel.selectedLinkerType = 0
                        dataModel.stepStates[1].colorSelected = true
                    }
                    ADCButtonSquareWithOutline(imageName: "linkers1",
                                            outlineColor: Color.white,
                                            description: "",
                                            index: 1,
                                            isSelected: {
                        dataModel.selectedLinkerType == 1
                    }) {
                        print("ITR..Button 1 pressed")
                        dataModel.selectedLinkerType = 1
                        dataModel.stepStates[1].colorSelected = true
                    }
                    ADCButtonSquareWithOutline(imageName: "linkers2",
                                            outlineColor: Color.white,
                                            description: "",
                                            index: 2,
                                            isSelected: {
                        dataModel.selectedLinkerType == 2
                    }) {
                        print("ITR..Button 2 pressed")
                        dataModel.selectedLinkerType = 2
                        dataModel.stepStates[1].colorSelected = true
                    }
                }
                .padding(.bottom, 30)
            }
        .frame(width: 600, height: 280)
        .glassBackgroundEffect()
        // .selectorAnimation(isVOPlaying: dataModel.isVOPlaying)
    }
}
//#Preview {
//    ADCLinkerSelectorView()
//        .environment(ADCAppModel())
//        .environment(ADCDataModel())
//}

```

File: ADC/Views/ADCBuilder/ADCSelectorView.swift
```swift
import SwiftUI

struct ADCSelectorView: View {
    @Environment(AppModel.self) var appModel
    @Environment(ADCDataModel.self) var dataModel
    
    var noButton: Bool = false
    
    var body: some View {
        VStack (spacing:30) {
            HStack (spacing: 10) {
                Text("Select Antibody Color")
                    .font(.title)
                Spacer()
                
                
                ADCCheckmarkButton(
                    action: {
                        // Update step state and advance
                        dataModel.stepStates[0].checkmarkClicked = true
                        dataModel.adcBuildStep = 1
                    },
                    isEnabled: dataModel.selectedADCAntibody != nil
                )
                .disabled(noButton)
                
                
            }
            .padding(.vertical, 30)
            .padding(.horizontal, 30)
            .background(.black.opacity(0.4))
            HStack (alignment: .top, spacing: 20){
                    ADCButtonSquareWithOutline(imageName: "antibody0",
                                           outlineColor: Color.white,
                                           description: "",
                                           index: 0,
                                           isSelected: {
                        dataModel.selectedADCAntibody == 0
                    }) {
                        print("ITR..Button 0 antibody pressed")
                        dataModel.selectedADCAntibody = 0
                        dataModel.stepStates[0].colorSelected = true
                    }
                    ADCButtonSquareWithOutline(imageName: "antibody1",
                                           outlineColor: Color.white,
                                           description: "",
                                           index: 1,
                                           isSelected: {
                        dataModel.selectedADCAntibody == 1
                    }) {
                        print("ITR..Button 1 antibody pressed")
                        dataModel.selectedADCAntibody = 1
                        dataModel.stepStates[0].colorSelected = true
                    }
                    ADCButtonSquareWithOutline(imageName: "antibody2",
                                           outlineColor: Color.white,
                                           description: "",
                                           index: 2,
                                           isSelected: {
                        dataModel.selectedADCAntibody == 2
                    }) {
                        print("ITR..Button 2 antibody pressed")
                        dataModel.selectedADCAntibody = 2
                        dataModel.stepStates[0].colorSelected = true
                    }
                }
                .padding(.bottom, 30)
            }
        .frame(width: 600, height: 300)
        .glassBackgroundEffect()
        // .selectorAnimation(isVOPlaying: dataModel.isVOPlaying)
    }
}

//#Preview {
//    ADCSelectorView()
//        .environment(AppModel())
//        .environment(ADCDataModel())
//    
//}

```

File: ADC/Views/ADCBuilder/ADCView.swift
```swift
import SwiftUI
import os

struct ADCView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel
    
    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
    @Environment(\.openImmersiveSpace) private var openImmersiveSpace
    @Environment(\.openWindow) private var openWindow
    @Environment(\.dismissWindow) private var dismissWindow
    
    var body: some View {
        if appModel.isBuilderInstructionsOpen {
            VStack(spacing: 0) {
                // Header bar
                ZStack {
                    HStack {
                        Image("Pfizer_Logo_White_RGB")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 100)
                            .padding(.leading, 30)
                        Spacer()
                    }
                    HStack {
                        Spacer()
                        Text("Build Your ADC")
                            .font(.largeTitle)
                            .transition(.opacity.combined(with: .move(edge: .top)))
                            .animation(.easeInOut(duration: 0.3), value: dataModel.adcBuildStep)
                        Spacer()
                    }
                }
                .padding(.horizontal, 30)
                .frame(height: 100)
                .background(Color.black.opacity(0.4))
                
                // Content
                VStack(spacing: 0) {
                    // Instructions sections
                    VStack(alignment: .leading, spacing: 20) {
                        instructionSection(
                            title: "Design Your Antibody",
                            description: "Select and customize your antibody with a unique color that will target specific cancer cells.",
                            systemImage: "target"
                        )
                        
                        instructionSection(
                            title: "Connect the Linker",
                            description: "Choose and color your linker component that will connect the antibody to the payload.",
                            systemImage: "link"
                        )
                        
                        instructionSection(
                            title: "Add the Payload",
                            description: "Select and customize the payload that will be delivered to destroy cancer cells.",
                            systemImage: "pill.fill"
                        )
                        
                        instructionSection(
                            title: "Assemble Your ADC",
                            description: "Drag and connect your components to create a complete Antibody Drug Conjugate.",
                            systemImage: "arrow.triangle.merge"
                        )
                    }
                    .padding(.horizontal, 120)
                    .padding(.top, 30)
                    .padding(.bottom, 30)
                    
                    // Start button
                    NavigationButton(
                        title: "Start Building!",
                        action: {
                            Task { @MainActor in
                                switch appModel.immersiveSpaceState {
                                case .open:
                                    appModel.immersiveSpaceState = .inTransition
                                    os_log(.debug, "ADCView: Attempting to dismiss current immersive space.")
                                    await dismissImmersiveSpace()
                                    os_log(.debug, "ADCView: Immersive space dismissed. Waiting 500ms before opening new immersive space.")
                                    try? await Task.sleep(nanoseconds: 500_000_000) // 500ms delay
                                    os_log(.debug, "ADCView: Now trying to open immersive space with id: %@", AppModel.buildingSpaceId)
                                    switch await openImmersiveSpace(id: AppModel.buildingSpaceId) {
                                    case .opened:
                                        os_log(.debug, "ADCView: immersive space open returned .opened")
                                        appModel.isBuilderInstructionsOpen = false
                                        dismissWindow(id: AppModel.mainWindowId)
                                        appModel.isMainWindowOpen = false
                                    case .userCancelled, .error:
                                        fallthrough
                                    @unknown default:
                                        os_log(.error, "ADCView: immersive space open failed or unknown result; setting state to closed")
                                        appModel.immersiveSpaceState = .closed
                                    }
                                    
                                case .closed:
                                    appModel.immersiveSpaceState = .inTransition
                                    os_log(.debug, "ADCView: Immersive space currently closed. Attempting to open with id: %@", AppModel.buildingSpaceId)
                                    switch await openImmersiveSpace(id: AppModel.buildingSpaceId) {
                                    case .opened:
                                        os_log(.debug, "ADCView: immersive space open returned .opened")
                                        appModel.isBuilderInstructionsOpen = false
                                        dismissWindow(id: AppModel.mainWindowId)
                                        appModel.isMainWindowOpen = false
                                    case .userCancelled, .error:
                                        fallthrough
                                    @unknown default:
                                        os_log(.error, "ADCView: immersive space open failed for unknown reasons; setting state to closed")
                                        appModel.immersiveSpaceState = .closed
                                    }
                                    
                                case .inTransition:
                                    os_log(.debug, "ADCView: immersive space is currently in transition; ignoring user action.")
                                    break
                                }
                            }
                        },
                        font: .title,
                        scaleEffect: AppModel.UIConstants.buttonExpandScale
                    )
                    .fontWeight(.bold)
                    .padding(30)
                    // .padding(.bottom, 30)

                }
                .padding(.top, 30)
                .padding(.bottom, 30)
            }
            .frame(width: 800)
            .glassBackgroundEffect()
        }
    }
    
    private func instructionSection(title: String, description: String, systemImage: String) -> some View {
        HStack(alignment: .top, spacing: 15) {
            Image(systemName: systemImage)
                .font(.title)
                .foregroundColor(.blue)
                .frame(width: 30)
            
            VStack(alignment: .leading, spacing: 5) {
                Text(title)
                    .font(.title3)
                    .fontWeight(.semibold)
                    .fixedSize(horizontal: false, vertical: true)
                
                Text(description)
                    .font(.body)
                    .foregroundColor(.secondary)
                    .opacity(0.7)
                    .fixedSize(horizontal: false, vertical: true)
                    .lineLimit(nil)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
    }
}

// Custom transition combining move and fade
extension AnyTransition {
    static var moveAndFade: AnyTransition {
        .asymmetric(
            insertion: .move(edge: .trailing).combined(with: .opacity),
            removal: .scale.combined(with: .opacity)
        )
    }
}

//#Preview {
//    let appModel = AppModel()
//    appModel.isBuilderInstructionsOpen = true  // Set this to true to see the view
//    
//    return ADCView()
//        .environment(appModel)
//        .environment(ADCDataModel())
//        .frame(width: 400, height: 400)
//}

```

File: ADC/Views/ADCBuilder/ADCPayloadSelectorView.swift
```swift
import SwiftUI

struct ADCPayloadSelectorView: View {
    @Environment(AppModel.self) var appModel
    @Environment(ADCDataModel.self) var dataModel
    
    var noButton: Bool = true
    
    var body: some View {
        VStack (spacing:30) {
            HStack (spacing: 10) {
                Text("Select Payload color and place Payload")
                    .font(.title)
                    .frame(maxWidth: .infinity, alignment: .leading)
                if dataModel.placedPayloadCount > 0 {
                    Text("\(dataModel.placedPayloadCount) of 4")
                        .font(.title2)
                        .foregroundColor(.gray)
                        .frame(alignment: .trailing)
                }
                
                
                ADCCheckmarkButton(
                    action: {
                        // Update step state and advance
                        dataModel.stepStates[2].checkmarkClicked = true
                        dataModel.adcBuildStep = 3
                    },
                    isEnabled: dataModel.selectedPayloadType != nil && dataModel.placedPayloadCount == 4
                )
                // .disabled(noButton)
                
                
            }
            .padding(.vertical, 30)
            .padding(.horizontal, 30)
            .background(.black.opacity(0.4))
            HStack (alignment: .top, spacing: 20){
                ADCButtonSquareWithOutline(imageName: "payload0",
                                        outlineColor: Color.white,
                                        description: "",
                                        index: 0,
                                        isSelected: {
                                            dataModel.selectedPayloadType == 0
                                        }) {
                    print("ITR..Button 0 pressed")
                    dataModel.selectedPayloadType = 0
                    dataModel.stepStates[2].colorSelected = true
                }
                ADCButtonSquareWithOutline(imageName: "payload1",
                                        outlineColor: Color.white,
                                        description: "",
                                        index: 1,
                                        isSelected: {
                                            dataModel.selectedPayloadType == 1
                                        }) {
                    print("ITR..Button 1 pressed")
                    dataModel.selectedPayloadType = 1
                    dataModel.stepStates[2].colorSelected = true
                }
                ADCButtonSquareWithOutline(imageName: "payload2",
                                        outlineColor: Color.white,
                                        description: "",
                                        index: 2,
                                        isSelected: {
                                            dataModel.selectedPayloadType == 2
                                        }) {
                    print("ITR..Button 2 pressed")
                    dataModel.selectedPayloadType = 2
                    dataModel.stepStates[2].colorSelected = true
                }
                
                }
                .padding(.bottom, 30)
            }
        .frame(width: 600, height: 280)
        .glassBackgroundEffect()
        // .selectorAnimation(isVOPlaying: dataModel.isVOPlaying)
    }
}

//#Preview {
//    ADCPayloadSelectorView()
//        .environment(ADCAppModel())
//        .environment(ADCDataModel())
//}

```

File: AppModel/AppModel+AssetLoading.swift
```swift
//
//  AppModel+AssetLoading.swift
//  SpawnAndAttrack
//
//  Created by Dale Carman on 12/10/24.
//

import SwiftUI

// Define a generic error to use
enum AppError: Error {
    case genericLoadingError
}

extension AppModel {
    // MARK: - Asset Loading
    
    var isLoadingAssets: Bool {
        if case .loading = assetLoadingManager.state {
            return true
        }
        return false
    }
    
    var assetsLoaded: Bool {
        if case .completed = assetLoadingManager.state {
            return true
        }
        return false
    }
    
    struct AssetToLoad {
        let name: String
        let category: AssetCategory
        let weight: Float  // Relative weight for progress calculation
    }
    
    func startLoading(adcDataModel: ADCDataModel) async {
        print("\n=== Starting Initial Asset Loading ===")
        print("🔍 Current phase: \(currentPhase)")
        print("🔍 Loading state: \(assetLoadingManager.loadingState)")
        
        // Reset the asset loading manager
        // assetLoadingManager.reset()
        
        print("🔄 Starting prepareIntroPhase...")
        await prepareIntroPhase()
        print("✅ prepareIntroPhase completed")
        print("🔄 Transitioning to .intro...")
        await transitionToPhase(.intro, adcDataModel: adcDataModel)
        print("✅ Transition to .intro completed")
    }
    
    func prepareIntroPhase() async {
        print("\n=== Preparing Intro Phase ===")
        print("🔍 Current phase before loading: \(currentPhase)")
        print("🔍 Loading state: \(assetLoadingManager.loadingState)")
        
        var introAssets: [String] = []
        introAssets.append(contentsOf: [
            "intro_environment",
            "intro_warp",
        ])
        
        var attackAssets: [String] = []
        attackAssets.append(contentsOf: [
            "attack_cancer_environment",
            "adc",
            "cancer_cell"
        ])
        
        var labAssets: [String] = []
        labAssets.append(contentsOf: [
            "assembled_lab"
        ])
        
        let allAssets = introAssets + attackAssets + labAssets
        
        var completedAssets = 0
        
        // Load intro environment assets
        for key in allAssets {
            print("📱 Loading asset: \(key)")
            
            let category: AssetCategory
            if introAssets.contains(key) {
                category = .introEnvironment
            } else if attackAssets.contains(key) {
                category = .attackCancerEnvironment
            } else if labAssets.contains(key) {
                category = .labEnvironment
            } else {
                // Default case, should not happen
                print("⚠️ Unknown asset category for key: \(key)")
                continue
            }
            
            do {
                _ = try await assetLoadingManager.loadAsset(withName: key, category: category)
                completedAssets += 1
                let progress = Float(completedAssets) / Float(allAssets.count)
                print("✅ Loaded \(key) - Progress: \(progress)")
            } catch {
                print("❌ Failed to load \(key): \(error)")
                // Use the generic error here
                assetLoadingManager.loadingState = .error(AppError.genericLoadingError)
                return // Exit the function on error
            }
        }
        print("✅ prepareIntroPhase completed")
    }
}

```

File: AssetManagement/AssetLoadingManager+Lab.swift
```swift
import Foundation
import RealityKit
import RealityKitContent

extension AssetLoadingManager {


    
    internal func loadLabEquipmentAssets(group: inout ThrowingTaskGroup<LoadResult, Error>, taskCount: inout Int) {
        let labAssets = [
            "autoclave", "beaker", "beaker_tall", "bin", "bottle_liquid",
            "bottle_pill", "bottle_square", "bottle_squat", "centrifuge",
            "chair", "deskShelf_double", "deskShelf_single", 
            "dryingRack", "flask_conical", "flask_conical_lg",
            "flask_flatBottom", "flask_flatBottom_lg", "flask_volumetric",
            "flask_volumetric_lg", "fridge_sm", "glovesBox_A", "glovesBox_B",
            "jar_pill", "jar_pill_sm", "laptop", "mettlerBalance",
            "mettlerBalance_box", "microscope", "oven", "pcKeyboard",
            "pcMonitor", "pcMouse", "pcTower", "shaker", "squirter",
            "stool", "testTubes_lg_set", "testTubes_sm_set", "tester",
            "uvBox", "vortex", "wasteBasket"
        ]
        
        for assetName in labAssets {
            group.addTask {
                let fullPath = "\(self.labObjectsPath)/\(assetName)"
                print("Starting to load asset: \(fullPath)")
                do {
                    let entity = try await Entity(named: fullPath, in: realityKitContentBundle)
                    print("Successfully loaded asset: \(fullPath)")
                    return .success(entity: entity, key: fullPath, category: .labEquipment)
                } catch {
                    print("Failed to load asset: \(fullPath), error: \(error)")
                    return .failure(key: fullPath, category: .labEquipment, error: error)
                }
            }
            taskCount += 1
        }
    }
    
    /// Load and populate a complete lab scene
    func loadPopulatedLabScene() async throws -> Entity {
        // Load the empty lab scene
        let emptyScene = try await Entity(named: "\(labObjectsPath)/lab_empties", in: realityKitContentBundle)
        
        // Find all empty transforms and get the total count
        let (emptyTransforms, totalCount) = findEmptyTransforms(in: emptyScene)
        var loadedCount = 0
        
        // Process each empty transform
        for empty in emptyTransforms {
            if let assetName = extractAssetName(from: empty.name) {
                // Load or get cached asset
                let asset = try await loadLabAsset(named: assetName)
                
                // Clone and parent
                let instance = asset.clone(recursive: true)
                empty.addChild(instance)
                
                // Configure the instance
                configureLabInstance(instance, for: empty)

                // Update progress
                loadedCount += 1
                let progress = Float(loadedCount) / Float(totalCount)
                loadingState = .loading(progress: progress)
            }
        }
        
        // Apply final scene rotation
        await MainActor.run {
            emptyScene.orientation = simd_quatf(angle: -.pi/2, axis: [1, 0, 0])
        }
        
        return emptyScene
    }
    
    private func loadLabAsset(named assetName: String) async throws -> Entity {
        return try await self.loadEntity(named: "\(labObjectsPath)/\(assetName)")
    }
    
    // MARK: - Private Helper Methods
    
    private func findEmptyTransforms(in scene: Entity) -> ([Entity], Int) {
        var empties: [Entity] = []
        
        func traverse(entity: Entity) {
            if entity.name.hasPrefix("empty_") {
                empties.append(entity)
            }
            
            for child in entity.children {
                traverse(entity: child)
            }
        }
        
        traverse(entity: scene)
        return (empties, empties.count) // Return both the array and the count
    }
    
    private func extractAssetName(from name: String) -> String? {
        // Remove the prefix "empty_" and the suffix "_<number>"
        let prefix = "empty_"
        guard name.hasPrefix(prefix) else { return nil }
        let nameWithoutPrefix = String(name.dropFirst(prefix.count))
        
        // Find the last underscore which precedes the number
        if let lastUnderscoreIndex = nameWithoutPrefix.lastIndex(of: "_") {
            let assetName = nameWithoutPrefix[..<lastUnderscoreIndex]
            return String(assetName)
        } else {
            // If there's no underscore, return the entire name
            return nameWithoutPrefix
        }
    }
    
    private func configureLabInstance(_ instance: Entity, for empty: Entity) {
        instance.position = .zero
        instance.orientation = .init()
        instance.scale = .one
    }
    
    /// Loads and assembles the complete lab environment on demand
    func loadAssembledLab() async throws -> Entity {
        print("📱 Starting lab environment assembly")
        
        // Check if we already have it cached
        if let cached = entityTemplates["assembled_lab"] {
            print("✅ Using cached assembled lab")
            return cached.clone(recursive: true)
        }
        loadingState = .loading(progress: 0.0)

        let assetRoot = Entity()
        
        // Use existing assembly logic
        let labEnvironmentScene = try await loadEntity(named: "LabEnvironment")
        assetRoot.addChild(labEnvironmentScene)
        
        // Use existing equipment population
        let equipmentScene = try await loadPopulatedLabScene()
        assetRoot.addChild(equipmentScene)
        
        // Use existing IBL setup
        try await IBLUtility
            .addImageBasedLighting(
                to: assetRoot,
                imageName: "lab_v005",
                intensity: 1.0
            )
        
        // Cache the assembled lab
        entityTemplates["assembled_lab"] = assetRoot
        loadingState = .completed
        print("✅ Completed lab environment assembly")
        return assetRoot.clone(recursive: true)
    }
} 

```

File: AssetManagement/AssetLoadingManager.swift
```swift
//
//  AssetLoadingManager.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman
//

import Foundation
import RealityKit
import RealityKitContent
import SwiftUI

/// Represents the result of loading an asset
enum LoadResult {
    case success(entity: Entity, key: String, category: AssetCategory)
    case failure(key: String, category: AssetCategory, error: Error)
}

/// Structure to track failed asset loads
struct FailedAsset {
    let key: String
    let category: AssetCategory
    let error: Error
}

/// Categories of assets for each environment
enum AssetCategory {
    case introEnvironment
    case outroEnvironment
    case labEnvironment
    case labEquipment
    case buildADCEnvironment
    case attackCancerEnvironment
    case cancerCell
    case adc
}

/// Loading state of the asset manager
enum LoadingState {
    case notStarted
    case loading(progress: Float)
    case completed
    case error(Error)
}

// Add the Equatable conformance in an extension
extension LoadingState: Equatable {
    static func ==(lhs: LoadingState, rhs: LoadingState) -> Bool {
        switch (lhs, rhs) {
        case (.notStarted, .notStarted):
            return true
        case (.loading(let p1), .loading(let p2)):
            return p1 == p2
        case (.completed, .completed):
            return true
        case (.error, .error): // Ignore error details
            return true
        default:
            return false
        }
    }
}

/// Add at the top level, before the AssetLoadingManager class
enum AssetError: Error {
    case resourceNotFound
    case criticalAssetsMissing(String)
    case materialNotFound
    case protobufError(String)  // Add protobuf error case
    // Add other asset-related errors as needed
}

/// Manages the loading and instantiation of assets in the lab environment
@MainActor
@Observable
final class AssetLoadingManager {
    // MARK: - Properties
    
    /// Singleton instance
    static let shared = AssetLoadingManager()
    
    /// Cached entity templates for efficient cloning
    internal var entityTemplates: [String: Entity] = [:]
    
    /// Track audio controllers for proper cleanup
    private var audioControllers: [Entity.ID: AudioPlaybackController] = [:]
    
    /// Track failed asset loads
    private var failedAssets: [FailedAsset] = []
    
    /// Public accessor for failed assets
    var loadingFailures: [FailedAsset] { failedAssets }
    
    /// Path to lab objects in RealityKitContent bundle
    internal let labObjectsPath = "Assets/Lab/Objects"
    
    /// Current loading state
    var loadingState: LoadingState = .notStarted
    
    /// The current state of asset loading
    var state: LoadingState { loadingState }
    
    // MARK: - Public Methods
    
    /// Resets the asset loading manager to its initial state
    func reset() {
        print("\n=== Resetting AssetLoadingManager ===")
        // Reset loading state
        loadingState = .notStarted
        
        // Clear failed assets
        failedAssets.removeAll()
        
        // Release all cached entities
        for (key, entity) in entityTemplates {
            print("🗑️ Releasing asset: \(key)")
            releaseEntity(entity)
        }
        
        // Clear templates
        entityTemplates.removeAll()
        
        // Clear audio controllers
        audioControllers.removeAll()
        
        print("✅ AssetLoadingManager reset complete\n")
    }
    
    /// Releases intro environment assets asynchronously
    func releaseIntroEnvironment() async {
        print("\n=== Starting Intro Environment Cleanup ===")
        
        // Log initial state
        #if DEBUG
        print("📊 Current template cache size: \(entityTemplates.count) entities")
        print("📊 Current templates: \(entityTemplates.keys.joined(separator: ", "))")
        #endif
        
        // Remove from entity templates
        let keysToRemove = [
            "intro_environment",
            "intro_warp",
        ]
        #if DEBUG
        print("🗑️ Preparing to remove \(keysToRemove.count) intro assets:")
        #endif
        for key in keysToRemove {
            if let entity = entityTemplates[key] {
                #if DEBUG
                print("\n🗑️ Removing asset: \(key)")
                #endif
                // Use releaseEntity for thorough cleanup including audio
                releaseEntity(entity)
                // Remove from templates after release
                entityTemplates.removeValue(forKey: key) // Remove immediately after release
                #if DEBUG
                print("✅ Released asset: \(key)")
                #endif
            } else {
                #if DEBUG
                print("⚠️ Asset not found in cache: \(key)")
                #endif
            }
        }
        
        // Log final state
        print("\n📊 Updated template cache size: \(entityTemplates.count) entities")
        if let remainingKeys = entityTemplates.keys.first {
            print("🔒 Remaining asset: \(remainingKeys)")
        }
        print("✅ Completed intro environment cleanup\n")
    }
    
    /// Releases an entity and all its resources
    func releaseEntity(_ entity: Entity) {
        // 1. Log the hierarchy before removal for debugging
        #if DEBUG
        print("\n📝 Releasing entity: \(entity.name)")
        print("  - Child count: \(entity.children.count)")
        print("  - Has components: \(entity.components.isEmpty ? "no" : "yes")")
        #endif
        // 2. Recursively release all children first
        for child in entity.children {
            releaseEntity(child)
        }
        
        // 3. Stop any active audio playback
        if let controller = audioControllers[entity.id] {
            #if DEBUG
            print("  - Stopping audio playback for entity: \(entity.name)")
            #endif
            controller.stop()
            audioControllers.removeValue(forKey: entity.id)
        }
        
        // 4. Remove all components
        entity.components.removeAll()
        
        // 5. Remove from parent
        if let parent = entity.parent {
            #if DEBUG
            print("  - Detaching from parent: \(parent.name)")
            #endif
            entity.removeFromParent()
        }
        #if DEBUG
        print("✅ Released entity: \(entity.name)\n")
        #endif
    }
    
    /// Releases lab environment assets asynchronously
    func releaseLabEnvironment() async {
        print("\n=== Starting Lab Environment Cleanup ===")
        
        // Log initial state
        #if DEBUG
        print("📊 Current template cache size: \(entityTemplates.count) entities")
        print("📊 Current templates: \(entityTemplates.keys.joined(separator: ", "))")
        #endif
        
        // Get all keys except assembled_lab
        let keysToRemove = entityTemplates.keys.filter { $0 != "assembled_lab" }
        
        print("🗑️ Preparing to remove \(keysToRemove.count) assets after lab phase:")
        for key in keysToRemove {
            if let entity = entityTemplates[key] {
                #if DEBUG
                print("\n🗑️ Removing asset: \(key)")
                #endif
                // Use new releaseEntity function for thorough cleanup
                releaseEntity(entity)
                // Remove from templates after release
                entityTemplates.removeValue(forKey: key)
                #if DEBUG
                print("✅ Released asset: \(key)")
                #endif
            }
        }
        
        // Log final state
        print("\n📊 Updated template cache size: \(entityTemplates.count) entities")
        if let remainingKeys = entityTemplates.keys.first {
            print("🔒 Remaining asset: \(remainingKeys)")
        }
        print("✅ Completed aggressive lab cleanup\n")
    }
    
    /// Releases outro environment assets asynchronously
    func releaseOutroEnvironment() async {
        print("\n=== Starting Outro Environment Cleanup ===")
        
        // Log initial state
        print("📊 Current template cache size: \(entityTemplates.count) entities")
        print("📊 Current templates: \(entityTemplates.keys.joined(separator: ", "))")
        
        // Remove from entity templates
        let keysToRemove = [
            "outro_environment"
        ]
        
        print("🗑️ Preparing to remove \(keysToRemove.count) outro assets:")
        for key in keysToRemove {
            if let entity = entityTemplates[key] {
                print("\n🗑️ Removing asset: \(key)")
                // Use releaseEntity for thorough cleanup including audio
                releaseEntity(entity)
                // Remove from templates after release
                entityTemplates.removeValue(forKey: key)
                print("✅ Released asset: \(key)")
            } else {
                print("⚠️ Asset not found in cache: \(key)")
            }
        }
        
        // Log final state
        print("\n📊 Updated template cache size: \(entityTemplates.count) entities")
        if let remainingKeys = entityTemplates.keys.first {
            print("🔒 Remaining asset: \(remainingKeys)")
        }
        print("✅ Completed outro environment cleanup\n")
    }
    
    /// Releases attack cancer environment assets asynchronously
    func releaseAttackCancerEnvironment() async {
        print("\n=== Starting Attack Cancer Environment Cleanup ===")
        
        // Log initial state
        print("📊 Current template cache size: \(entityTemplates.count) entities")
        print("📊 Current templates: \(entityTemplates.keys.joined(separator: ", "))")
        
        // Remove voice-over assets
        let keysToRemove = [
            "game_start_vo"
        ]
        
        print("🗑️ Preparing to remove \(keysToRemove.count) attack cancer VO assets:")
        for key in keysToRemove {
            if let entity = entityTemplates[key] {
                print("\n🗑️ Removing asset: \(key)")
                releaseEntity(entity)
                entityTemplates.removeValue(forKey: key) // Remove immediately
                print("✅ Released asset: \(key)")
            } else {
                print("⚠️ Asset not found in cache: \(key)")
            }
        }
        
        // Log final state
        print("\n📊 Updated template cache size: \(entityTemplates.count) entities")
        if let remainingKeys = entityTemplates.keys.first {
            print("🔒 Remaining asset: \(remainingKeys)")
        }
        print("✅ Completed attack cancer environment cleanup\n")
    }
    
    /// Get the current loading progress
    func loadingProgress() -> Float {
        switch loadingState {
        case .notStarted:
            return 0
        case .loading(let progress):
            return progress
        case .completed:
            return 1
        case .error:
            return 0
        }
    }
    
    /// Logs the entity hierarchy during instantiation
    func instantiateEntity(_ key: String) async -> Entity? {
        guard let template = entityTemplates[key] else {
            print("Warning: No template found for key: \(key)")
            return nil
        }
        let clone = template.clone(recursive: true)
        print("\nCloned entity for key: \(key)")
//        inspectEntityHierarchy(clone)
        return clone
    }
    
    internal func processLoadedAsset(_ result: LoadResult) {
        switch result {
        case .success(let entity, let key, _):
            entityTemplates[key] = entity
        case .failure(_, _, _):
            break
        }
    }
    
    // MARK: - Memory Management
    
    /// Aggressively cleans up all assets except those explicitly needed for playing phase
    func cleanupForPlayingPhase() async {
        print("\n=== Starting Aggressive Cleanup for Playing Phase ===")
        
        // Log initial state
        print("📊 Before cleanup - Template cache size: \(entityTemplates.count) entities")
        print("📊 Current templates: \(entityTemplates.keys.joined(separator: ", "))")
        
        // Only keep assembled_lab and cancer_cell for playing phase
        let essentialForPlaying = ["assembled_lab", "cancer_cell"]
        let keysToRemove = entityTemplates.keys.filter { !essentialForPlaying.contains($0) }
        
        print("\n🗑️ Aggressively removing \(keysToRemove.count) non-essential assets:")
        for key in keysToRemove {
            if let entity = entityTemplates[key] {
                print("\n🗑️ Removing asset: \(key)")
                // Use releaseEntity for thorough cleanup including audio
                releaseEntity(entity)
                entityTemplates.removeValue(forKey: key)
                print("✅ Released asset: \(key)")
            }
        }
        
        // Clear any remaining audio controllers
        let audioCount = audioControllers.count
        if audioCount > 0 {
            print("\n🔊 Clearing \(audioCount) audio controllers")
            audioControllers.removeAll()
        }
        
        // Log final state
        print("\n📊 After cleanup - Template cache size: \(entityTemplates.count) entities")
        print("🔒 Remaining assets: \(entityTemplates.keys.joined(separator: ", "))")
        print("✅ Completed aggressive cleanup for playing phase\n")
        
        // Force a garbage collection if possible
        #if DEBUG
        print("💭 Requesting memory cleanup")
        Task { @MainActor in
            try? await Task.sleep(for: .seconds(0.1))
            print("💭 Memory cleanup requested")
        }
        #endif
    }

    /// Handles memory pressure by releasing non-essential assets
    func handleMemoryWarning() {
        print("\n⚠️ === Handling Memory Pressure ===")
        print("📊 Before cleanup - Template cache size: \(entityTemplates.count) entities")
        print("📊 Current templates: \(entityTemplates.keys.joined(separator: ", "))")
        
        // Clear ALL audio controllers immediately
        let audioCount = audioControllers.count
        if audioCount > 0 {
            print("\n🔊 Clearing \(audioCount) audio controllers")
            audioControllers.removeAll()
        }
        
        // Keep only absolute essentials based on current phase
        let essentialKeys = [
            "assembled_lab",
            "attack_cancer_environment",
            "adc",
            "cancer_cell"
        ]
        let nonEssentialKeys = entityTemplates.keys.filter { !essentialKeys.contains($0) }
        
        print("\n🔒 Essential assets to retain: \(essentialKeys)")
        print("🗑️ Non-essential assets to release: \(nonEssentialKeys)")
        
        // Release non-essential assets
        for key in nonEssentialKeys {
            if let entity = entityTemplates[key] {
                releaseEntity(entity)
                entityTemplates.removeValue(forKey: key)
                print("  - Released: \(key)")
            }
        }
        
        print("\n📊 After cleanup - Template cache size: \(entityTemplates.count) entities")
        print("🔒 Remaining assets: \(entityTemplates.keys.joined(separator: ", "))")
        print("✅ Memory pressure handling complete\n")
    }
    
    internal func validateTemplate(_ entity: Entity, category: AssetCategory) async {
        print("\n=== Validating \(category) Template ===")
        inspectEntityHierarchy(entity, level: 0)
    }
    
    /// Debug utility to inspect entity hierarchies
    public func inspectEntityHierarchy(_ entity: Entity, level: Int = 0, showComponents: Bool = true) {
        let indent = String(repeating: "  ", count: level)
        print("\(indent)Entity: \(entity.name)")
        if showComponents {
            print("\(indent)Components: \(entity.components.map { type(of: $0) })")
        }
        
        for child in entity.children {
            inspectEntityHierarchy(child, level: level + 1, showComponents: showComponents)
        }
    }
    
    /// Load an entity by name, using caching to avoid redundant loads
    func loadEntity(named name: String) async throws -> Entity {
        // First attempt: Check cache and clone to ensure each usage gets its own instance
        if let cachedEntity = entityTemplates[name] {
            return cachedEntity.clone(recursive: true)
        }

        do {
            // Second attempt: Load from bundle and handle protobuf errors
        let entity = try await Entity(named: name, in: realityKitContentBundle)
            // Clone again to ensure the loaded entity is independent and can be used multiple times
        return entity.clone(recursive: true)
        } catch {
            if error.localizedDescription.contains("protobuf") {
                print("❌ Protobuf error loading \(name): \(error)")
                throw AssetError.protobufError(name)
            }
            throw error
        }
    }
    
    // MARK: - On-Demand Asset Loading

    // Add a private mapping from our logical keys to actual asset names
    private let assetNameMappings: [String: String] = [
        "intro_environment": "IntroEnvironment",
        "intro_warp": "IntroWarp",
        "title_card": "outdoCancer",
        "lab_environment": "LabEnvironment",
        "lab_vo": "LabVO",
        "lab_audio": "LabAudio",
        "antibody_scene": "antibodyScene",
        "attack_cancer_environment": "AttackCancerEnvironment",
        "adc": "ADC-spawn",  // ADC asset name
        "cancer_cell": "CancerCell-spawn",  // Cancer cell asset name
        "game_start_vo": "AttackCancerGameStart_VO",  // Tutorial/game start VO
        "test_fire_cell": "TestFireCell",  // Test fire cell asset name
        "outro_environment": "OutroEnvironment"  // Outro environment asset
        // add further mappings as needed
    ]

    // Helper function to obtain the actual asset name from a key
    private func actualAssetName(for key: String, category: AssetCategory) -> String {
        return assetNameMappings[key] ?? key
    }

    /// Loads an asset by name on demand and caches it.
    func loadAsset(withName name: String, category: AssetCategory) async throws -> Entity {
        print("AssetLoadingManager: loadAsset(withName: \(name), category: \(category))")
        // For the assembled lab, use the specialized loader
        if name == "assembled_lab" {
            return try await loadAssembledLab()
        }
        
        // If already cached, return a clone of the cached asset
        if let cached = entityTemplates[name] {
            return cached.clone(recursive: true)
        }
        
        // Map the provided logical key to the actual resource name
        let actualName = actualAssetName(for: name, category: category)
        
        // Attempt to load from the RealityKitContent bundle using the actual asset name
        let entity = try await self.loadEntity(named: actualName)
        
        // Special handling for ADC asset
        if name == "adc" {
            if let innerRoot = entity.children.first {
                print("✅ ADC template loaded (using inner Root with audio)")
                // Cache the inner root as the ADC template
                entityTemplates[name] = innerRoot
                return innerRoot.clone(recursive: true)
            } else {
                print("❌ Failed to find inner root in ADC-spawn")
                throw AssetError.resourceNotFound
            }
        }
        
        // Cache the loaded asset for future use using the logical key
        entityTemplates[name] = entity
        
        // Return a cloned copy so that modifications do not affect the cached template
        return entity.clone(recursive: true)
    }

    /// Instantiates an asset, returning a cloned instance.
    func instantiateAsset(withName name: String, category: AssetCategory) async throws -> Entity {
        return try await loadAsset(withName: name, category: category)
    }

    /// Stores an audio controller for later cleanup
    func trackAudioController(_ controller: AudioPlaybackController, for entity: Entity) {
        audioControllers[entity.id] = controller
        print("📝 Tracking audio controller for entity: \(entity.name)")
    }
}

```

File: Assets.xcassets/AccentColor.colorset/Contents.json
```json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/antibody0.imageset/antibody0.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/antibody1.imageset/antibody1.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/antibody0.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "antibody0.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/antibody1.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "antibody1.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/antibody2.imageset/antibody2.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/antibody2.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "antibody2.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/antibody3.imageset/antibody3.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/linkers0.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "linkers0.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/antibody3.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "antibody3.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/linkers0.imageset/linkers0.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/linkers1.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "linkers1.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/linkers1.imageset/linkers1.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/linkers2.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "linkers2.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/linkers2.imageset/linkers2.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/linkers3.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "linkers3.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/linkers3.imageset/linkers3.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/payload0.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "payload0.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/payload0.imageset/payload0.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/payload1.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "payload1.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/payload1.imageset/payload1.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/payload2.imageset/payload2.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/payload3.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "payload3.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/payload2.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "payload2.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/payload3.imageset/payload3.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/questionMark.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "questionMark.png",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/ADCBuilder/questionMark.imageset/questionMark.png
```png
[Binary file]
```

File: Assets.xcassets/ADCBuilder/Contents.json
```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/AppIcon.solidimagestack/Back.solidimagestacklayer/Content.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "PfizerIconBackground.jpg",
      "idiom" : "vision",
      "scale" : "2x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/AppIcon.solidimagestack/Back.solidimagestacklayer/Content.imageset/PfizerIconBackground.jpg
```jpg
[Binary file]
```

File: Assets.xcassets/AppIcon.solidimagestack/Back.solidimagestacklayer/Contents.json
```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/AppIcon.solidimagestack/Front.solidimagestacklayer/Content.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "PfizerIconFront.png",
      "idiom" : "vision",
      "scale" : "2x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/AppIcon.solidimagestack/Front.solidimagestacklayer/Contents.json
```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/AppIcon.solidimagestack/Front.solidimagestacklayer/Content.imageset/PfizerIconFront.png
```png
[Binary file]
```

File: Assets.xcassets/AppIcon.solidimagestack/Middle.solidimagestacklayer/Content.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "PfizerIconMiddle.png",
      "idiom" : "vision",
      "scale" : "2x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/AppIcon.solidimagestack/Middle.solidimagestacklayer/Content.imageset/PfizerIconMiddle.png
```png
[Binary file]
```

File: Assets.xcassets/AppIcon.solidimagestack/Middle.solidimagestacklayer/Contents.json
```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/DarkRed200.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.145",
          "green" : "0.000",
          "red" : "0.600"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/AppIcon.solidimagestack/Contents.json
```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "layers" : [
    {
      "filename" : "Front.solidimagestacklayer"
    },
    {
      "filename" : "Middle.solidimagestacklayer"
    },
    {
      "filename" : "Back.solidimagestacklayer"
    }
  ]
}

```

File: Assets.xcassets/DarkRed050.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.153",
          "green" : "0.027",
          "red" : "0.753"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/DarkRed600.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.063",
          "green" : "0.000",
          "red" : "0.267"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/DarkRed400.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.102",
          "green" : "0.000",
          "red" : "0.424"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/DarkRed800.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.043",
          "green" : "0.000",
          "red" : "0.149"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/gradient400.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "255",
          "green" : "149",
          "red" : "0"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/gradient200.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "255",
          "green" : "209",
          "red" : "104"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/gradient050.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "255",
          "green" : "245",
          "red" : "224"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/gradient600.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.788",
          "green" : "0.000",
          "red" : "0.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/gradient800.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "103",
          "green" : "0",
          "red" : "0"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightBlue050.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "1.000",
          "green" : "0.961",
          "red" : "0.878"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightBlue200.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "1.000",
          "green" : "0.894",
          "red" : "0.682"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightBlue400.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "1.000",
          "green" : "0.820",
          "red" : "0.408"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightBlue600.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "1.000",
          "green" : "0.714",
          "red" : "0.208"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightBlue800.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "1.000",
          "green" : "0.588",
          "red" : "0.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightGreen050.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.875",
          "green" : "0.957",
          "red" : "0.882"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightGreen200.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.702",
          "green" : "0.910",
          "red" : "0.722"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightGreen400.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.443",
          "green" : "0.859",
          "red" : "0.494"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightGreen600.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.247",
          "green" : "0.800",
          "red" : "0.302"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightGreen800.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.004",
          "green" : "0.690",
          "red" : "0.071"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightMustard050.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.831",
          "green" : "0.957",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightMustard200.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.620",
          "green" : "0.890",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightMustard400.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.431",
          "green" : "0.827",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightMustard600.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.133",
          "green" : "0.773",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightMustard800.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.004",
          "green" : "0.651",
          "red" : "0.953"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightRed050.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.914",
          "green" : "0.914",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightRed600.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.412",
          "green" : "0.412",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightRed200.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.800",
          "green" : "0.800",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightRed400.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.588",
          "green" : "0.588",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/LightRed800.colorset/Contents.json
```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.255",
          "green" : "0.196",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/Pfizer_Logo_Color_RGB.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "Pfizer_Logo_Color_RGB.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/Pfizer_Logo_White_RGB.imageset/Pfizer_Logo_White_RGB.png
```png
[Binary file]
```

File: Assets.xcassets/Pfizer_Logo_Color_RGB.imageset/Pfizer_Logo_Color_RGB.png
```png
[Binary file]
```

File: Assets.xcassets/Pfizer_Logo_White_RGB.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "Pfizer_Logo_White_RGB.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/screen.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "screen.jpg",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/tap.imageset/tap.jpg
```jpg
[Binary file]
```

File: Assets.xcassets/tap.imageset/Contents.json
```json
{
  "images" : [
    {
      "filename" : "tap.jpg",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Assets.xcassets/screen.imageset/screen.jpg
```jpg
[Binary file]
```

File: Assets.xcassets/Contents.json
```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Extensions/Entity+Animation.swift
```swift
import Foundation
import RealityKit

extension Entity {
    /// Cancels any pending animation timers for this entity
    func cancelPendingAnimations() {
        // No change needed here
    }
    
    /// Animates the x-scale of an entity from a starting value to an end value over a duration
    /// - Parameters:
    ///   - from: Starting x-scale value (optional - uses current scale if nil)
    ///   - to: Target x-scale value 
    ///   - duration: Animation duration in seconds
    ///   - delay: Optional delay before starting the animation (in seconds)
    ///   - timing: Animation timing curve (default: .easeInOut)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func animateXScale(from start: Float? = nil,
                      to end: Float,
                      duration: TimeInterval,
                      delay: TimeInterval = 0,
                      timing: RealityKit.AnimationTimingFunction = .easeInOut,
                      waitForCompletion: Bool = false) async {
        // Handle delay first, even for immediate changes
        if delay > 0 {
            try? await Task.sleep(for: .seconds(delay))
        }
        
        // For non-animated changes (duration = 0), set immediately
        guard duration > 0 else {
            var newTransform = transform
            newTransform.scale.x = end
            transform = newTransform
            return
        }
        
        // Build and play the animation
        let startTransform = transform
        var endTransform = transform
        endTransform.scale.x = end
        
        let scaleAnimation = FromToByAnimation(
            from: startTransform,
            to: endTransform,
            duration: duration,
            timing: timing,
            bindTarget: .transform
        )
        
        do {
            let resource = try AnimationResource.generate(with: scaleAnimation)
            playAnimation(resource)
            
            // Optionally wait for the animation to complete
            if waitForCompletion {
                try? await Task.sleep(for: .seconds(duration))
            }
        } catch {
            print("⚠️ Could not generate scale animation: \(error.localizedDescription)")
            // Fall back to immediate change
            var newTransform = transform
            newTransform.scale.x = end
            transform = newTransform
        }
    }
    
    /// Animates uniform scale of an entity from a starting value to an end value over a duration
    /// - Parameters:
    ///   - from: Starting scale value (optional - uses current scale if nil)
    ///   - to: Target scale value 
    ///   - duration: Animation duration in seconds
    ///   - delay: Optional delay before starting the animation (in seconds)
    ///   - timing: Animation timing curve (default: cubicBezier with ease-in-out control points)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func animateScale(from start: Float? = nil,
                     to end: Float,
                     duration: TimeInterval,
                     delay: TimeInterval = 0,
                     timing: RealityKit.AnimationTimingFunction = .cubicBezier(controlPoint1: SIMD2<Float>(1.0, 0), controlPoint2: SIMD2<Float>(0.6, 1)),
                     waitForCompletion: Bool = false) async {
        // Handle delay first, even for immediate changes
        if delay > 0 {
            try? await Task.sleep(for: .seconds(delay))
        }
        
        // For non-animated changes (duration = 0), set immediately
        guard duration > 0 else {
            var newTransform = transform
            newTransform.scale = .init(repeating: end)
            transform = newTransform
            return
        }
        
        // Build and play the animation
        let startTransform = transform
        var endTransform = transform
        endTransform.scale = .init(repeating: end)
        
        let scaleAnimation = FromToByAnimation(
            from: startTransform,
            to: endTransform,
            duration: duration,
            timing: timing,
            bindTarget: .transform
        )
        
        do {
            let resource = try AnimationResource.generate(with: scaleAnimation)
            playAnimation(resource)
            
            // Optionally wait for the animation to complete
            if waitForCompletion {
                try? await Task.sleep(for: .seconds(duration))
            }
        } catch {
            print("⚠️ Could not generate scale animation: \(error.localizedDescription)")
            // Fall back to immediate change
            var newTransform = transform
            newTransform.scale = .init(repeating: end)
            transform = newTransform
        }
    }
    
    /// Animates the z-position of an entity relative to its current position
    /// - Parameters:
    ///   - to: Distance to move in z direction (positive = forward, negative = backward)
    ///   - duration: Animation duration in seconds
    ///   - delay: Optional delay before starting the animation (in seconds)
    ///   - timing: Animation timing curve (default: .easeInOut)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func animateZPosition(to relativeZ: Float,
                         duration: TimeInterval,
                         delay: TimeInterval = 0,
                         timing: RealityKit.AnimationTimingFunction = .easeInOut,
                         waitForCompletion: Bool = false) async {
        // Handle delay first, even for immediate changes
        if delay > 0 {
            try? await Task.sleep(for: .seconds(delay))
        }
        
        let startTransform = transform
        var endTransform = transform
        
        // Add relative movement to current position
        endTransform.translation.z = startTransform.translation.z + relativeZ
        
        // For non-animated changes (duration = 0), set immediately
        guard duration > 0 else {
            transform = endTransform
            return
        }
        
        // Build and play the animation
        let positionAnimation = FromToByAnimation(
            from: startTransform,
            to: endTransform,
            duration: duration,
            timing: timing,
            bindTarget: .transform
        )
        
        do {
            let resource = try AnimationResource.generate(with: positionAnimation)
            playAnimation(resource)
            
            // Optionally wait for the animation to complete
            if waitForCompletion {
                try? await Task.sleep(for: .seconds(duration))
            }
        } catch {
            print("⚠️ Could not generate position animation: \(error.localizedDescription)")
            // Fall back to immediate change
            transform = endTransform
        }
    }
    
    /// Animates the position of an entity from its current position to a target position
    /// - Parameters:
    ///   - to: Target position as SIMD3<Float> to add to current position
    ///   - duration: Animation duration in seconds
    ///   - delay: Optional delay before starting the animation (in seconds)
    ///   - timing: Animation timing curve (default: .easeInOut)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func animatePosition(to targetPosition: SIMD3<Float>,
                        duration: TimeInterval,
                        delay: TimeInterval = 0,
                        timing: RealityKit.AnimationTimingFunction = .easeInOut,
                        waitForCompletion: Bool = false) async {
        // Handle delay first, even for immediate changes
        if delay > 0 {
            try? await Task.sleep(for: .seconds(delay))
        }
        
        let startTransform = transform
        var endTransform = transform
        endTransform.translation = startTransform.translation + targetPosition
        
        // For non-animated changes (duration = 0), set immediately
        guard duration > 0 else {
            transform = endTransform
            return
        }
        
        // Build and play the animation
        let positionAnimation = FromToByAnimation(
            from: startTransform,
            to: endTransform,
            duration: duration,
            timing: timing,
            bindTarget: .transform
        )
        
        do {
            let resource = try AnimationResource.generate(with: positionAnimation)
            playAnimation(resource)
            
            // Optionally wait for the animation to complete
            if waitForCompletion {
                try? await Task.sleep(for: .seconds(duration))
            }
        } catch {
            print("⚠️ Could not generate position animation: \(error.localizedDescription)")
            // Fall back to immediate change
            transform = endTransform
        }
    }
    
    /// Animates the Y rotation of an entity from its current rotation to a target angle in degrees
    /// - Parameters:
    ///   - to: Target angle in degrees (positive = clockwise)
    ///   - duration: Animation duration in seconds
    ///   - delay: Optional delay before starting the animation (in seconds)
    ///   - timing: Animation timing curve (default: .easeInOut)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func animateYRotation(to targetDegrees: Float,
                         duration: TimeInterval,
                         delay: TimeInterval = 0,
                         timing: RealityKit.AnimationTimingFunction = .easeInOut,
                         waitForCompletion: Bool = false) async {
        // Handle delay first, even for immediate changes
        if delay > 0 {
            try? await Task.sleep(for: .seconds(delay))
        }
        
        let startTransform = transform
        var endTransform = transform
        
        // Convert degrees to radians and set Y rotation
        let targetRadians = (targetDegrees * .pi) / 180
        endTransform.rotation = simd_quatf(angle: targetRadians, axis: SIMD3<Float>(0, 1, 0))
        
        // For non-animated changes (duration = 0), set immediately
        guard duration > 0 else {
            transform = endTransform
            return
        }
        
        // Build and play the animation
        let rotationAnimation = FromToByAnimation(
            from: startTransform,
            to: endTransform,
            duration: duration,
            timing: timing,
            bindTarget: .transform
        )
        
        do {
            let resource = try AnimationResource.generate(with: rotationAnimation)
            playAnimation(resource)
            
            // Optionally wait for the animation to complete
            if waitForCompletion {
                try? await Task.sleep(for: .seconds(duration))
            }
        } catch {
            print("⚠️ Could not generate rotation animation: \(error.localizedDescription)")
            // Fall back to immediate change
            transform = endTransform
        }
    }
    
    /// Creates a quick squish and bounce scale animation when an entity is hit
    /// - Parameters:
    ///   - intensity: How strong the squish effect should be (default: 0.9)
    ///   - duration: Total duration of the squish and bounce animation (default: 0.3)
    ///   - scaleReduction: The percentage to reduce the current scale by (default: 0.1 = 10%)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func hitScaleAnimation(intensity: Float = 0.9,
                         duration: TimeInterval = 0.3,
                         scaleReduction: Float = 0.1,
                         waitForCompletion: Bool = false) async {
        // Store original scale
        let originalScale = scale
        let targetScale = originalScale * (1.0 - scaleReduction) // Reduce by percentage
        
        // First phase: Quick squish (25% of duration)
        var squishTransform = transform
        squishTransform.scale = originalScale * intensity
        
        // Second phase: Bounce back slightly larger (50% of duration)
        var bounceTransform = transform
        let bounceScale = targetScale * (2.0 - intensity) // Bounce to slightly larger than target
        bounceTransform.scale = bounceScale
        
        // Final phase: Return to target scale (25% of duration)
        var finalTransform = transform
        finalTransform.scale = targetScale
        
        // Create the multi-phase animation
        let squishDuration = duration * 0.25
        let bounceDuration = duration * 0.5
        let returnDuration = duration * 0.25
        
        // Squish phase
        let squishAnimation = FromToByAnimation(
            from: transform,
            to: squishTransform,
            duration: squishDuration,
            timing: .easeIn,
            bindTarget: .transform
        )
        
        // Bounce phase
        let bounceAnimation = FromToByAnimation(
            from: squishTransform,
            to: bounceTransform,
            duration: bounceDuration,
            timing: .easeOut,
            bindTarget: .transform
        )
        
        // Return phase
        let returnAnimation = FromToByAnimation(
            from: bounceTransform,
            to: finalTransform,
            duration: returnDuration,
            timing: .easeInOut,
            bindTarget: .transform
        )
        
        do {
            // Generate and play each phase
            let squishResource = try AnimationResource.generate(with: squishAnimation)
            playAnimation(squishResource, transitionDuration: 0)
            
            if waitForCompletion {
                try await Task.sleep(for: .seconds(squishDuration))
            }
            
            let bounceResource = try AnimationResource.generate(with: bounceAnimation)
            playAnimation(bounceResource, transitionDuration: 0)
            
            if waitForCompletion {
                try await Task.sleep(for: .seconds(bounceDuration))
            }
            
            let returnResource = try AnimationResource.generate(with: returnAnimation)
            playAnimation(returnResource, transitionDuration: 0)
            
            if waitForCompletion {
                try await Task.sleep(for: .seconds(returnDuration))
            }
        } catch {
            print("Failed to create hit scale animation: \(error)")
        }
    }
    
    /// Animates both position and Y rotation of an entity simultaneously
    /// - Parameters:
    ///   - position: Target position as SIMD3<Float> to add to current position
    ///   - rotation: Target Y rotation in degrees (positive = clockwise)
    ///   - duration: Animation duration in seconds
    ///   - delay: Optional delay before starting the animation (in seconds)
    ///   - timing: Animation timing curve (default: .easeInOut)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func animatePositionAndRotation(position: SIMD3<Float>,
                                  rotation: Float,
                                  duration: TimeInterval,
                                  delay: TimeInterval = 0,
                                  timing: RealityKit.AnimationTimingFunction = .easeInOut,
                                  waitForCompletion: Bool = false) async {
        // Handle delay first, even for immediate changes
        if delay > 0 {
            try? await Task.sleep(for: .seconds(delay))
        }
        
        let startTransform = transform
        var endTransform = transform
        
        // Set both position and rotation in the end transform
        endTransform.translation = startTransform.translation + position
        let rotationRadians = (rotation * .pi) / 180
        endTransform.rotation = simd_quatf(angle: rotationRadians, axis: SIMD3<Float>(0, 1, 0))
        
        // For non-animated changes (duration = 0), set immediately
        guard duration > 0 else {
            transform = endTransform
            return
        }
        
        // Build and play the animation
        let combinedAnimation = FromToByAnimation(
            from: startTransform,
            to: endTransform,
            duration: duration,
            timing: timing,
            bindTarget: .transform
        )
        
        do {
            let resource = try AnimationResource.generate(with: combinedAnimation)
            playAnimation(resource)
            
            // Optionally wait for the animation to complete
            if waitForCompletion {
                try? await Task.sleep(for: .seconds(duration))
            }
        } catch {
            print("⚠️ Could not generate combined animation: \(error.localizedDescription)")
            // Fall back to immediate change
            transform = endTransform
        }
    }
    
    /// Starts continuous rotation around the specified axis
    /// - Parameters:
    ///   - speed: Rotation speed in radians per second (default: 1.0)
    ///   - axis: The axis to rotate around (default: .yAxis)
    func startContinuousRotation(speed: Float = 1.0, axis: RotationAxis = .yAxis) {
        var component = RotationComponent()
        component.speed = speed
        component.rotationAxis = axis
        components.set(component)
    }
    
    /// Starts continuous rotation around the Y axis (legacy support)
    /// - Parameter speed: Rotation speed in radians per second (default: 1.0)
    func startContinuousYRotation(speed: Float = 1.0) {
        startContinuousRotation(speed: speed, axis: .yAxis)
    }
    
    /// Stops any continuous rotation by removing the RotationComponent
    func stopRotation() {
        components.remove(RotationComponent.self)
    }
    
    /// Animates the entity's absolute position and scale from its current state to a target state.
    /// - Parameters:
    ///   - targetPosition: The absolute target position (default: [0, 0, 0])
    ///   - targetScale: The absolute target scale (default: [1, 1, 1])
    ///   - duration: Animation duration in seconds
    ///   - delay: Optional delay before starting the animation (in seconds)
    ///   - timing: Animation timing curve (default: .easeInOut)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func animateAbsolutePositionAndScale(to targetPosition: SIMD3<Float> = SIMD3<Float>(0, 0, 0),
                                           scale targetScale: SIMD3<Float> = SIMD3<Float>(1, 1, 1),
                                           duration: TimeInterval,
                                           delay: TimeInterval = 0,
                                           timing: RealityKit.AnimationTimingFunction = .easeInOut,
                                           waitForCompletion: Bool = false) async {
        // Handle delay first
        if delay > 0 {
            try? await Task.sleep(for: .seconds(delay))
        }
        
        let startTransform = transform
        var endTransform = transform
        // Set absolute target values
        endTransform.translation = targetPosition
        endTransform.scale = targetScale
        
        // For non-animated changes (duration = 0), apply the transform immediately
        guard duration > 0 else {
            transform = endTransform
            return
        }
        
        // Build the animation using FromToByAnimation, animating the entire transform
        let animation = FromToByAnimation(
            from: startTransform,
            to: endTransform,
            duration: duration,
            timing: timing,
            bindTarget: .transform
        )
        
        do {
            let resource = try AnimationResource.generate(with: animation)
            playAnimation(resource)
            
            // Optionally wait for the animation to complete
            if waitForCompletion {
                try? await Task.sleep(for: .seconds(duration))
            }
        } catch {
            print("⚠️ Could not generate absolute position and scale animation: \(error.localizedDescription)")
            // Fall back to directly setting the transform
            transform = endTransform
        }
    }
    
    /// Animates the entity's absolute position from its current position to a target position.
    /// - Parameters:
    ///   - targetPosition: The absolute target position
    ///   - duration: Animation duration in seconds
    ///   - delay: Optional delay before starting the animation (in seconds)
    ///   - timing: Animation timing curve (default: .easeInOut)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func animateAbsolutePosition(to targetPosition: SIMD3<Float>,
                                duration: TimeInterval,
                                delay: TimeInterval = 0,
                                timing: RealityKit.AnimationTimingFunction = .easeInOut,
                                waitForCompletion: Bool = false) async {
        // Handle delay first
        if delay > 0 {
            try? await Task.sleep(for: .seconds(delay))
        }
        
        let startTransform = transform
        var endTransform = transform
        // Set absolute target position
        endTransform.translation = targetPosition
        
        // For non-animated changes (duration = 0), apply the transform immediately
        guard duration > 0 else {
            transform = endTransform
            return
        }
        
        // Build the animation using FromToByAnimation
        let animation = FromToByAnimation(
            from: startTransform,
            to: endTransform,
            duration: duration,
            timing: timing,
            bindTarget: .transform
        )
        
        do {
            let resource = try AnimationResource.generate(with: animation)
            playAnimation(resource)
            
            // Optionally wait for the animation to complete
            if waitForCompletion {
                try? await Task.sleep(for: .seconds(duration))
            }
        } catch {
            print("⚠️ Could not generate absolute position animation: \(error.localizedDescription)")
            // Fall back to directly setting the transform
            transform = endTransform
        }
    }
    
    /// Triggers a head position update for an entity with a PositioningComponent
    /// - Parameters:
    ///   - animated: Whether to animate the position change
    ///   - duration: Animation duration in seconds (only used if animated is true)
    func checkHeadPosition(animated: Bool = false, duration: TimeInterval = 0.5) {
        guard var positioningComponent = components[PositioningComponent.self] else {
            Logger.debug("⚠️ Cannot check head position: No PositioningComponent found on entity '\(name)'")
            return 
        }
        
        Logger.debug("""
        
        🎯 Requesting head position update for entity '\(name)'
        ├─ Current World Position: \(position(relativeTo: nil))
        ├─ Offsets: [\(positioningComponent.offsetX), \(positioningComponent.offsetY), \(positioningComponent.offsetZ)]
        ├─ Animated: \(animated ? "✅" : "❌")
        └─ Duration: \(animated ? "\(duration)s" : "immediate")
        """)
        
        positioningComponent.needsPositioning = true
        positioningComponent.shouldAnimate = animated
        positioningComponent.animationDuration = animated ? duration : 0.0
        components[PositioningComponent.self] = positioningComponent
    }
}

```

File: Extensions/Entity+Audio.swift
```swift
import RealityKit

extension Entity {
    
    /// Enables a large room reverb effect on the entity.
    func enableLargeRoomReverb() {
        // Create the ReverbComponent with the large room preset.
        let largeRoomReverb = ReverbComponent(reverb: .preset(.largeRoom))
        // Attach the reverb component to the entity.
        self.components.set(largeRoomReverb)
    }
    
    /// Disables any active reverb effect on the entity.
    func disableReverb() {
        // Remove the ReverbComponent from the entity.
        self.components.remove(ReverbComponent.self)
    }
}

```

File: Extensions/Entity+AudioSystem.swift
```swift
import Foundation
import RealityKit
import OSLog

// If using Apple's new Observation framework, uncomment the following import
// import Observation

/// A reusable audio system that can be attached to any RealityKit Entity.
/// It supports both spatial and channel-based audio playback, resource loading from RCP packages, and simple playback control.
@Observable
@MainActor  // Make the entire class MainActor-isolated
final class EntityAudioSystem: @unchecked Sendable {  // Make the class Sendable
    // MARK: - Properties
    let entity: Entity
    var spatialAudioEnabled: Bool
    var gain: Float
    var focus: Float

    /// New properties for spatial offset
    var positionOffset: SIMD3<Float> = .zero
    var rotationOffset: simd_quatf = simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0))  // Identity rotation

    /// Private anchor entity used for audio playback when spatial audio is enabled
    private var audioAnchor: Entity

    /// Dictionary to hold loaded audio resources keyed by their names.
    var loadedAudioResources: [String: AudioFileResource] = [:]

    /// Controller for the currently playing audio, if any.
    var currentAudioPlayback: AudioPlaybackController?
    var currentAudioName: String?

    var isPlaying: Bool = false
    var playbackProgress: Double = 0.0

    // MARK: - Initialization
    init(entity: Entity, spatialAudioEnabled: Bool = true, gain: Float = 1.0, focus: Float = 1.0) {
        self.entity = entity
        self.spatialAudioEnabled = spatialAudioEnabled
        self.gain = gain
        self.focus = focus

        // Create a child anchor entity for audio playback
        self.audioAnchor = Entity()
        // Set initial transform using positionOffset and rotationOffset, using the order: scale, rotation, translation
        self.audioAnchor.transform = Transform(scale: .one, rotation: rotationOffset, translation: positionOffset)
        // Add the audioAnchor as a child of the main entity
        entity.addChild(audioAnchor)

        // If spatial audio is enabled, add a SpatialAudioComponent to the audioAnchor if not already present.
        if spatialAudioEnabled, !audioAnchor.components.has(SpatialAudioComponent.self) {
            audioAnchor.components.set(SpatialAudioComponent(
                gain: Double(gain),
                directivity: .beam(focus: Double(focus))
            ))
        }
    }

    // MARK: - Audio Resource Loading
    /// Loads an audio resource from the specified source and bundle.
    /// - Parameters:
    ///   - audioName: The name of the audio file (e.g. "bubblepop_mp3").
    ///   - source: The asset source, which can be a scene name (e.g. "antibodyScene.usda") or folder name in the RCP package.
    ///   - bundle: The bundle containing the audio asset.
    ///
    /// The resource is stored keyed by `audioName`.
    func loadAudio(named audioName: String, from source: String, in bundle: Bundle) async throws {
        let resource = try await AudioFileResource(named: "/Root/\(audioName)", from: source, in: bundle)
        loadedAudioResources[audioName] = resource
        Logger.audio("Loaded audio resource: \(audioName)")
    }

    // MARK: - Playback Control
    /// Plays the audio corresponding to `audioName`.
    /// If another audio is already playing, it is stopped first.
    /// - Parameters:
    ///   - audioName: The key for the loaded audio resource.
    ///   - duration: Optional duration for playback progress tracking (defaults to 5 seconds if not provided).
    func play(audioNamed audioName: String, duration: Double? = nil) async throws {
        guard let resource = loadedAudioResources[audioName] else {
            throw NSError(domain: "EntityAudioSystem", code: -1, userInfo: [NSLocalizedDescriptionKey: "Audio resource \(audioName) not loaded"])
        }

        Logger.audio("Resource for \(audioName) found: \(resource)")

        // Stop current audio if playing
        if isPlaying {
            stop()
        }

        Logger.audio("Preparing playback controller for \(audioName)")
        // Prepare audio using the audioAnchor's prepareAudio method
        let playbackController = audioAnchor.prepareAudio(resource)
        currentAudioPlayback = playbackController
        currentAudioName = audioName
        isPlaying = true
        playbackProgress = 0.0

        // Create a weak reference to self for the completion handler
        weak var weakSelf = self
        
        // Set completion handler on main actor
        playbackController.completionHandler = {
            Task { @MainActor in
                guard let self = weakSelf else { return }
                Logger.audio("Audio \(audioName) completed playback")
                self.isPlaying = false
                self.playbackProgress = 1.0
                self.currentAudioPlayback = nil
            }
        }

        Logger.audio("Calling playbackController.play() for \(audioName)")
        playbackController.play()
        Logger.audio("Called playbackController.play() for \(audioName)")

        // Track playback progress if a duration is provided
        let totalDuration = duration ?? 5.0
        let startTime = Date()
        
        // Create a separate Task for progress tracking
        Task { @MainActor in
            guard let self = weakSelf else { return }
            while self.isPlaying {
                let elapsed = Date().timeIntervalSince(startTime)
                // Log progress every second approximately
                if Int(elapsed) % 1 == 0 {
                    Logger.audio("Playback progress for \(audioName): \(self.playbackProgress * 100)% after \(Int(elapsed))s")
                }
                self.playbackProgress = min(elapsed / totalDuration, 1.0)
                try? await Task.sleep(nanoseconds: 16_000_000) // ~60fps
            }
        }
    }

    /// Stops the current audio playback if any.
    func stop() {
        if let controller = currentAudioPlayback, isPlaying {
            controller.stop()
            isPlaying = false
            playbackProgress = 0.0
            currentAudioPlayback = nil
            Logger.audio("Stopped audio playback")
        }
    }

    // MARK: - Configuration Updates
    /// Updates the gain value used for spatial audio. This will affect future playback.
    func updateGain(newGain: Float) {
        gain = newGain
        Logger.audio("Updated gain to \(newGain)")
        if spatialAudioEnabled {
            if audioAnchor.components.has(SpatialAudioComponent.self) {
                audioAnchor.components.remove(SpatialAudioComponent.self)
                audioAnchor.components.set(SpatialAudioComponent(
                    gain: Double(newGain),
                    directivity: .beam(focus: Double(focus))
                ))
                Logger.audio("Reattached SpatialAudioComponent with updated gain")
            }
        }
    }

    /// Updates the focus value (directivity) for spatial audio. This will affect future playback.
    func updateFocus(newFocus: Float) {
        focus = newFocus
        Logger.audio("Updated focus to \(newFocus)")
        if spatialAudioEnabled {
            if audioAnchor.components.has(SpatialAudioComponent.self) {
                audioAnchor.components.remove(SpatialAudioComponent.self)
                audioAnchor.components.set(SpatialAudioComponent(
                    gain: Double(gain),
                    directivity: .beam(focus: Double(newFocus))
                ))
                Logger.audio("Reattached SpatialAudioComponent with updated focus")
            }
        }
    }

    /// Updates the position offset for the audio playback. This adjusts the local position of the audio anchor.
    func updatePositionOffset(newOffset: SIMD3<Float>) {
        positionOffset = newOffset
        updateAudioAnchorTransform()
        Logger.audio("Updated audio position offset to \(newOffset)")
    }

    /// Updates the rotation offset for the audio playback. This adjusts the local rotation of the audio anchor.
    func updateRotationOffset(newRotation: simd_quatf) {
        rotationOffset = newRotation
        updateAudioAnchorTransform()
        Logger.audio("Updated audio rotation offset")
    }

    /// Helper method to update the audioAnchor's transform with the current offset and rotation.
    private func updateAudioAnchorTransform() {
        audioAnchor.transform = Transform(scale: .one, rotation: rotationOffset, translation: positionOffset)
    }

    // MARK: - Cleanup
    /// Stops any ongoing audio and clears loaded resources. Also removes any spatial audio components and the audio anchor added by this system.
    func cleanup() {
        stop()
        loadedAudioResources.removeAll()
        if spatialAudioEnabled, audioAnchor.components.has(SpatialAudioComponent.self) {
            audioAnchor.components.remove(SpatialAudioComponent.self)
        }
        audioAnchor.removeFromParent()
        Logger.audio("Audio system cleanup completed")
    }
}

// MARK: - Entity Extension
extension Entity {
    /// Attaches a new EntityAudioSystem to the entity.
    /// - Parameters:
    ///   - spatial: Enables spatial audio if true. Defaults to true.
    ///   - gain: Initial gain value for spatial audio. Defaults to 1.0.
    ///   - focus: Initial focus value for spatial audio. Defaults to 1.0.
    /// - Returns: A new instance of EntityAudioSystem configured with the provided parameters.
    func attachAudioSystem(spatial: Bool = true, gain: Float = 1.0, focus: Float = 1.0) -> EntityAudioSystem {
        return EntityAudioSystem(entity: self, spatialAudioEnabled: spatial, gain: gain, focus: focus)
    }
} 

```

File: Extensions/Entity+Opacity.swift
```swift
import Foundation
import RealityKit

extension Entity {
    /// The opacity value applied to the entity and its descendants.
    ///
    /// `OpacityComponent` is assigned to the entity if it doesn't already exist.
    var opacity: Float {
        get {
            return components[OpacityComponent.self]?.opacity ?? 1
        }
        set {
            if !components.has(OpacityComponent.self) {
                components[OpacityComponent.self] = OpacityComponent(opacity: newValue)
            } else {
                components[OpacityComponent.self]?.opacity = newValue
            }
        }
    }
    
    /// Fades the entity's opacity to a target value with optional animation.
    /// Returns after the animation completes, including any delay.
    ///
    /// - Parameters:
    ///   - targetOpacity: Target opacity value (0.0 to 1.0)
    ///   - duration: Animation duration in seconds (default: 1.0)
    ///   - delay: Optional delay before starting the animation (in seconds)
    ///   - timing: Animation timing curve (default: .easeInOut)
    ///   - waitForCompletion: If true, waits for the animation to complete before returning
    func fadeOpacity(to targetOpacity: Float,
                    duration: TimeInterval = 1.0,
                    delay: TimeInterval = 0,
                    timing: RealityKit.AnimationTimingFunction = .easeInOut,
                    waitForCompletion: Bool = false) async {
        // Handle delay first, even for immediate changes
        if delay > 0 {
            try? await Task.sleep(for: .seconds(delay))
        }
        
        // For non-animated changes (duration = 0), set immediately
        guard duration > 0 else {
            self.opacity = targetOpacity
            return
        }
        
        // Build and play the animation
        let startOpacity = self.opacity
        let fadeAnimation = FromToByAnimation(
            from: startOpacity,
            to: targetOpacity,
            duration: duration,
            timing: timing,
            bindTarget: .opacity
        )
        
        do {
            let animationResource = try AnimationResource.generate(with: fadeAnimation)
            playAnimation(animationResource)
            
            // Optionally wait for the animation to complete
            if waitForCompletion {
                try? await Task.sleep(for: .seconds(duration))
            }
        } catch {
            print("⚠️ Could not generate opacity animation: \(error.localizedDescription)")
            // Fall back to immediate change
            self.opacity = targetOpacity
        }
    }
}

```

File: Extensions/Entity+Trace.swift
```swift
//
//  Entity+Trace.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 12/30/24.
//


/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
Convenience methods for drawing a trace behind a satellite.
*/

import SwiftUI
import RealityKit

extension Entity {
    /// Resets all the elements of a trace.
    func resetTrace(recursive: Bool = false) {
        if var trace: TraceComponent = components[TraceComponent.self] {
            trace.mesh.positions.removeAll()
            trace.model?.removeFromParent()
            trace.model = nil
            self.components[TraceComponent.self] = trace
        }
        if recursive {
            for child in children {
                child.resetTrace(recursive: recursive)
            }
        }
    }

    /// Updates the configuration of a trace.
    func updateTrace(
        anchor: Entity,
        width: Float,
        isVisible: Bool,
        isPaused: Bool
    ) {
        if isVisible {
            if !components.has(TraceComponent.self) {
                components.set(TraceComponent(anchor: anchor, width: width))
            } else if var trace: TraceComponent = components[TraceComponent.self] {
                trace.isPaused = isPaused
                trace.mesh.width = width
                components[TraceComponent.self] = trace
            }
        } else {
            if let trace: TraceComponent = components[TraceComponent.self] {
                trace.model?.removeFromParent()
            }
            components[TraceComponent.self] = nil
        }
    }
}

```

File: Extensions/Entity+Find.swift
```swift
//
//  Entity+Find.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 05.02.25.
//

import RealityKit

extension Entity {
    /// Recursively searches for a component of the specified type in the entity hierarchy.
    func findComponent<T>(ofType type: T.Type) -> T? where T: Component {
        // Check if the component exists on this entity.
        if let component = self.components[ type ] {
            return component
        }
        // Otherwise, search the parent recursively.
        return self.parent?.findComponent(ofType: type)
    }
}

```

File: Extensions/Transitions.swift
```swift
//
//  Twirl.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/9/25.
//
import SwiftUI

struct Appear: Transition {
    func body(content: Content, phase: TransitionPhase) -> some View {
        // We'll treat `.didDisappear` as the "disappearing" phase
        // and disable hit-testing at that time so it doesn't block taps.
        let isDisappearing = (phase == .didDisappear)
        
        return content
            .allowsHitTesting(!isDisappearing) // disable in removal phase
            .scaleEffect(phase.isIdentity ? 1 : 0.5)
            .opacity(phase.isIdentity ? 1 : 0)
            .blur(radius: phase.isIdentity ? 0 : 10)
            // For insertion phase: let’s flash brightness
            .brightness(phase == .willAppear ? 1 : 0)
    }
}



```

File: Extensions/EnvironmentResource.swift
```swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension of the environment resource class to create an environment resource from an image URL.
*/

import RealityKit
import Foundation
import CoreImage

extension EnvironmentResource {
    /// Asynchronously generates an environment resource from an image URL.
    convenience init(fromImage url: URL) async throws {
        // Reads the image source from the URL.
        guard let source = CGImageSourceCreateWithURL(url as CFURL, nil) else {
            fatalError("Failed to load image from \(url)")
        }

        // Create an image object with the image source.
        guard let image = CGImageSourceCreateImageAtIndex(source, 0, nil) else {
            fatalError("Failed to load image from \(url)")
        }

        // Creates the environment resource with the image.
        try await self.init(equirectangular: image)
    }
}

```

File: Extensions/WordByWordTransition.swift
```swift
import SwiftUI

extension Text.Layout {
    /// A helper function for easier access to all runs in a layout.
    var flattenedRuns: some RandomAccessCollection<Text.Layout.Run> {
        self.flatMap { line in
            line
        }
    }

    /// A helper function for easier access to all run slices in a layout.
    var flattenedRunSlices: some RandomAccessCollection<Text.Layout.RunSlice> {
        flattenedRuns.flatMap(\.self)
    }
}

struct WordByWordTransition: Transition {
    var totalDuration: Double = 0.9
    var elementDuration: Double = 0.4
    var extraBounce: Double = 0.2
    
    static var properties: TransitionProperties {
        TransitionProperties(hasMotion: true)
    }
    
    func body(content: Content, phase: TransitionPhase) -> some View {
        let elapsedTime = phase.isIdentity ? totalDuration : 0
        let renderer = WordAnimationRenderer(
            elapsedTime: elapsedTime,
            elementDuration: elementDuration,
            totalDuration: totalDuration,
            extraBounce: extraBounce
        )
        
        content.transaction { transaction in
            if !transaction.disablesAnimations {
                transaction.animation = .linear(duration: totalDuration)
            }
        } body: { view in
            view.textRenderer(renderer)
        }
    }
}

struct WordAnimationRenderer: TextRenderer, Animatable {
    var elapsedTime: TimeInterval
    var elementDuration: TimeInterval
    var totalDuration: TimeInterval
    var extraBounce: Double
    
    var spring: Spring {
        .snappy(duration: elementDuration - 0.05, extraBounce: extraBounce)
    }
    
    var animatableData: Double {
        get { elapsedTime }
        set { elapsedTime = newValue }
    }
    
    func draw(layout: Text.Layout, in context: inout GraphicsContext) {
        for run in layout.flattenedRuns {
            let delay = elementDelay(count: run.count)
            
            for (index, slice) in run.enumerated() {
                let timeOffset = TimeInterval(index) * delay
                let elementTime = max(0, min(elapsedTime - timeOffset, elementDuration))
                
                var copy = context
                draw(slice, at: elementTime, in: &copy)
            }
        }
    }
    
    func draw(_ slice: Text.Layout.RunSlice, at time: TimeInterval, in context: inout GraphicsContext) {
        let progress = time / elementDuration
        let opacity = UnitCurve.easeIn.value(at: progress)
        let blurRadius = slice.typographicBounds.rect.height / 16 * UnitCurve.easeIn.value(at: 1 - progress)
        
        let translationY = spring.value(
            fromValue: slice.typographicBounds.descent,
            toValue: 0,
            initialVelocity: 0,
            time: time
        )
        
        context.translateBy(x: 0, y: translationY)
        context.addFilter(.blur(radius: blurRadius))
        context.opacity = opacity
        context.draw(slice)
    }
    
    func elementDelay(count: Int) -> TimeInterval {
        let count = TimeInterval(count)
        let remainingTime = totalDuration - count * elementDuration
        return max(remainingTime / (count + 1), (totalDuration - elementDuration) / count)
    }
}

struct EmphasisAttribute: TextAttribute {} 
```

File: Extensions/View+WordAnimation.swift
```swift
//import SwiftUI
//
//extension View {
//    /// Animates text word by word with a fade and upward movement
//    func animateWords(
//        text: String,
//        isAnimating: Bool = true,
//        startDelay: Double = 0.5,
//        wordDelay: Double = 0.3,
//        animationDuration: Double = 0.6
//    ) -> some View {
//        self.modifier(
//            WordAnimationModifier(
//                text: text,
//                isAnimating: isAnimating,
//                startDelay: startDelay,
//                wordDelay: wordDelay,
//                animationDuration: animationDuration
//            )
//        )
//    }
//}
//
//private struct WordAnimationModifier: ViewModifier {
//    let text: String
//    let isAnimating: Bool
//    let startDelay: Double
//    let wordDelay: Double
//    let animationDuration: Double
//    
//    @State private var words: [(word: String, opacity: Double, offset: Double)] = []
//    
//    init(text: String, isAnimating: Bool, startDelay: Double, wordDelay: Double, animationDuration: Double) {
//        self.text = text
//        self.isAnimating = isAnimating
//        self.startDelay = startDelay
//        self.wordDelay = wordDelay
//        self.animationDuration = animationDuration
//        
//        // Initialize words with starting values
//        let initialWords = text.split(separator: " ").map { 
//            (String($0), 0.0, 20.0)
//        }
//        _words = State(initialValue: initialWords)
//    }
//    
//    func body(content: Content) -> some View {
//        // Extract the font from the content if possible
//        let contentFont = (content as? Text)?.font ?? .body
//        
//        HStack(spacing: 8) {
//            ForEach(Array(words.enumerated()), id: \.offset) { index, word in
//                Text(word.word)
//                    .font(contentFont)
//                    .opacity(word.opacity)
//                    .offset(y: word.offset)
//            }
//        }
//        .onAppear {
//            guard isAnimating else {
//                words = words.map { ($0.word, 1.0, 0.0) }
//                return
//            }
//            
//            for (index, _) in words.enumerated() {
//                let delay = startDelay + (Double(index) * wordDelay)
//                
//                withAnimation(.easeOut(duration: animationDuration).delay(delay)) {
//                    words[index].opacity = 1.0
//                    words[index].offset = 0.0
//                }
//            }
//        }
//    }
//} 

```

File: Extensions/View+SelectorAnimation.swift
```swift
import SwiftUI

extension View {
    /// Applies a consistent scale and fade animation for selector views
    /// - Parameter isVisible: Boolean indicating if the selector should be visible
    func selectorAnimation(isVisible: Bool) -> some View {
        modifier(SelectorAnimationModifier(isVisible: isVisible))
    }
}

/// A view modifier that provides consistent scale and fade animations for selector views
private struct SelectorAnimationModifier: ViewModifier {
    let isVisible: Bool
    @State private var scale: CGFloat = 0.8
    @State private var opacity: Double = 0
    
    func body(content: Content) -> some View {
        content
            .scaleEffect(scale)
            .opacity(opacity)
            .onChange(of: isVisible) { oldValue, newValue in
                if newValue {
                    withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {
                        scale = 1
                        opacity = 1
                    }
                } else {
                    withAnimation(.easeIn(duration: 0.3)) {
                        scale = 0.8
                        opacity = 0
                    }
                }
            }
    }
} 
```

File: FollowSystemAndComponent/FollowSystem.swift
```swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
The system for following the device's position and updating the entity to move each time the scene rerenders.
*/

import RealityKit
import SwiftUI
import ARKit

/// A system that moves entities to the device's transform each time the scene rerenders.
public struct FollowSystem: System {
    static let query = EntityQuery(where: .has(FollowComponent.self))
    private let arkitSession = ARKitSession()
    private let worldTrackingProvider = WorldTrackingProvider()
    
    public init(scene: RealityKit.Scene) {
        runSession()
    }
    
    func runSession() {
        Task {
            do {
                try await arkitSession.run([worldTrackingProvider])
            } catch {
                print("Error: \(error). Head-position mode will still work.")
            }
        }
    }
    
    public func update(context: SceneUpdateContext) {
        // Check whether the world-tracking provider is running.
        guard worldTrackingProvider.state == .running else { return }
        
        // Query the device anchor at the current time.
        guard let deviceAnchor = worldTrackingProvider.queryDeviceAnchor(atTimestamp: CACurrentMediaTime()) else { return }
        
        // Find the transform of the device.
        let deviceTransform = Transform(matrix: deviceAnchor.originFromAnchorTransform)
    
        // Iterate through each entity in the scene containing `FollowComponent`.
        let entities = context.entities(matching: Self.query, updatingSystemWhen: .rendering)
        
        for entity in entities {
            // Move the entity to the device's transform.
            entity.move(to: deviceTransform, relativeTo: entity.parent, duration: 1.2, timingFunction: .easeInOut)
        }
    }
}

```

File: FollowSystemAndComponent/FollowComponent.swift
```swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
The component for following the device.
*/

import RealityKit
import SwiftUI
import ARKit

/// A component to add to any entity that you want to move with the device's transform.
public struct FollowComponent: Component, Codable {}

```

File: FollowSystemAndComponent/PositioningComponent.swift
```swift
/*
See the LICENSE.txt file for this sample's licensing information.

Abstract:
The component for following the device.
*/

import Foundation
import RealityKit
import SwiftUI
import ARKit

/// A component to add to any entity that you want to move with the device's transform.
public struct PositioningComponent: Component, Codable {
    var offsetX: Float
    var offsetY: Float
    var offsetZ: Float
    var needsPositioning: Bool
    var shouldAnimate: Bool
    var animationDuration: TimeInterval
    var isAnimating: Bool
    
    public init(
        offsetX: Float = 0.0,
        offsetY: Float = 0.0,
        offsetZ: Float = 0.0,
        needsPositioning: Bool = true,
        shouldAnimate: Bool = false,
        animationDuration: TimeInterval = 0.5,
        isAnimating: Bool = false
    ) {
        self.offsetX = offsetX
        self.offsetY = offsetY
        self.offsetZ = offsetZ
        self.needsPositioning = needsPositioning
        self.shouldAnimate = shouldAnimate
        self.animationDuration = animationDuration
        self.isAnimating = isAnimating
    }
}

```

File: FollowSystemAndComponent/HeadPositionTracker.swift
```swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An object that enables world tracking and retrieves the transform of the device.
*/

import SwiftUI
import ARKit
import RealityKit

enum WorldTrackingError: Error {
    case trackingFailed
}

/// The `HeadPositionTracker` class starts a world-tracking session and gets the device's pose and anchors.
@Observable class HeadPositionTracker {
    /// The instance of the `ARKitSession` for world tracking.
    let arSession = ARKitSession()
    
    /// The instance of a new `WorldTrackingProvider` for world tracking.
    let worldTracking = WorldTrackingProvider()

    /// Simple private property since this is internal state
    private var isInitialized = false
    
    /// The initializer for the tracker to check through the requirements for world tracking
    /// and start the world-tracking session.
    init() {
        // Remove initialization from init
    }
    
    /// Ensure the tracker is initialized
    func ensureInitialized() async throws {
        // If already initialized, return immediately
        guard !isInitialized else { return }
        
        // Check whether the device supports world tracking
        guard WorldTrackingProvider.isSupported else {
            print("WorldTrackingProvider is not supported on this device")
            throw WorldTrackingError.trackingFailed
        }
        
        do {
            // Attempt to start an ARKit session with the world-tracking provider
            try await arSession.run([worldTracking])
            print("Successfully started ARKit session with world tracking")
            
            // Wait a short moment for the world tracking to fully initialize
            try await Task.sleep(nanoseconds: 500_000_000) // 500ms
            
            isInitialized = true
        } catch let error as ARKitSession.Error {
            print("Encountered an error while running providers: \(error.localizedDescription)")
            throw error
        } catch {
            print("Encountered an unexpected error: \(error.localizedDescription)")
            throw error
        }
    }
    
    /// Get the current position of the device.
    func originFromDeviceTransform() -> simd_float4x4? {
        /// The anchor of the device at the current time.
        guard let deviceAnchor = worldTracking.queryDeviceAnchor(atTimestamp: CACurrentMediaTime()) else {
            return nil
        }
            
        // Return the device's transform.
        return deviceAnchor.originFromAnchorTransform
    }
    
    /// Position an entity relative to the user based on the current device transform
    /// - Parameters:
    ///   - entity: The entity to position
    ///   - offset: The offset vector relative to the user's position (default: [0, 0, -1])
    func positionEntityRelativeToUser(_ entity: Entity?, offset: SIMD3<Float> = [0, 0, -1]) {
        if let deviceTransform = originFromDeviceTransform() {
            let translation = deviceTransform.translation()
            print("positioning entity according to device transform")
            entity?.setPosition([
                translation.x + offset.x,
                translation.y + offset.y,
                translation.z + offset.z
            ], relativeTo: nil)
        }
    }
    
    /// Convenience method to position an entity directly in front of the user
    /// - Parameters:
    ///   - entity: The entity to position
    ///   - distance: Distance in front of the user (negative values are forward)
    func positionEntityInFrontOfUser(_ entity: Entity?, distance: Float = -1.0) {
        positionEntityRelativeToUser(entity, offset: [0, 0, distance])
    }
}

```

File: FollowSystemAndComponent/PositioningSystem.swift
```swift
/*
See the LICENSE.txt file for this sample's licensing information.

Abstract:
The system for following the device's position and updating the entity to move each time the scene rerenders.
*/

import Foundation
import RealityKit
import SwiftUI
import ARKit

/// A system that moves entities to the device's transform each time the scene rerenders.
@MainActor
public class PositioningSystem: System {
    // MARK: - Static Properties
    static let query = EntityQuery(where: .has(PositioningComponent.self))
    private static var sharedAppModel: AppModel?
    private let systemId = UUID()
    
    // Static method to set AppModel
    static func setAppModel(_ appModel: AppModel) {
        Logger.debug("🔄 PositioningSystem.setAppModel called")
        sharedAppModel = appModel
    }
    
    // MARK: - System Initialization
    public required init(scene: RealityKit.Scene) {
        Logger.debug("🎯 PositioningSystem \(systemId) initializing...")
    }
    
    // MARK: - System Update
    public func update(context: SceneUpdateContext) {
        // Get device anchor from TrackingSessionManager's worldTrackingProvider
        guard let appModel = Self.sharedAppModel else {
            // Only log if AppModel is missing, as this indicates a setup issue
            Logger.error("❌ PositioningSystem: Missing AppModel reference")
            return
        }
        
        // Skip silently if tracking isn't running or no device anchor available
        guard case .running = appModel.trackingManager.worldTrackingProvider.state,
              let deviceAnchor = appModel.trackingManager.worldTrackingProvider.queryDeviceAnchor(atTimestamp: CACurrentMediaTime()) else {
            return
        }
        
        // Position entities that need positioning
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            guard var positioningComponent = entity.components[PositioningComponent.self],
                  positioningComponent.needsPositioning,
                  !positioningComponent.isAnimating else { continue }
            
            // Only log if we're not already animating
            if !positioningComponent.isAnimating {
                Logger.debug("""
                
                🔄 Starting position update for entity '\(entity.name)'
                ├─ Current Position: \(entity.position(relativeTo: nil))
                ├─ Animated: \(positioningComponent.shouldAnimate ? "✅" : "❌")
                └─ Duration: \(positioningComponent.animationDuration)s
                """)
            }
            
            Task {
                // Set animating state immediately
                positioningComponent.isAnimating = true
                entity.components[PositioningComponent.self] = positioningComponent
                
                if await tryPositionEntity(entity: entity, component: &positioningComponent, deviceAnchor: deviceAnchor) {
                    // Wait for animation
                    if positioningComponent.shouldAnimate {
                        try? await Task.sleep(for: .seconds(positioningComponent.animationDuration))
                    }
                    
                    // Update final state
                    positioningComponent.isAnimating = false
                    positioningComponent.needsPositioning = false
                    entity.components[PositioningComponent.self] = positioningComponent
                    
                    Logger.debug("""
                    
                    ✨ Position update complete for '\(entity.name)'
                    ├─ Final Position: \(entity.position(relativeTo: nil))
                    └─ Status: Success
                    """)
                }
            }
        }
    }
    
    // MARK: - Entity Positioning
    private func tryPositionEntity(entity: Entity, component: inout PositioningComponent, deviceAnchor: DeviceAnchor) async -> Bool {
        let deviceTransform = deviceAnchor.originFromAnchorTransform
        let devicePosition = deviceTransform.translation()
        
        // Validate translation values
        let minValidDistance: Float = 0.3  // Minimum 0.3 meters from device
        let maxValidDistance: Float = 3.0   // Maximum 3 meters from device
        
        // Calculate the target position with offsets
        let targetPosition = SIMD3<Float>(
            devicePosition.x + component.offsetX,
            devicePosition.y + component.offsetY,
            devicePosition.z + component.offsetZ
        )
        
        // Calculate distance from device to target (including offsets)
        let distanceFromDevice = length(targetPosition - devicePosition)
        
        // Validate and adjust position if needed
        let finalPosition: SIMD3<Float>
        if distanceFromDevice < minValidDistance || distanceFromDevice > maxValidDistance {
            Logger.debug("""
            
            ⚠️ Invalid position detected for '\(entity.name)'
            ├─ Distance from device: \(distanceFromDevice)m
            ├─ Min allowed: \(minValidDistance)m
            └─ Max allowed: \(maxValidDistance)m
            """)
            
            // Calculate direction vector from device to target
            let direction = normalize(targetPosition - devicePosition)
            
            // Clamp distance to valid range
            let clampedDistance = simd_clamp(distanceFromDevice, minValidDistance, maxValidDistance)
            
            // Calculate new position at clamped distance
            finalPosition = devicePosition + (direction * clampedDistance)
            
            Logger.debug("✅ Adjusted to safe distance: \(clampedDistance)m")
        } else {
            finalPosition = targetPosition
        }
        
        Logger.debug("""
        
        📍 Positioning entity '\(entity.name)'
        ├─ From: \(entity.position)
        ├─ To: \(finalPosition)
        ├─ Offsets: [\(component.offsetX), \(component.offsetY), \(component.offsetZ)]
        ├─ Distance: \(distanceFromDevice)m
        └─ Method: \(component.shouldAnimate ? "Animated (\(component.animationDuration)s)" : "Immediate")
        """)
        
        if component.shouldAnimate {
            await entity.animateAbsolutePosition(
                to: finalPosition,
                duration: component.animationDuration,
                timing: .easeInOut,
                waitForCompletion: false
            )
        } else {
            entity.setPosition(finalPosition, relativeTo: nil)
        }
        
        Logger.debug("""
        
        ✨ Position update complete for '\(entity.name)'
        ├─ Final Position: \(entity.position(relativeTo: nil))
        └─ Status: Success
        """)
        
        return true
    }
}


```

File: Managers/HandTrackingManager.swift
```swift
import RealityKit
import SwiftUI
import ARKit

@Observable
final class HandTrackingManager {
    // MARK: - Properties
    private weak var trackingManager: TrackingSessionManager?
    
    /// Root entity containing all hand-tracked content
    private var contentEntity = Entity()
    
    /// The most recent hand anchors
    private(set) var leftHandAnchor: HandAnchor?
    private(set) var rightHandAnchor: HandAnchor?
    
    /// Entities representing finger positions for spawning
    private let fingerEntities: [HandAnchor.Chirality: ModelEntity] = [
        .left: .createFingertip(),
        .right: .createFingertip()
    ]
    
    init(trackingManager: TrackingSessionManager? = nil) {
        self.trackingManager = trackingManager
    }
    
    func configure(with trackingManager: TrackingSessionManager) {
        self.trackingManager = trackingManager
    }
    
    // MARK: - Setup
    func setupContentEntity() -> Entity {
        // Add finger entities to content
        // for entity in fingerEntities.values {
        //     entity.scale = .one * 0.2  // Make sure debug spheres are visible
        //     entity.components.set(ModelComponent(
        //         mesh: .generateSphere(radius: 1),
        //         materials: [SimpleMaterial(color: .blue, isMetallic: false)]
        //     ))
        //     entity.isEnabled = true  // Make sure entities start enabled
        //     contentEntity.addChild(entity)
        // }
        
        // Set up hand tracking updates using ClosureComponent
        contentEntity.components.set(ClosureComponent(closure: { [weak self] deltaTime in
            guard let self = self else { return }
            
            // Update left hand
            if let leftAnchor = self.leftHandAnchor,
               let leftHandSkeleton = leftAnchor.handSkeleton {
                let indexTip = leftHandSkeleton.joint(.indexFingerTip)
                
                if indexTip.isTracked {
                    let originFromIndex = leftAnchor.originFromAnchorTransform * indexTip.anchorFromJointTransform
                    self.fingerEntities[.left]?.setTransformMatrix(originFromIndex, relativeTo: nil)
                }
            }
            
            // Update right hand
            if let rightAnchor = self.rightHandAnchor,
               let rightHandSkeleton = rightAnchor.handSkeleton {
                let indexTip = rightHandSkeleton.joint(.indexFingerTip)
                
                if indexTip.isTracked {
                    let originFromIndex = rightAnchor.originFromAnchorTransform * indexTip.anchorFromJointTransform
                    self.fingerEntities[.right]?.setTransformMatrix(originFromIndex, relativeTo: nil)
                }
            }
        }))
        
        return contentEntity
    }
    
    // MARK: - Helper Methods
    
    /// Gets the current position of a specified hand's index finger
    /// - Parameter chirality: Which hand to get the position for
    /// - Returns: The world space position of the index finger, if available
    func getFingerPosition(_ chirality: HandAnchor.Chirality) -> SIMD3<Float>? {
        return fingerEntities[chirality]?.transform.translation
    }
    
    /// Gets the distance between thumb and index finger for a hand
    /// - Parameter chirality: Which hand to check
    /// - Returns: Distance between thumb and index finger if both are tracked, nil otherwise
    func getPinchDistance(_ chirality: HandAnchor.Chirality) -> Float? {
        let handAnchor = chirality == .left ? leftHandAnchor : rightHandAnchor
        
        guard handAnchor?.isTracked == true else { return nil }
        
        let thumbTip = handAnchor?.handSkeleton?.joint(.thumbTip)
        let indexTip = handAnchor?.handSkeleton?.joint(.indexFingerTip)
        
        guard ((thumbTip?.isTracked) != nil) && ((indexTip?.isTracked) != nil) else { return nil }
        
        let originFromAnchor = handAnchor!.originFromAnchorTransform
        let thumbTransform = thumbTip?.anchorFromJointTransform
        let indexTransform = indexTip?.anchorFromJointTransform
        
        let originFromThumb = originFromAnchor * thumbTransform!
        let originFromIndex = originFromAnchor * indexTransform!
        
        // Get positions from transforms
        let thumbPosition = SIMD3<Float>(originFromThumb.columns.3.x, 
                                       originFromThumb.columns.3.y, 
                                       originFromThumb.columns.3.z)
        let indexPosition = SIMD3<Float>(originFromIndex.columns.3.x, 
                                       originFromIndex.columns.3.y, 
                                       originFromIndex.columns.3.z)
        
        // Calculate distance
        return distance(thumbPosition, indexPosition)
    }
    
    /// Calculate distance between two 3D points
    private func distance(_ a: SIMD3<Float>, _ b: SIMD3<Float>) -> Float {
        let diff = a - b
        return sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z)
    }
    
    func updateHandAnchors(left: HandAnchor?, right: HandAnchor?) {
        leftHandAnchor = left
        rightHandAnchor = right
    }
}

// MARK: - ModelEntity Extensions

private extension ModelEntity {
    /// Creates a visualization for the fingertip
    static func createFingertip() -> ModelEntity {
        let entity = ModelEntity(
            mesh: .generateSphere(radius: 0.005),
            materials: [SimpleMaterial(color: .cyan, isMetallic: false)]
        )
        entity.components.set(OpacityComponent(opacity: 0.6))
        return entity
    }
}
```

File: Preview Content/Preview Assets.xcassets/Contents.json
```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

File: Resources/lab_v005.exr
```exr
[File too large]
```

File: Resources/metro_noord_2k.exr
```exr
[File too large]
```

File: Managers/TrackingSessionManager.swift
```swift
//
//  TrackingSessionManager.swift
//  VisionOS Only – Revised for clean session restarts
//

import ARKit
import RealityKit
import SwiftUI
import QuartzCore

@Observable
@MainActor
final class TrackingSessionManager {
    // MARK: - Properties
    // Making this a variable so we can reinitialize it on stop.
    var arkitSession = ARKitSession()
    var worldTrackingProvider = WorldTrackingProvider()
    var handTrackingProvider: HandTrackingProvider!
    
    private(set) var providersStoppedWithError = false
    private(set) var worldSensingAuthorizationStatus = ARKitSession.AuthorizationStatus.notDetermined
    private var isTracking = false
    
    // Track current provider state
    private(set) var currentState: DataProviderState = .initialized
    
    // Hand tracking state
    private(set) var leftHandAnchor: HandAnchor?
    private(set) var rightHandAnchor: HandAnchor?
    var shouldProcessHandTracking: Bool = false
    
    // HandTrackingManager
    let handTrackingManager: HandTrackingManager
    
    // Weak reference to AppModel
    weak var appModel: AppModel?
    
    init() {
        handTrackingManager = HandTrackingManager(trackingManager: nil)
        handTrackingManager.configure(with: self)
    }
    
    // MARK: - Session Management
    func startTracking(needsHandTracking: Bool = false) async throws {
        await logTrackingState(context: "Start Tracking Request")
        
        // If already tracking with the same state, skip starting a new session.
        if isTracking && shouldProcessHandTracking == needsHandTracking {
            Logger.info("⚠️ Already tracking with same state - skipping")
            await logTrackingState(context: "Skipped Start (Already Tracking)")
            return
        }
        
        // If already tracking, stop the previous session and verify cleanup
        if isTracking {
            Logger.info("🛑 Stopping previous tracking session")
            await stopTracking()
            do {
                try await waitForCleanup()
                if !verifyProviderState(expectRunning: false) {
                    Logger.error("❌ Provider state verification failed after cleanup")
                    throw TrackingError.cleanupFailed
                }
            } catch {
                Logger.error("❌ Cleanup failed: \(error)")
                throw TrackingError.cleanupFailed
            }
            await logTrackingState(context: "Post-Stop Check")
        }
        
        // Reinitialize providers to guarantee fresh state.
        worldTrackingProvider = WorldTrackingProvider()
        let providers: [any DataProvider]
        if needsHandTracking {
            shouldProcessHandTracking = true
            handTrackingProvider = HandTrackingProvider()
            providers = [worldTrackingProvider, handTrackingProvider]
            Logger.info("""
            
            🖐️ Configuring Tracking Session
            ├─ World Tracking: Enabled
            ├─ Hand Tracking: Enabled
            ├─ Provider State: \(currentState)
            └─ Previous Tracking: \(isTracking ? "Active" : "Inactive")
            """)
        } else {
            shouldProcessHandTracking = false
            providers = [worldTrackingProvider]
            Logger.info("""
            
            🌎 Configuring Tracking Session
            ├─ World Tracking: Enabled
            ├─ Hand Tracking: Disabled
            ├─ Provider State: \(currentState)
            └─ Previous Tracking: \(isTracking ? "Active" : "Inactive")
            """)
        }
        
        providersStoppedWithError = false
        
        do {
            // For VisionOS, simply run the ARKit session with the providers.
            try await arkitSession.run(providers)
            
            // Wait for and verify running state
            try await waitForTrackingToRun()
            if !verifyProviderState(expectRunning: true) {
                Logger.error("❌ Provider state verification failed after start")
                throw TrackingError.failedToStart
            }
            
            isTracking = true
            await logTrackingState(context: "Post-Start")
        } catch {
            Logger.error("❌ Failed to start tracking: \(error)")
            isTracking = false
            throw TrackingError.failedToStart
        }
    }
    
    func stopTracking() async {
        Logger.info("🛑 Stopping Tracking Session")
        arkitSession.stop()
        isTracking = false
        
        // Reinitialize arkitSession to clear any stale state.
        arkitSession = ARKitSession()
        
        // Wait for cleanup
        do {
            try await waitForCleanup()
        } catch {
            Logger.error("❌ Cleanup timeout: \(error)")
        }
        
        await logTrackingState(context: "Post-Stop")
    }
    
    func waitForTrackingToRun(timeout: TimeInterval = 2.0) async throws {
        let startTime = Date()
        while true {
            if case .running = self.worldTrackingProvider.state {
                return
            }
            if Date().timeIntervalSince(startTime) > timeout {
                throw TrackingError.timedOut
            }
            try await Task.sleep(nanoseconds: 100_000_000) // 100ms delay
        }
    }
    
    /// Waits for tracking providers to reach a stopped state
    /// - Parameter timeout: Maximum time to wait for cleanup (default: 1.0 seconds)
    /// - Throws: TrackingError.cleanupTimeout if providers don't stop within timeout
    func waitForCleanup(timeout: TimeInterval = 1.0) async throws {
        let startTime = Date()
        while Date().timeIntervalSince(startTime) < timeout {
            if case .stopped = worldTrackingProvider.state {
                if !shouldProcessHandTracking || handTrackingProvider?.state == .stopped {
                    return
                }
            }
            try await Task.sleep(for: .milliseconds(50))
        }
        throw TrackingError.cleanupTimeout
    }
    
    /// Verifies the current state of tracking providers
    /// - Parameter expectRunning: Whether providers should be in running state
    /// - Returns: true if providers are in expected state
    func verifyProviderState(expectRunning: Bool) -> Bool {
        let worldState = worldTrackingProvider.state
        let handState = handTrackingProvider?.state
        
        let worldOK = expectRunning ? worldState == .running : worldState == .stopped
        let handOK = !shouldProcessHandTracking || 
                    (expectRunning ? handState == .running : handState == .stopped)
        
        Logger.debug("""
        🔍 Provider State Verification
        ├─ Expected State: \(expectRunning ? "Running" : "Stopped")
        ├─ World Provider: \(worldOK ? "✅" : "❌") [\(worldState)]
        ├─ Hand Tracking Needed: \(shouldProcessHandTracking)
        └─ Hand Provider: \(handOK ? "✅" : "❌") [\(handState ?? .stopped)]
        """)
        
        return worldOK && handOK
    }
    
    // MARK: - Update Processing
    func processWorldTrackingUpdates() async {
        for await _ in worldTrackingProvider.anchorUpdates {
            // Process world tracking updates.
        }
    }
    
    func processHandTrackingUpdates() async {
        Logger.info("""
        
        === Processing Hand Updates ===
        ├─ Should Process Hand Tracking: \(shouldProcessHandTracking)
        └─ Hand Provider State: \(handTrackingProvider?.state ?? DataProviderState.initialized)
        """)
        
        guard shouldProcessHandTracking else {
            Logger.info("❌ Hand tracking updates disabled")
            return
        }
        
        Logger.info("🖐️ Starting hand tracking updates")
        for await update in handTrackingProvider.anchorUpdates {
            let handAnchor = update.anchor
            switch update.event {
            case .added, .updated:
                switch handAnchor.chirality {
                case .left:
                    leftHandAnchor = handAnchor
                case .right:
                    rightHandAnchor = handAnchor
                }
                handTrackingManager.updateHandAnchors(left: leftHandAnchor, right: rightHandAnchor)
            case .removed:
                switch handAnchor.chirality {
                case .left:
                    leftHandAnchor = nil
                    Logger.info("❌ Left hand removed")
                case .right:
                    rightHandAnchor = nil
                    Logger.info("❌ Right hand removed")
                }
                handTrackingManager.updateHandAnchors(left: leftHandAnchor, right: rightHandAnchor)
            }
        }
    }
    
    // MARK: - Event Monitoring
    func monitorTrackingEvents() async {
        for await event in arkitSession.events {
            switch event {
            case .dataProviderStateChanged(let providers, let newState, let error):
                for provider in providers {
                    let providerName: String
                    if provider is WorldTrackingProvider {
                        providerName = "World Tracking"
                    } else if provider is HandTrackingProvider {
                        providerName = "Hand Tracking"
                    } else {
                        providerName = "Unknown"
                    }
                    
                    Logger.info("""
                    
                    🔄 Provider State Change
                    ├─ Provider: \(providerName)
                    ├─ From: \(currentState)
                    ├─ To: \(newState)
                    ├─ Error: \(error?.localizedDescription ?? "none")
                    └─ Current Phase: \(appModel?.currentPhase ?? .loading)
                    """)
                }
                
                currentState = newState
                await logTrackingState(context: "Provider State Change [\(newState)]")
                
                switch newState {
                case .initialized:
                    Logger.info("ℹ️ Providers initialized")
                case .running:
                    Logger.info("✅ Providers running")
                    isTracking = true
                case .paused:
                    Logger.info("⏸️ Providers paused")
                case .stopped:
                    if let error = error {
                        Logger.info("""
                        
                        ❌ Providers Stopped with Error
                        ├─ Error: \(error)
                        └─ State: \(currentState)
                        """)
                        providersStoppedWithError = true
                    } else {
                        Logger.info("""
                        
                        ⏹️ Providers Stopped Normally
                        └─ State: \(currentState)
                        """)
                    }
                    isTracking = false
                @unknown default:
                    break
                }
                
            case .authorizationChanged(let type, let status):
                if type == .worldSensing {
                    worldSensingAuthorizationStatus = status
                    Logger.info("""
                    
                    🔐 Authorization Changed
                    ├─ Type: World Sensing
                    └─ Status: \(status)
                    """)
                }
                
            default:
                break
            }
        }
    }
    
    // MARK: - Authorization
    func requestWorldSensingAuthorization() async {
        let authorizationResult = await arkitSession.requestAuthorization(for: [.worldSensing])
        worldSensingAuthorizationStatus = authorizationResult[.worldSensing]!
    }
}

// MARK: - Errors
extension TrackingSessionManager {
    enum TrackingError: Error {
        case timedOut
        case cleanupTimeout
        case failedToStop
        case failedToStart
        case providerNotAvailable
        case invalidState
        case cleanupFailed
    }
}

// MARK: - Enhanced Logging
extension TrackingSessionManager {
    func logTrackingState(context: String) async {
        Logger.info("""
        
        === Tracking State [\(context)] ===
        ├─ Tracking Enabled: \(isTracking)
        ├─ Hand Tracking Enabled: \(shouldProcessHandTracking)
        └─ Current Provider State: \(currentState)
        """)
        
        if let deviceAnchor = worldTrackingProvider.queryDeviceAnchor(atTimestamp: CACurrentMediaTime()) {
            Logger.info("""
            
            📍 Device Anchor Info
            ├─ Head Transform: \(deviceAnchor.originFromAnchorTransform)
            ├─ Position X: \(deviceAnchor.originFromAnchorTransform.columns.3.x)
            ├─ Position Y: \(deviceAnchor.originFromAnchorTransform.columns.3.y)
            └─ Position Z: \(deviceAnchor.originFromAnchorTransform.columns.3.z)
            """)
        } else {
            Logger.info("⚠️ No device anchor available")
        }
        
        Logger.info("""
        
        🌐 Provider States
        ├─ World Provider: \(worldTrackingProvider.state)
        ├─ Hand Provider: \(handTrackingProvider?.state ?? DataProviderState.initialized)
        └─ Stopped with Error: \(providersStoppedWithError)
        """)
    }
    
    func logTransition(from: String, to: String) async {
        Logger.info("""
        
        🔄 Phase Transition
        ├─ From: \(from)
        └─ To: \(to)
        """)
        await logTrackingState(context: "Pre-Transition")
    }
}

```

File: Systems/ADCMovementSystem.swift
```swift
// PfizerOutdoCancer/Systems/ADCMovementSystem.swift
// Revised ADCMovementSystem.swift

import RealityKit
import Foundation
import RealityKitContent

@MainActor
public class ADCMovementSystem: System {
    // MARK: - Queries and Constants
    
    /// Query for entities with an ADC component
    static let query = EntityQuery(where: .has(ADCComponent.self))
    
    // Movement parameters
    static let numSteps: Double = 120
    static let baseArcHeight: Float = 1.2
    static let arcHeightRange: ClosedRange<Float> = 0.6...1.2
    static let baseStepDuration: TimeInterval = 0.016  // ~60fps
    static let speedRange: ClosedRange<Float> = 1.2...3.0
    static let totalDuration: TimeInterval = numSteps * baseStepDuration
    static let minDistance: Float = 0.5
    static let maxDistance: Float = 3.0
    
    // Rotation parameters
    static let rotationSmoothingFactor: Float = 12.0
    static let maxBankAngle: Float = .pi / 8
    static let bankingSmoothingFactor: Float = 6.0
    
    // Acceleration parameters
    static let accelerationPhase: Float = 0.2
    static let decelerationPhase: Float = 0.2
    static let minSpeedMultiplier: Float = 0.4
    
    // Retargeting parameters
    private static let retargetDuration: Float = 0.5
    static let numLookupSamples: Int = 100
    
    // Target search parameters for orbiting ADCs
    static let orbitingTargetSearchInterval: Double = 1.0  // Check for targets every second
    
    // MARK: - Initialization
    required public init(scene: Scene) { }
    
    // MARK: - Update Loop
    public func update(context: SceneUpdateContext) {
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            guard var adcComponent = entity.components[ADCComponent.self] else { continue }

            if adcComponent.state == .moving {
                guard var adcComponent = entity.components[ADCComponent.self],
                      adcComponent.state == .moving,
                      let start = adcComponent.startWorldPosition,
                      let targetID = adcComponent.targetEntityID else { continue }
                
                // Find target entity by its ID.
                let query = EntityQuery(where: .has(AttachmentPoint.self))
                let entities = context.scene.performQuery(query)
                guard let targetEntity = entities.first(where: { $0.id == Entity.ID(targetID) }) else {
                    #if DEBUG
                    print("⚠️ Target entity not found - aborting ADC movement")
                    #endif
                    adcComponent.state = .idle
                    entity.components[ADCComponent.self] = adcComponent
                    continue
                }
                
                // Validate target before proceeding.
                if !Self.validateTarget(targetEntity, adcComponent, in: context.scene) {
                    #if DEBUG
                    print("⚠️ Target no longer valid - attempting to find new target")
                    #endif
                    if Self.retargetADC(entity, &adcComponent, currentPosition: entity.position(relativeTo: nil), in: context.scene) {
                        entity.components[ADCComponent.self] = adcComponent
                        continue
                    } else {
                        #if DEBUG
                        print("⚠️ No valid targets found - resetting ADC")
                        #endif
                        Self.resetADC(entity: entity, component: &adcComponent)
                        continue
                    }
                }
                
                // Get the target position, handling interpolation if needed
                var targetPosition = targetEntity.position(relativeTo: nil)
                
                // If we're interpolating between targets, blend the target position
                if let previousTarget = adcComponent.previousTargetPosition,
                   let newTarget = adcComponent.newTargetPosition {
                    // Update interpolation progress
                    adcComponent.targetInterpolationProgress += Float(context.deltaTime / ADCComponent.targetInterpolationDuration)
                    
                    // When interpolation is complete, update the path
                    if adcComponent.targetInterpolationProgress >= 1.0 {
                        adcComponent.targetInterpolationProgress = 1.0
                        
                        #if DEBUG
                        print("\n=== Path Update Before Recalculation ===")
                        print("Current Position: \(entity.position(relativeTo: nil))")
                        print("Start Position: \(start)")
                        print("Previous Target: \(previousTarget)")
                        print("New Target: \(newTarget)")
                        print("Current Traveled Distance: \(adcComponent.traveledDistance)")
                        print("Previous Path Length: \(adcComponent.pathLength)")
                        #endif
                        
                        // Calculate distances for scaling decision
                        let oldTargetDistance = length(previousTarget - start)
                        let newTargetDistance = length(newTarget - start)
                        
                        #if DEBUG
                        print("\n=== Distance Comparison ===")
                        print("Old target distance: \(oldTargetDistance)")
                        print("New target distance: \(newTargetDistance)")
                        #endif
                        
                        // Scale traveled distance if new target is closer
                        var newTraveledDistance = adcComponent.traveledDistance
                        if newTargetDistance < oldTargetDistance {
                            newTraveledDistance = (adcComponent.traveledDistance / oldTargetDistance) * newTargetDistance
                            #if DEBUG
                            print("Scaling traveled distance: \(adcComponent.traveledDistance) -> \(newTraveledDistance)")
                            #endif
                        } else {
                            #if DEBUG
                            print("New target is farther - preserving absolute traveled distance")
                            #endif
                        }
                        
                        // Calculate new path
                        let distance = length(newTarget - start)
                        let midPoint = Self.mix(start, newTarget, t: 0.5)
                        let arcHeightFactor = adcComponent.arcHeightFactor ?? 1.0
                        let heightOffset = distance * 0.5 * arcHeightFactor
                        let controlPoint = midPoint + SIMD3<Float>(0, heightOffset, 0)
                        
                        // Build new lookup table
                        let lookup = Self.buildLookupTableForQuadraticBezier(
                            start: start,
                            control: controlPoint,
                            end: newTarget,
                            samples: Self.numLookupSamples
                        )
                        
                        let newPathLength = lookup.last ?? 0.0
                        
                        #if DEBUG
                        print("\n=== Path Update After Recalculation ===")
                        print("New Path Length: \(newPathLength)")
                        print("Traveled Distance (updated): \(newTraveledDistance)")
                        print("New Progress: \(newTraveledDistance / newPathLength)")
                        print("Distance from start to target: \(distance)")
                        #endif
                        
                        // Verify the new path is valid
                        if newPathLength <= 0.0 {
                            #if DEBUG
                            print("⚠️ Invalid new path length!")
                            #endif
                            continue
                        }
                        
                        // Update component with new path data
                        adcComponent.lookupTable = lookup
                        adcComponent.pathLength = newPathLength
                        adcComponent.traveledDistance = newTraveledDistance
                        adcComponent.wasRetargeted = true
                        adcComponent.previousTargetPosition = nil
                        adcComponent.newTargetPosition = nil
                        
                        #if DEBUG
                        print("✅ Path update complete - ADC will continue to new target")
                        #endif
                    }
                    
                    // Interpolate target position for this frame
                    let t = Self.smoothstep(0, 1, adcComponent.targetInterpolationProgress)
                    targetPosition = Self.mix(previousTarget, newTarget, t: t)
                }
                
                // Calculate path parameters based on current target position
                let distance = length(targetPosition - start)
                let midPoint = Self.mix(start, targetPosition, t: 0.5)
                let arcHeightFactor = adcComponent.arcHeightFactor ?? 1.0
                let heightOffset = distance * 0.5 * arcHeightFactor
                let controlPoint = midPoint + SIMD3<Float>(0, heightOffset, 0)
                
                // Update lookup table if needed (first frame or after retargeting)
                if adcComponent.lookupTable == nil {
                    let lookup = Self.buildLookupTableForQuadraticBezier(start: start, control: controlPoint, end: targetPosition, samples: Self.numLookupSamples)
                    adcComponent.lookupTable = lookup
                    adcComponent.pathLength = lookup.last ?? 0.0
                    adcComponent.traveledDistance = 0.0
                }
                
                // Calculate effective speed and update traveled distance
                let speedFactor = adcComponent.speedFactor ?? 1.0
                let baseSpeed = adcComponent.pathLength / Float(Self.totalDuration)
                
                // Calculate speed multiplier based on acceleration/deceleration
                let normalizedProgress = (adcComponent.pathLength > 0) ? (adcComponent.traveledDistance / adcComponent.pathLength) : 0
                let speedMultiplier: Float
                if normalizedProgress < Self.accelerationPhase {
                    let t = normalizedProgress / Self.accelerationPhase
                    speedMultiplier = Self.mix(Self.minSpeedMultiplier, 1.0, t: Self.smoothstep(0, 1, t))
                } else if normalizedProgress > (1.0 - Self.decelerationPhase) {
                    let t = (normalizedProgress - (1.0 - Self.decelerationPhase)) / Self.decelerationPhase
                    speedMultiplier = Self.mix(1.0, Self.minSpeedMultiplier, t: Self.smoothstep(0, 1, t))
                } else {
                    speedMultiplier = 1.0
                }
                
                let effectiveSpeed = baseSpeed * speedFactor * speedMultiplier
                adcComponent.traveledDistance += effectiveSpeed * Float(context.deltaTime)
                adcComponent.traveledDistance = min(adcComponent.traveledDistance, adcComponent.pathLength)
                
                // Check for retargeting at 40% for untargeted ADCs
                let currentNormalizedProgress = (adcComponent.pathLength > 0) ? (adcComponent.traveledDistance / adcComponent.pathLength) : 0
                if currentNormalizedProgress >= 0.8 {
                    if let attachPoint = targetEntity.components[AttachmentPoint.self],
                       attachPoint.isUntargeted {
                        #if DEBUG
                        print("\n=== ADC at 80% - Converting from Untargeted to Seeking ===")
                        print("Current Progress: \(currentNormalizedProgress)")
                        print("ADC World Position: \(entity.position(relativeTo: nil))")
                        print("Target World Position: \(targetEntity.position(relativeTo: nil))")
                        #endif
                        
                        // Mark the attachment point as no longer untargeted
                        var updatedAttachPoint = attachPoint
                        updatedAttachPoint.isUntargeted = false
                        updatedAttachPoint.isOccupied = true
                        targetEntity.components[AttachmentPoint.self] = updatedAttachPoint
                        
                        #if DEBUG
                        print("🎯 ADC at 80% - attempting to find cancer cell target")
                        #endif
                        
                        if Self.retargetADC(entity, &adcComponent, currentPosition: entity.position(relativeTo: nil), in: context.scene) {
                            entity.components[ADCComponent.self] = adcComponent
                            // Remove the headPosition entity and its debug sphere.
                            targetEntity.removeFromParent()
                            #if DEBUG
                            print("✨ Removed headPosition entity after successful retarget")
                            #endif
                            continue
                        }
                        // If retargeting fails, just continue to the headPosition
                        #if DEBUG
                        print("⚠️ No suitable cancer cell targets found - continuing to headPosition")
                        #endif
                    }
                }
                
                // Calculate current position on the path
                let tMapped = Self.lookupParameter(forDistance: adcComponent.traveledDistance, lookup: adcComponent.lookupTable ?? [])
                
                // Break down quadratic Bézier calculation into steps
                let t1 = 1.0 - tMapped
                let t2 = tMapped
                
                // Calculate each term separately
                let term1 = start * (t1 * t1)
                let term2 = controlPoint * (2 * t1 * t2)
                let term3 = targetPosition * (t2 * t2)
                
                // Sum the terms to get final position
                let position = term1 + term2 + term3
                entity.position = position
                
                // Calculate tangent vector components separately
                let tangentStart = (controlPoint - start) * (1 - tMapped)
                let tangentEnd = (targetPosition - controlPoint) * tMapped
                let tangent = normalize(2 * (tangentStart + tangentEnd))
                
                // Update orientation
                let orientation = Self.calculateOrientation(
                    progress: tMapped,
                    direction: tangent,
                    deltaTime: context.deltaTime,
                    currentOrientation: entity.orientation,
                    entity: entity
                )
                entity.orientation = orientation
                
                // Save updated component
                entity.components[ADCComponent.self] = adcComponent
                
                // Handle completion
                if adcComponent.hasCollided {
                    #if DEBUG
                    print("\n=== ADC Path Completion ===")
                    print("Final Progress: \(tMapped)")
                    print("Total Distance Traveled: \(adcComponent.traveledDistance)")
                    print("Path Length: \(adcComponent.pathLength)")
                    print("Start Position: \(start)")
                    print("Final Position: \(position)")
                    print("Target Position: \(targetPosition)")
                    #endif
                    
                    // Trigger a hit-scale animation on the parent cancer cell
                    if let cancerCell = Self.findParentCancerCell(for: targetEntity, in: context.scene) {
                        #if DEBUG
                        print("✅ Found parent cancer cell - triggering hit animation")
                        #endif
                        Task { @MainActor in
                            await cancerCell.hitScaleAnimation(
                                intensity: 0.95,
                                duration: 0.2,
                                scaleReduction: 0.05
                            )
                        }
                    } else {
                        #if DEBUG
                        print("⚠️ Could not find parent cancer cell for hit animation")
                        #endif
                    }
                    
                    #if DEBUG
                    print("\n=== ADC Attachment Process ===")
                    // Remove ADC from its current parent and prepare for attachment
                    let previousParent = entity.parent?.name ?? "none"
                    #endif
                    
                    entity.removeFromParent()
                    
                    // Compute and validate landing transform
                    let landingTransform = Self.computeLandingTransform(for: entity, with: targetEntity)
                    if Self.validateLandingTransform(landingTransform) {
                        // Add as child with computed transform
                        targetEntity.addChild(entity)
                        entity.transform = landingTransform
                        
                        #if DEBUG
                        print("✅ Applied landing transform successfully")
                        #endif
                    } else {
                        // Fallback to simple attachment if transform is invalid
                        targetEntity.addChild(entity)
                        entity.position = SIMD3<Float>(0, -0.08, 0)
                        entity.orientation = targetEntity.orientation(relativeTo: nil)
                        #if DEBUG
                        print("⚠️ Using fallback attachment due to invalid landing transform")
                        #endif
                    }
                    
                    #if DEBUG
                    print("🔄 Reparented ADC:")
                    print("Previous Parent: \(previousParent)")
                    print("New Parent: \(targetEntity.name)")
                    #endif
                    
                    // Trigger antigen retraction
                    if let offsetEntity = targetEntity.parent {
                        if var antigenComponent = offsetEntity.components[AntigenComponent.self] {
                            antigenComponent.isRetracting = true
                            offsetEntity.components[AntigenComponent.self] = antigenComponent
                        }
                    }
                    
                    // Scale-up animation
                    var scaleUpTransform = entity.transform
                    scaleUpTransform.scale = SIMD3<Float>(repeating: 1.2)
                    entity.move(
                        to: scaleUpTransform,
                        relativeTo: entity.parent,
                        duration: 0.15,
                        timingFunction: .easeInOut
                    )
                    
                    Task {
                        try? await Task.sleep(for: .milliseconds(150))
                        var originalTransform = entity.transform
                        originalTransform.scale = SIMD3<Float>(repeating: 1.0)
                        entity.move(
                            to: originalTransform,
                            relativeTo: entity.parent,
                            duration: 0.15,
                            timingFunction: .easeInOut
                        )
                    }
                    
                    // Handle audio
                    entity.stopAllAudio()
                    if let audioComponent = entity.components[AudioLibraryComponent.self],
                       let attachSound = audioComponent.resources["ADC_Attach.wav"] {
                        if var spatialAudio = entity.components[SpatialAudioComponent.self] {
                            spatialAudio.directivity = .beam(focus: 1.0)
                            spatialAudio.gain = -6.0
                            entity.components[SpatialAudioComponent.self] = spatialAudio
                        }
                        entity.playAudio(attachSound)
                    }
                    
                    // Update ADC state
                    adcComponent.state = .attached
                    entity.components[ADCComponent.self] = adcComponent
                    #if DEBUG
                    print("✅ ADC state updated to attached")
                    #endif
                    
                    // Update cell hit count
                    if let cellID = adcComponent.targetCellID,
                       let cancerCell = Self.findParentCancerCell(for: targetEntity, in: context.scene),
                       let stateComponent = cancerCell.components[CancerCellStateComponent.self] {
                        let _ = stateComponent.parameters.hitCount
                        stateComponent.parameters.hitCount += 1
                        stateComponent.parameters.wasJustHit = true
                        
                        // Only log the critical hit count updates
                        print("📊 Cell \(cellID): \(stateComponent.parameters.hitCount)/\(stateComponent.parameters.requiredHits) hits")
                        
                        // Post notification for cell update
                        NotificationCenter.default.post(
                            name: Notification.Name("UpdateCancerCell"),
                            object: nil,
                            userInfo: ["entity": cancerCell]
                        )
                        #if DEBUG
                        print("📢 Posted UpdateCancerCell notification for cell \(cellID)")
                        print("\n=== ADC Path Completion ===")
                        print("Final Progress: \(tMapped)")
                        print("Total Distance Traveled: \(adcComponent.traveledDistance)")
                        print("Path Length: \(adcComponent.pathLength)")
                        print("Start Position: \(start)")
                        print("Final Position: \(position)")
                        print("Target Position: \(targetPosition)")
                        #endif
                    } else {
                        #if DEBUG
                        print("⚠️ Could not update hit count - missing required components")
                        #endif
                    }
                    
                    #if DEBUG
                    print("✅ ADC completion process finished successfully")
                    #endif
                    continue
                }
                
                // Set the initial orientation on the first frame.
                if adcComponent.traveledDistance <= 0.01 {
                    let direction = simd_normalize(targetPosition - start)
                    Self.setInitialRootOrientation(entity: entity, direction: direction)
                }
                
                // Update any additional per-frame behavior (like protein spin).
                Self.updateProteinSpin(entity: entity, deltaTime: context.deltaTime)
                
                // Save updated component.
                entity.components[ADCComponent.self] = adcComponent
                
                // MARK: ORBITING
            } else if adcComponent.state == .orbiting {
                // Get the orbit center from headTrackingRoot or use a fallback.
                let orbitCenter: SIMD3<Float>
                if let headTrackingRoot = entity.scene?.findEntity(named: "headTrackingRoot") {
                    orbitCenter = headTrackingRoot.position(relativeTo: nil)
                } else {
                    orbitCenter = [0, 1.5, 0]
                }
                
                // Accumulate time since last target search
                adcComponent.timeSinceLastTargetSearch += context.deltaTime
                
                // Check for new targets periodically
                if adcComponent.timeSinceLastTargetSearch >= Self.orbitingTargetSearchInterval {
                    // Reset the timer
                    adcComponent.timeSinceLastTargetSearch = 0
                    
                    // Try to find a new target
                    if Self.retargetADC(entity, &adcComponent, currentPosition: entity.position(relativeTo: nil), in: context.scene) {
                        // Valid target found, transition to moving state
                        adcComponent.state = .moving
                        adcComponent.lookupTable = nil
                        adcComponent.traveledDistance = 0.0
                        adcComponent.startWorldPosition = entity.position(relativeTo: nil)
                        entity.components[ADCComponent.self] = adcComponent
                        continue
                    }
                }
                
                // --- Update orbit angle in reverse (for counter-clockwise movement)
                // Use only orbitSpeed (no division by orbitRadius here unless you specifically want that effect).
                adcComponent.orbitTheta -= Float(context.deltaTime) * adcComponent.orbitSpeed
                
                // --- Organic Vertical Oscillation
                // Lower the amplitude by scaling it down (for example, multiply by 0.5).
                let verticalOscillation = (adcComponent.verticalOscillationAmplitude * 0.5) *
                    sin(adcComponent.orbitTheta * adcComponent.verticalOscillationFrequency + adcComponent.verticalOscillationPhase)
                
                // Lower the orbit height (again, scale down the stored value).
                let baseOrbitHeight = adcComponent.orbitHeight * 0.5
                
                // --- Calculate the target orbit position.
                let targetX = orbitCenter.x + adcComponent.orbitRadius * cos(adcComponent.orbitTheta)
                let targetZ = orbitCenter.z + adcComponent.orbitRadius * sin(adcComponent.orbitTheta)
                let targetY = orbitCenter.y + baseOrbitHeight + verticalOscillation
                let targetOrbitPosition = SIMD3<Float>(targetX, targetY, targetZ)
                
                // --- Smooth transition into orbiting.
                if adcComponent.orbitTransitionProgress < 1.0 {
                    adcComponent.orbitTransitionProgress += Float(context.deltaTime) / adcComponent.orbitTransitionDuration
                    let t = ADCMovementSystem.smoothstep(0, 1, adcComponent.orbitTransitionProgress)
                    entity.position = ADCMovementSystem.mix(adcComponent.orbitTransitionStartPosition, targetOrbitPosition, t: t)
                } else {
                    entity.position = targetOrbitPosition
                }
                
                // --- Tumbling Rotation
                // Update the tumble angle based on tumbleSpeed.
                adcComponent.tumbleAngle += Float(context.deltaTime) * adcComponent.tumbleSpeed
                // For tumbling, choose a fixed (or random per ADC) axis. Here we use a normalized axis [1, 1, 0].
                let tumbleAxis = simd_normalize(SIMD3<Float>(1, 1, 0))
                let tumbleRotation = simd_quatf(angle: adcComponent.tumbleAngle, axis: tumbleAxis)
                
                // --- Combine with Orbit Orientation
                // Compute the orbit tangent for facing direction. (For a circle, tangent = (-sinθ, 0, cosθ))
                let tangent = SIMD3<Float>(-sin(adcComponent.orbitTheta), 0, cos(adcComponent.orbitTheta))
                let orbitOrientation = simd_quatf(from: [0, 0, 1], to: tangent)
                // Apply the tumble rotation on top of the orbit-facing orientation.
                entity.orientation = tumbleRotation * orbitOrientation
                
                // Update any other per-frame behavior (like protein spin).
                ADCMovementSystem.updateProteinSpin(entity: entity, deltaTime: context.deltaTime)
                
                // Save the updated component.
                entity.components[ADCComponent.self] = adcComponent
            } else {
                #if DEBUG
//                print("⚠️ Unknown ADC state - skipping update")
                #endif
            }
        }
    }
    
    // MARK: - Helper Functions
    
    private static func setInitialRootOrientation(entity: Entity, direction: SIMD3<Float>) {
        let baseOrientation = simd_quatf(from: [0, 0, 1], to: direction)
        entity.orientation = baseOrientation
    }
    
    private static func updateProteinSpin(entity: Entity, deltaTime: TimeInterval) {
        if let proteinComplex = entity.findEntity(named: "antibodyProtein_complex"),
           let adcComponent = entity.components[ADCComponent.self] {
            let spinRotation = simd_quatf(angle: Float(deltaTime) * adcComponent.proteinSpinSpeed, axis: [-1, 0, 0])
            proteinComplex.orientation = proteinComplex.orientation * spinRotation
        }
    }
    
    /// Replaces the old `startMovement` method to initialize the lookup table and arc-length parameters.
    @MainActor
    public static func startMovement(entity: Entity, from start: SIMD3<Float>, to targetPoint: Entity) {
        guard var adcComponent = entity.components[ADCComponent.self] else {
            print("ERROR: No ADCComponent found on entity")
            return
        }
        
        adcComponent.state = .moving
        adcComponent.startWorldPosition = start
        adcComponent.traveledDistance = 0.0
        adcComponent.targetEntityID = UInt64(targetPoint.id)
        
        adcComponent.arcHeightFactor = Float.random(in: arcHeightRange)
        adcComponent.speedFactor = Float.random(in: speedRange)
        
        let target = targetPoint.position(relativeTo: nil)
        let distance = length(target - start)
        let midPoint = mix(start, target, t: 0.5)
        let heightOffset = distance * 0.5 * (adcComponent.arcHeightFactor ?? 1.0)
        let controlPoint = midPoint + SIMD3<Float>(0, heightOffset, 0)
        
        let lookup = Self.buildLookupTableForQuadraticBezier(start: start, control: controlPoint, end: target, samples: Self.numLookupSamples)
        adcComponent.lookupTable = lookup
        adcComponent.pathLength = lookup.last ?? 0.0
        
        entity.components[ADCComponent.self] = adcComponent
        entity.position = start
        
        // Start drone sound.
        if let audioComponent = entity.components[AudioLibraryComponent.self],
           let droneSound = audioComponent.resources["Drones_01.wav"] {
            if var spatialAudio = entity.components[SpatialAudioComponent.self] {
                spatialAudio.directivity = .beam(focus: 1.0)
                entity.components[SpatialAudioComponent.self] = spatialAudio
            }
            entity.playAudio(droneSound)
        }
    }
    
    // (The resetADC function is defined in its separate extension file.)
}

```

File: Systems/ADCMovementSystem+Utils.swift
```swift
//
//  ADCMovementSystem+Utils.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 2/3/25.
//

import RealityKit
import Foundation
import RealityKitContent

@MainActor
extension ADCMovementSystem {
    static func resetADC(entity: Entity, component: inout ADCComponent) {
        #if DEBUG
        print("\n=== Resetting ADC ===")
        print("Previous State: \(component.state)")
        print("Previous Target Cell ID: \(String(describing: component.targetCellID))")
        #endif
        
        // Reset ADC state and target information.
        component.state = .orbiting
        component.targetEntityID = nil
        component.targetCellID = nil
        component.startWorldPosition = nil
        component.targetWorldPosition = nil
        
        // Reset path tracking values.
        component.traveledDistance = 0
        component.pathLength = 0
        component.lookupTable = nil
        
        // Reset retargeting/interpolation values.
        component.previousTargetPosition = nil
        component.newTargetPosition = nil
        component.targetInterpolationProgress = 0
        component.previousPathLength = 0
        component.previousPathTangent = nil
        component.isRetargetedPath = false
        component.compositeProgress = 0
        
        // Stop any ongoing audio.
        entity.stopAllAudio()
        
        // --- NEW: Orbiting Setup ---
        // Set lower and more varied orbit parameters.
        let orbitRadius = Float.random(in: 2.0...3.0)       // Slightly lower orbit radius.
        let orbitHeight = Float.random(in: 0.5...1.0)         // Lower orbit height.
        let orbitSpeed = Float.random(in: 0.3...0.6)          // More variation in orbit speed.
        let orbitTheta = Float.random(in: 0...(2 * .pi))
        component.orbitRadius = orbitRadius
        component.orbitHeight = orbitHeight
        component.orbitSpeed = orbitSpeed
        component.orbitTheta = orbitTheta
        
        // Organic vertical oscillation parameters (with lower amplitude).
        component.verticalOscillationAmplitude = Float.random(in: 0.1...0.3)
        component.verticalOscillationFrequency = Float.random(in: 0.5...1.0)
        component.verticalOscillationPhase = Float.random(in: 0...(2 * .pi))
        
        // --- NEW: Smooth Transition into Orbiting ---
        // Capture the current position as the starting point.
        component.orbitTransitionStartPosition = entity.position(relativeTo: nil)
        // Reset transition progress.
        component.orbitTransitionProgress = 0.0
        // Increase the duration for a smoother transition.
        component.orbitTransitionDuration = 2.0  // For example, 2 seconds.
        
        // --- NEW: Tumbling Rotation Parameters ---
        // Reset the tumble angle and assign a random tumble speed.
        component.tumbleAngle = 0.0
        component.tumbleSpeed = Float.random(in: 0.5...1.5)  // Radians per second.
        
        // Disable collisions (if applicable).
        if var collisionComponent = entity.components[CollisionComponent.self] {
            collisionComponent.filter = CollisionFilter(group: collisionComponent.filter.group, mask: [])
            entity.components[CollisionComponent.self] = collisionComponent
        }
        
        entity.components[ADCComponent.self] = component
        
        #if DEBUG
        print("✅ ADC Reset Complete")
        print("New State: \(component.state)")
        #endif
    }
}
```

File: Systems/ADCMovementSystem+Math.swift
```swift
// ADCMovementSystem+Math.swift

import RealityKit
import Foundation
import RealityKitContent

@MainActor
extension ADCMovementSystem {
    
    internal static func mix(_ a: Float, _ b: Float, t: Float) -> Float {
        return a * (1 - t) + b * t
    }
    
    internal static func mix(_ a: SIMD3<Float>, _ b: SIMD3<Float>, t: Float) -> SIMD3<Float> {
        return a * (1 - t) + b * t
    }
    
    internal static func smoothstep(_ edge0: Float, _ edge1: Float, _ x: Float) -> Float {
        let t = max(0, min((x - edge0) / (edge1 - edge0), 1))
        return t * t * (3 - 2 * t)
    }
    
    /// Quadratic Bézier point calculation: B(t) = (1-t)²P₀ + 2(1-t)tP₁ + t²P₂
    static func quadraticBezierPoint(_ p0: SIMD3<Float>,
                                     _ p1: SIMD3<Float>,
                                     _ p2: SIMD3<Float>,
                                     t: Float) -> SIMD3<Float> {
        let mt = 1 - t
        return mt * mt * p0 + 2 * mt * t * p1 + t * t * p2
    }
    
    /// Given a quadratic Bézier curve, sample it to build a lookup table of cumulative arc lengths.
    static func buildLookupTableForQuadraticBezier(start: SIMD3<Float>, control: SIMD3<Float>, end: SIMD3<Float>, samples: Int) -> [Float] {
        var lookup: [Float] = [0.0]
        var previousPoint = start
        for i in 1...samples {
            let t = Float(i) / Float(samples)
            let point = quadraticBezierPoint(start, control, end, t: t)
            let segmentLength = simd_distance(point, previousPoint)
            let cumulative = lookup.last! + segmentLength
            lookup.append(cumulative)
            previousPoint = point
        }
        return lookup
    }
    
    /// Given the traveled distance and a lookup table, interpolate the corresponding parameter t.
    static func lookupParameter(forDistance distance: Float, lookup: [Float]) -> Float {
        guard let totalLength = lookup.last, totalLength > 0 else { return 0 }
        let d = simd_clamp(distance, 0, totalLength)
        for i in 1..<lookup.count {
            if lookup[i] >= d {
                let t0 = Float(i - 1) / Float(lookup.count - 1)
                let t1 = Float(i) / Float(lookup.count - 1)
                let d0 = lookup[i - 1]
                let d1 = lookup[i]
                let segmentFraction = (d - d0) / (d1 - d0)
                return t0 + segmentFraction * (t1 - t0)
            }
        }
        return 1.0
    }
    
    /// Calculates complete path metrics (for legacy or debugging purposes).
    static func calculatePathMetrics(
        start: SIMD3<Float>,
        control: SIMD3<Float>,
        end: SIMD3<Float>
    ) -> (length: Float, initialDirection: SIMD3<Float>, controlPoint: SIMD3<Float>) {
        let pathLength = quadraticBezierLength(start, control, end)
        let initialDerivative = 2 * (control - start)
        let initialDirection = normalize(initialDerivative)
        return (pathLength, initialDirection, control)
    }
    
    /// Quadratic Bézier curve length using Gauss–Legendre quadrature.
    static func quadraticBezierLength(_ p0: SIMD3<Float>, _ p1: SIMD3<Float>, _ p2: SIMD3<Float>) -> Float {
        let weights: [Float] = [0.236926885056189, 0.478628670499366, 0.568888888888889, 0.478628670499366, 0.236926885056189]
        let nodes: [Float] = [0.046910077030668, 0.230765344947158, 0.5, 0.769234655052842, 0.953089922969332]
        
        return nodes.enumerated().reduce(0) { acc, pair in
            let t = pair.element
            let derivative = 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1))
            return acc + weights[pair.offset] * simd_length(derivative)
        } * 0.5
    }
    
    internal static func validateQuaternion(_ quat: simd_quatf) -> Bool {
        if quat.vector.x.isNaN || quat.vector.y.isNaN || quat.vector.z.isNaN || quat.vector.w.isNaN {
            return false
        }
        let length = sqrt(quat.vector.x * quat.vector.x +
                          quat.vector.y * quat.vector.y +
                          quat.vector.z * quat.vector.z +
                          quat.vector.w * quat.vector.w)
        return abs(length - 1.0) < 0.001
    }
    
    static func calculateOrientation(progress: Float,
                                     direction: SIMD3<Float>,
                                     deltaTime: TimeInterval,
                                     currentOrientation: simd_quatf,
                                     entity: Entity) -> simd_quatf {
        // Validate inputs
        guard validateOrientationCalculation(entity: entity,
                                          progress: progress,
                                          direction: direction,
                                          currentOrientation: currentOrientation) else {
            return currentOrientation
        }
        
        // Handle protein complex spin animation
        if let proteinComplex = entity.findEntity(named: "antibodyProtein_complex"),
           let adcComponent = entity.components[ADCComponent.self] {
            let worldSpinAxis = currentOrientation.act([-1, 0, 0])
            let spinRotation = simd_quatf(angle: Float(deltaTime) * adcComponent.proteinSpinSpeed, axis: worldSpinAxis)
            proteinComplex.orientation = spinRotation * proteinComplex.orientation
        }
        
        // Early return if we don't have the necessary components
        guard let adcComponent = entity.components[ADCComponent.self],
              let targetID = adcComponent.targetEntityID else {
            return currentOrientation
        }
        
        // Find target entity
        let query = EntityQuery(where: .has(AttachmentPoint.self))
        guard let targetEntity = entity.scene?.performQuery(query).first(where: { $0.id == Entity.ID(targetID) }) else {
            return currentOrientation
        }
        
        // Compute landing orientation and blend factor
        let landingOrientation = computeLandingOrientation(for: entity, with: targetEntity)
        let blendFactor = computeBlendFactor(progress: progress)
        
        // Debug state if needed
        // #if DEBUG
        // debugPrintOrientationState(
        //     progress: progress,
        //     blendFactor: blendFactor,
        //     currentOrientation: currentOrientation,
        //     targetOrientation: landingOrientation
        // )
        // #endif
        
        if blendFactor > 0 {
            // Blend between flight orientation and landing orientation
            let flightOrientation = simd_quatf(from: [0, 0, 1], to: direction)
            let intermediateOrientation = safeSlerp(from: flightOrientation, to: landingOrientation, t: blendFactor)
            
            // Add subtle banking based on progress
            let bankAngle = computeBankingAngle(progress: progress, blendFactor: blendFactor)
            let bankRotation = simd_quatf(angle: bankAngle, axis: [1, 0, 0])
            
            // Combine orientations
            let targetOrientation = bankRotation * intermediateOrientation
            
            // Smoothly interpolate from current to target orientation
            return safeSlerp(from: currentOrientation, to: targetOrientation, t: Float(deltaTime) * rotationSmoothingFactor)
        } else {
            // Standard flight orientation when not near target
            let flightOrientation = simd_quatf(from: [0, 0, 1], to: direction)
            
            // Add banking during normal flight
            let bankAngle = computeBankingAngle(progress: progress, blendFactor: 0)
            let bankRotation = simd_quatf(angle: bankAngle, axis: [1, 0, 0])
            
            // Combine orientations
            let targetOrientation = bankRotation * flightOrientation
            
            // Smoothly interpolate from current to target orientation
            return safeSlerp(from: currentOrientation, to: targetOrientation, t: Float(deltaTime) * rotationSmoothingFactor)
        }
    }
    
    // MARK: - Landing Orientation Helpers
    
    /// Ensures a quaternion is normalized and valid
    internal static func normalizeQuaternion(_ quat: simd_quatf) -> simd_quatf {
        if !validateQuaternion(quat) {
            // Create identity quaternion manually (w=1, xyz=0)
            return simd_quatf(vector: SIMD4<Float>(0, 0, 0, 1))
        }
        return quat
    }
    
    /// Safely normalizes a vector, returning a default up vector if normalization fails
    internal static func safeNormalize(_ vector: SIMD3<Float>, defaultVector: SIMD3<Float> = SIMD3<Float>(0, 1, 0)) -> SIMD3<Float> {
        let vectorLength = length(vector)
        
        // Check for near-zero length or NaN components
        if vectorLength < 1e-6 || vector.x.isNaN || vector.y.isNaN || vector.z.isNaN {
            #if DEBUG
            // print("⚠️ Vector normalization failed:")
            // print("Vector: \(vector)")
            // print("Length: \(vectorLength)")
            // print("Using default vector: \(defaultVector)")
            #endif
            return defaultVector
        }
        
        return vector / vectorLength
    }
    
    /// Computes surface normal from a point on the surface to the center
    internal static func computeSurfaceNormal(surfacePoint: SIMD3<Float>, center: SIMD3<Float>) -> SIMD3<Float> {
        let vector = surfacePoint - center
        
        #if DEBUG
        // print("Surface Normal Calculation:")
        // print("Vector: \(vector)")
        // print("Vector Length: \(length(vector))")
        #endif
        
        return safeNormalize(vector)
    }
    
    /// Safely interpolates between two quaternions with validation
    internal static func safeSlerp(from start: simd_quatf, to end: simd_quatf, t: Float) -> simd_quatf {
        guard validateQuaternion(start) && validateQuaternion(end) else {
            #if DEBUG
            print("⚠️ Invalid quaternions in slerp - using start quaternion")
            #endif
            return start
        }
        return simd_slerp(start, end, t)
    }
    
    // MARK: - Easing and Blending
    
    /// Smooth easing function for orientation blending
    internal static func smoothEaseInOut(_ x: Float) -> Float {
        let t = simd_clamp(x, 0, 1)
        return t * t * (3 - 2 * t)
    }
    
    /// Exponential ease out for smoother deceleration
    internal static func expEaseOut(_ x: Float) -> Float {
        return x == 1 ? 1 : 1 - pow(2, -10 * x)
    }
    
    /// Computes blend factor for landing orientation transition
    internal static func computeBlendFactor(progress: Float, startBlend: Float = 0.8) -> Float {
        if progress < startBlend {
            return 0
        }
        let rawFactor = (progress - startBlend) / (1 - startBlend)
        return smoothEaseInOut(rawFactor)
    }
    
    /// Computes banking angle based on progress and blend factor
    internal static func computeBankingAngle(progress: Float, blendFactor: Float) -> Float {
        let baseAngle = sin(progress * .pi * 2)
        return (1 - blendFactor) * maxBankAngle * baseAngle
    }
    
    // MARK: - Landing Orientation
    
    /// Computes a landing orientation that aligns the ADC with the antigen's surface normal
    internal static func computeLandingOrientation(for adc: Entity, with target: Entity) -> simd_quatf {
        // Get the antigen (two levels up from attachment point)
        guard let antigenOffset = target.parent,
              let antigen = antigenOffset.parent,
              let scene = antigen.scene,
              let cell = findParentCancerCell(for: antigen, in: scene) else {
            #if DEBUG
            print("⚠️ No parent cell found for target - using target orientation")
            #endif
            return target.orientation(relativeTo: nil)
        }
        
        // Compute world positions using the antigen position instead of attachment point
        let antigenWorldPos = antigen.position(relativeTo: nil)
        let cellWorldPos = cell.position(relativeTo: nil)
        
        // #if DEBUG
        // print("\n=== Landing Orientation Debug ===")
        // print("Antigen Entity: \(antigen.name)")
        // print("Antigen World Position: \(antigenWorldPos)")
        // print("Cell World Position: \(cellWorldPos)")
        // print("Vector between positions: \(antigenWorldPos - cellWorldPos)")
        // #endif
        
        // Compute surface normal and validate
        let normal = computeSurfaceNormal(surfacePoint: antigenWorldPos, center: cellWorldPos)
        
        // #if DEBUG
        // print("Computed Normal: \(normal)")
        // print("Normal length: \(length(normal))")
        // print("Has NaN?: \(normal.x.isNaN || normal.y.isNaN || normal.z.isNaN)")
        // #endif
        
        guard !normal.x.isNaN && !normal.y.isNaN && !normal.z.isNaN else {
            #if DEBUG
            print("⚠️ Invalid surface normal computed - using target orientation")
            #endif
            return target.orientation(relativeTo: nil)
        }
        
        // Base rotation to align ADC's up vector with surface normal
        let baseRotation = simd_quatf(from: SIMD3<Float>(0, 1, 0), to: normal)
        guard validateQuaternion(baseRotation) else {
            #if DEBUG
            print("⚠️ Invalid base rotation - using target orientation")
            #endif
            return target.orientation(relativeTo: nil)
        }
        
        // Add randomized rotation around the normal for variety
        let randomAngle = Float.random(in: -Float.pi/8 ... Float.pi/8)
        let randomRotation = simd_quatf(angle: randomAngle, axis: normal)
        
        // Combine rotations and validate
        let finalOrientation = normalizeQuaternion(randomRotation * baseRotation)
        if !validateQuaternion(finalOrientation) {
            #if DEBUG
            print("⚠️ Invalid final orientation - using target orientation")
            #endif
            return target.orientation(relativeTo: nil)
        }
        
        return finalOrientation
    }
    
    /// Computes the complete landing transform including position offset
    internal static func computeLandingTransform(for adc: Entity, with target: Entity) -> Transform {
        var transform = Transform()
        
        // // Set orientation
        // transform.rotation = computeLandingOrientation(for: adc, with: target)
        
        // // Set position with slight offset along the surface normal
        // if let cell = target.parent {
        //     let normal = computeSurfaceNormal(
        //         surfacePoint: target.position(relativeTo: nil),
        //         center: cell.position(relativeTo: nil)
        //     )
        //     transform.translation = SIMD3<Float>(0, -0.08, 0) // Slight offset for visual appeal
        // } else {
        //     transform.translation = .zero
        // }
        
        // Create a pitch rotation of -90 degrees (i.e. -π/2 radians) around the X axis.
        let pitchRotation = simd_quatf(angle: -Float.pi/2, axis: SIMD3<Float>(1, 0, 0))
        
        // Generate a random yaw rotation between 0 and 360 degrees (0 to 2π radians) around the Y axis.
        let randomYawAngle = Float.random(in: 0 ..< (2 * Float.pi))
        let yawRotation = simd_quatf(angle: randomYawAngle, axis: SIMD3<Float>(0, 1, 0))
        
        // Combine the rotations. (Multiplication order matters:
        // here, yawRotation * pitchRotation means that the ADC first gets pitched -90°,
        // then rotated randomly around its new up axis.)
        transform.rotation = yawRotation * pitchRotation
        
        // Optionally, add a slight translation offset along the local Y axis.
        // (This offset can be adjusted to fine-tune the "lily pad" visual.)
        transform.translation = SIMD3<Float>(0, -0.08, 0)
        
        // Set the scale to uniform 1.
        transform.scale = SIMD3<Float>(1, 1, 1)

        return transform
    }
    
    // MARK: - Validation and Debugging
    
    /// Validates all inputs for orientation calculation
    internal static func validateOrientationCalculation(entity: Entity,
                                                      progress: Float,
                                                      direction: SIMD3<Float>,
                                                      currentOrientation: simd_quatf) -> Bool {
        // Check for NaN values in direction vector
        if direction.x.isNaN || direction.y.isNaN || direction.z.isNaN {
            #if DEBUG
            print("⚠️ Invalid direction vector in orientation calculation")
            #endif
            return false
        }
        
        // Validate current orientation
        if !validateQuaternion(currentOrientation) {
            #if DEBUG
            print("⚠️ Invalid current orientation in calculation")
            #endif
            return false
        }
        
        // Validate progress value
        if progress.isNaN || progress < 0 || progress > 1 {
            #if DEBUG
            print("⚠️ Invalid progress value: \(progress)")
            #endif
            return false
        }
        
        // Validate entity has required components
        if entity.components[ADCComponent.self] == nil {
            #if DEBUG
            print("⚠️ Entity missing ADC component")
            #endif
            return false
        }
        
        return true
    }
    
    /// Debug function to print orientation state
    internal static func debugPrintOrientationState(progress: Float,
                                                  blendFactor: Float,
                                                  currentOrientation: simd_quatf,
                                                  targetOrientation: simd_quatf) {
        print("""
        === ADC Orientation State ===
        Progress: \(String(format: "%.3f", progress))
        Blend Factor: \(String(format: "%.3f", blendFactor))
        Current Orientation: \(currentOrientation)
        Target Orientation: \(targetOrientation)
        Quaternion Lengths:
          Current: \(sqrt(simd_dot(currentOrientation.vector, currentOrientation.vector)))
          Target: \(sqrt(simd_dot(targetOrientation.vector, targetOrientation.vector)))
        ========================
        """)
    }
    
    /// Validates transform for landing
    internal static func validateLandingTransform(_ transform: Transform) -> Bool {
        // Check position
        if transform.translation.x.isNaN || transform.translation.y.isNaN || transform.translation.z.isNaN {
            #if DEBUG
            print("⚠️ Invalid landing position")
            #endif
            return false
        }
        
        // Check rotation
        if !validateQuaternion(transform.rotation) {
            #if DEBUG
            print("⚠️ Invalid landing rotation")
            #endif
            return false
        }
        
        // Check scale (should be uniform)
        if transform.scale.x != transform.scale.y || transform.scale.y != transform.scale.z {
            #if DEBUG
            print("⚠️ Non-uniform scale in landing transform")
            #endif
            return false
        }
        
        return true
    }
}
```

File: Systems/ADCMovementSystem+Retargeting.swift
```swift
// ADCMovementSystem+Retargeting.swift

import RealityKit
import Foundation
import RealityKitContent

@MainActor
extension ADCMovementSystem {
    
    static func retargetADC(_ entity: Entity,
                            _ adcComponent: inout ADCComponent,
                            currentPosition: SIMD3<Float>,
                            in scene: Scene) -> Bool {
        // Find new target
        guard let (newTarget, newCellID) = findNewTarget(for: entity, currentPosition: currentPosition, in: scene) else {
            #if DEBUG
            print("⚠️ No valid targets found for retargeting")
            #endif
            return false
        }
        
        #if DEBUG
        print("🎯 Retargeting ADC to new cancer cell (ID: \(newCellID))")
        #endif
        
        // Skip if targeting same cell
        if adcComponent.targetCellID == newCellID {
            #if DEBUG
            print("⚠️ Attempting to retarget to same cell - skipping")
            #endif
            return false
        }
        
        // Check that the new target is sufficiently far from current position
        let newTargetPos = newTarget.position(relativeTo: nil)
        let distanceToNewTarget = length(newTargetPos - currentPosition)
        let minRequiredDistance: Float = 0.3 // Match the scoring function's minimum distance
        
        if distanceToNewTarget < minRequiredDistance {
            #if DEBUG
            print("\n⚠️ Target Distance Check Failed:")
            print("New target \(newTarget.name) is too close to current position")
            print("Distance to target: \(distanceToNewTarget)")
            print("Required minimum distance: \(minRequiredDistance)")
            #endif
            return false
        } else {
            #if DEBUG
            print("\n✅ Target Distance Check Passed:")
            print("Distance to new target: \(distanceToNewTarget)")
            print("Current position: \(currentPosition)")
            print("Target position: \(newTargetPos)")
            #endif
        }
        
        // Store current target position and set up interpolation
        if let currentTargetID = adcComponent.targetEntityID,
           let currentTarget = scene.findEntity(id: currentTargetID) {
            // Store the current path length before updating
            adcComponent.previousPathLength = adcComponent.pathLength
            
            #if DEBUG
            print("\n=== Previous Path Info ===")
            print("Previous Path Length: \(adcComponent.pathLength)")
            print("Previous Progress: \(adcComponent.traveledDistance / adcComponent.pathLength)")
            print("Previous Target Position: \(currentTarget.position(relativeTo: nil))")
            print("Previous Target Distance: \(length(currentTarget.position(relativeTo: nil) - currentPosition))")
            #endif
            
            // Set up target interpolation using transform snapshots
            let currentTransform = currentTarget.transformMatrix(relativeTo: nil)
            let newTransform = newTarget.transformMatrix(relativeTo: nil)
            
            adcComponent.previousTargetPosition = currentTransform.translation()
            adcComponent.newTargetPosition = newTransform.translation()
            adcComponent.targetInterpolationProgress = 0
            
            #if DEBUG
            print("\n=== Starting Retarget ===")
            print("From: \(currentTarget.name) to: \(newTarget.name)")
            print("Current Distance Traveled: \(adcComponent.traveledDistance)")
            print("Current Path Length: \(adcComponent.pathLength)")
            print("Current Progress: \(adcComponent.traveledDistance / adcComponent.pathLength)")
            print("New Target Distance: \(length(newTarget.position(relativeTo: nil) - currentPosition))")
            print("Interpolation Start Position: \(currentPosition)")
            #endif
        }
        
        // Update component with new target info using proper component update pattern
        adcComponent.targetEntityID = newTarget.id
        adcComponent.targetCellID = newCellID
        
        // Update attachment point using proper component update pattern
        if let attachPoint = newTarget.components[AttachmentPoint.self] {
            var updatedAttachPoint = attachPoint
            updatedAttachPoint.isOccupied = true
            newTarget.components[AttachmentPoint.self] = updatedAttachPoint
            #if DEBUG
            print("✅ Marked attachment point as occupied")
            #endif
        }
        
        return true
    }
    
    static func validateTarget(_ targetEntity: Entity, _ adcComponent: ADCComponent, in scene: Scene) -> Bool {
        // Check if this is an untargeted spawn point
        if let attachPoint = targetEntity.components[AttachmentPoint.self],
           attachPoint.isUntargeted {
            return true
        }
        
        // The rest of the validation is for cancer cell targets
        if targetEntity.parent == nil {
            #if DEBUG
            print("\n=== ADC RETARGET (Target Lost) ===")
            print("Target attachment point has been removed from scene")
            #endif
            return false
        }
        
        // Use proper error handling for component access
        guard let cancerCell = findParentCancerCell(for: targetEntity, in: scene),
              let stateComponent = cancerCell.components[CancerCellStateComponent.self],
              let cellID = adcComponent.targetCellID else {
            #if DEBUG
            print("\n=== ADC RETARGET (Invalid State) ===")
            print("Missing required components or target cell ID")
            #endif
            return false
        }
        
        let parameters = stateComponent.parameters
        
        if parameters.isDestroyed {
            #if DEBUG
            print("\n=== ADC RETARGET (Cell Destroyed) ===")
            print("Cell ID: \(cellID)")
            print("Hit Count: \(parameters.hitCount)/\(parameters.requiredHits)")
            #endif
            return false
        }
        
        if parameters.hitCount >= parameters.requiredHits {
            #if DEBUG
            print("\n=== ADC RETARGET (Cell Complete) ===")
            print("Cell ID: \(cellID)")
            print("Hit Count: \(parameters.hitCount)/\(parameters.requiredHits)")
            #endif
            return false
        }
        
        if parameters.cellID == cellID &&
            !parameters.isDestroyed &&
            parameters.hitCount < parameters.requiredHits {
            return true
        }
        
        #if DEBUG
        print("\n=== ADC RETARGET (Target Invalid) ===")
        print("Cell ID: \(cellID)")
        print("Hit Count: \(parameters.hitCount)/\(parameters.requiredHits)")
        print("Is Destroyed: \(parameters.isDestroyed)")
        #endif
        return false
    }
    
    /// Calculates a score for an attachment point based on its position and orientation relative to an approach position
    /// - Parameters:
    ///   - attachPosition: World position of the attachment point
    ///   - cellCenter: World position of the cell center
    ///   - approachPosition: Position from which the ADC is approaching
    ///   - minDistance: Minimum allowed distance (to prevent too-close targeting)
    /// - Returns: A score where higher values indicate better targets, or nil if the target is invalid
    @MainActor
    public static func calculateAttachmentScore(
        attachPosition: SIMD3<Float>,
        cellCenter: SIMD3<Float>,
        approachPosition: SIMD3<Float>,
        minDistance: Float = 0.3
    ) -> Float? {
        let distance = length(attachPosition - approachPosition)
        
        // Skip if the target is too close (prevent sharp turns)
        if distance < minDistance {
            return nil
        }
        
        // Base score on inverse distance (closer is better, but not too close)
        var score = 1.0 / max(distance, minDistance)
        
        // Factor in the facing direction of the antigen
        let antigenDirection = simd_normalize(attachPosition - cellCenter)
        let approachVector = simd_normalize(approachPosition - cellCenter)
        let dotProduct = simd_dot(antigenDirection, approachVector)
        
        // Adjust score based on how well the antigen faces the approach vector
        // (dotProduct + 1) * 2.0 maps the dot product from [-1,1] to [0,4]
        score *= (dotProduct + 1) * 2.0
        
        return score
    }

    static func findNewTarget(for adcEntity: Entity, currentPosition: SIMD3<Float>, in scene: Scene) -> (Entity, Int)? {
        let query = EntityQuery(where: .has(AttachmentPoint.self))
        var bestScore: Float = -Float.infinity
        var bestTarget: (Entity, Int)? = nil
        
        let entities = scene.performQuery(query)
        
        for entity in entities {
            guard let attachComponent = entity.components[AttachmentPoint.self],
                  !attachComponent.isOccupied else {
                continue
            }
            
            guard let cancerCell = findParentCancerCell(for: entity, in: scene),
                  let stateComponent = cancerCell.components[CancerCellStateComponent.self],
                  let cellID = stateComponent.parameters.cellID,
                  !stateComponent.parameters.isDestroyed else {
                continue
            }
            
            if stateComponent.parameters.hitCount >= stateComponent.parameters.requiredHits {
                continue
            }
            
            let attachPosition = entity.position(relativeTo: nil)
            let cellCenter = cancerCell.position(relativeTo: nil)
            
            guard let score = Self.calculateAttachmentScore(
                attachPosition: attachPosition,
                cellCenter: cellCenter,
                approachPosition: currentPosition
            ) else { continue }
            
            #if DEBUG
            // print("📊 Antigen Score - Distance: \(length(attachPosition - currentPosition)), Score: \(score)")
            #endif
            
            if score > bestScore {
                bestScore = score
                bestTarget = (entity, cellID)
                #if DEBUG
                print("✨ New best target found - Score: \(score)")
                #endif
            }
        }
        
        #if DEBUG
        if bestTarget != nil {
            // print("\n🎯 Selected target:")
            // print("Cell ID: \(target.1)")
            // print("Attachment Point: \(target.0.name)")
            // print("Final Score: \(bestScore)")
        }
        #endif
        
        return bestTarget
    }
    
    // --- Re-add findParentCancerCell ---
    static func findParentCancerCell(for attachmentPoint: Entity, in scene: Scene) -> Entity? {
        var current = attachmentPoint
        while let parent = current.parent {
            if parent.components[CancerCellStateComponent.self] != nil {
                return parent
            }
            current = parent
        }
        return nil
    }
}

```

File: Systems/ADCSystem.swift
```swift
import RealityKit
import RealityKitContent

@MainActor
public class ADCSystem: System {
    /// Query for entities with ADC component
    static let query = EntityQuery(where: .has(ADCComponent.self))
    
    public required init(scene: Scene) {
        // One-time setup if needed
    }
    
    public func update(context: SceneUpdateContext) {
        // Will implement necessary logic
    }
}

```

File: Systems/AttachmentSystem.swift
```swift
import Foundation
@preconcurrency import RealityKit
import RealityKitContent
import SwiftUI

public struct AttachmentSystem: System {
    // Queries as instance properties to avoid concurrency issues
    let attachmentQuery = EntityQuery(where: .has(AttachmentPoint.self))
    let cancerCellQuery = EntityQuery(where: .has(CancerCellStateComponent.self))

    public init(scene: RealityKit.Scene) { }
    
    @MainActor
    public func update(context: SceneUpdateContext) {
        for _ in context.entities(matching: attachmentQuery, updatingSystemWhen: .rendering) {
            // if you find attachments, and they have marked themselves as occupied, then increment the hitCount of that attachments parent cancer cell. only one increment per isOccupied
            // if entity.components[AttachmentPoint.self]?.isOccupied == true {
            //     if let cellEntity = entity.parent,
            //        var stateComponent = cellEntity.components[CancerCellStateComponent.self] {
            //         stateComponent.parameters.hitCount += 1
            //         cellEntity.components[CancerCellStateComponent.self] = stateComponent
            //     }
            // }
        }
    }
    
    // MARK: - Public API
    
    @MainActor
    public static func getAvailablePoint(
        in scene: RealityKit.Scene,
        forCellID cellID: Int,
        approachPosition: SIMD3<Float>? = nil
    ) -> Entity? {
        let query = EntityQuery(where: .has(AttachmentPoint.self))
        let entities = scene.performQuery(query)
        
        // If no approach position provided, use simple first-available logic
        if approachPosition == nil {
            return entities.first { entity in
                guard let attachPoint = entity.components[AttachmentPoint.self] else { return false }
                return attachPoint.cellID == cellID && !attachPoint.isOccupied
            }
        }
        
        // Otherwise use scoring logic to find best available point
        var bestScore: Float = -Float.infinity
        var bestPoint: Entity? = nil
        
        for entity in entities {
            guard let attachPoint = entity.components[AttachmentPoint.self],
                  attachPoint.cellID == cellID && !attachPoint.isOccupied else {
                continue
            }
            
            // Find parent cancer cell for center position
            var current = entity
            var cellCenter: SIMD3<Float>? = nil
            while let parent = current.parent {
                if parent.components[CancerCellStateComponent.self] != nil {
                    cellCenter = parent.position(relativeTo: nil)
                    break
                }
                current = parent
            }
            
            guard let cellCenter = cellCenter else { continue }
            
            let attachPosition = entity.position(relativeTo: nil)
            
            guard let score = ADCMovementSystem.calculateAttachmentScore(
                attachPosition: attachPosition,
                cellCenter: cellCenter,
                approachPosition: approachPosition!
            ) else { continue }
            #if DEBUG
//            print("📊 Attachment Point Score - Point: \(entity.name), Score: \(score)")
            #endif
            
            if score > bestScore {
                bestScore = score
                bestPoint = entity
                #if DEBUG
//                print("✨ New best attachment point - Score: \(score)")
                #endif
            }
        }
        
        if bestPoint != nil {
            #if DEBUG
//            print("🎯 Selected attachment point: \(bestPoint.name) with score: \(bestScore)")
            #endif
        }
        
        return bestPoint
    }
    
    @MainActor
    public static func markPointAsOccupied(_ point: Entity) {
        guard var attachPoint = point.components[AttachmentPoint.self] else {
            print("No AttachmentPoint component found")
            return
        }
        
        attachPoint.isOccupied = true
        point.components[AttachmentPoint.self] = attachPoint
    }
    
    @MainActor
    public static func markPointAsAvailable(_ entity: Entity) {
        guard var attachPoint = entity.components[AttachmentPoint.self] else { return }
        attachPoint.isOccupied = false
        entity.components[AttachmentPoint.self] = attachPoint
    }
}

```

File: Systems/CancerCellMovementData.swift
```swift
// CancerCellMovementData.swift
import RealityKit
import simd

/// A component to store the base movement data for a cancer cell.
public struct CancerCellMovementData: Component, Codable {
    public var baseLinearVelocity: SIMD3<Float>
    
    public init(baseLinearVelocity: SIMD3<Float>) {
        self.baseLinearVelocity = baseLinearVelocity
    }
}
```

File: Systems/BreathingSystem.swift
```swift
import RealityKit
import RealityKitContent

@MainActor
public class BreathingSystem: System {
    /// Query for entities with both Transform and BreathingComponent
    static let query = EntityQuery(where: .has(BreathingComponent.self))
    
    /// Define system dependencies - run before CancerCellSystem
    public nonisolated static var dependencies: [SystemDependency] {
        [.before(CancerCellSystem.self)]
    }
    
    public required init(scene: Scene) { }
    
    public func update(context: SceneUpdateContext) {
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            guard var breathing = entity.components[BreathingComponent.self],
                  let _ = entity.components[CancerCellComponent.self],
                  let stateComponent = entity.components[CancerCellStateComponent.self] else { continue }
            
            // Skip if cancer cell is scaling from a hit
            if stateComponent.parameters.isScaling { continue }
            
            // Update phase
            breathing.phase += (2.0 * .pi * Float(context.deltaTime)) / breathing.cycleDuration
            
            // Wrap phase between 0 and 2π
            if breathing.phase >= 2.0 * .pi {
                breathing.phase -= 2.0 * .pi
            }
            
            // Use cancer cell's current scale as the base
            breathing.baseScale = stateComponent.parameters.currentScale
            
            // Calculate scale using sine wave
            let breathingScale = breathing.baseScale + (sin(breathing.phase) * breathing.intensity)
            entity.scale = [breathingScale, breathingScale, breathingScale]
            
            // Update component
            entity.components[BreathingComponent.self] = breathing
        }
    }
} 

```

File: Systems/RotationAxis.swift
```swift
//
//  to.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/4/25.
//


/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An enum to mark which axis to rotate.
*/
public enum RotationAxis: String, CaseIterable, Identifiable, Codable {
    public var id: String {
        return self.rawValue
    }
    
    public var axis: SIMD3<Float> {
        switch self {
        case .xAxis:
            return SIMD3<Float>(1.0, 0.0, 0.0)
        case .yAxis:
            return SIMD3<Float>(0.0, 1.0, 0.0)
        case .zAxis:
            return SIMD3<Float>(0.0, 0.0, 1.0)
        }
    }

    case xAxis = "X"
    case yAxis = "Y"
    case zAxis = "Z"
}


```

File: Systems/MovementSystem.swift
```swift
import RealityKit
import RealityKitContent

/// A system that handles the movement and rotation of entities with MovementComponent
@MainActor
public class MovementSystem: System {
    /// Query to find entities that have a MovementComponent
    static let query = EntityQuery(where: .has(MovementComponent.self))
    
    /// Initialize the system with the RealityKit scene
    required public init(scene: Scene) {}
    
    /// Update the entities to apply movement and rotation
    public func update(context: SceneUpdateContext) {
        // Temporarily disabled
        return
        
        // Original code commented out
        /*
        // Iterate over entities that match the query and are currently rendering
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            // Get the MovementComponent from the entity
            var comp = entity.components[MovementComponent.self]!
            
            // Update the time as it passes
            comp.time += context.deltaTime
            
            // Update the component in the entity
            entity.components[MovementComponent.self] = comp
            
            // Use SIMD3 axis directly since we changed the component
            entity.setOrientation(simd_quatf(angle: Float(0.1 * comp.speed), axis: comp.axis), relativeTo: entity)
        }
        */
    }
}

```

File: Systems/CancerCellSpeedBoostSystem.swift
```swift
import RealityKit
import simd

public class CancerCellSpeedBoostSystem: System {

    private struct BoostConfig {
        static let maxBoostMultiplier: Float = 20.5
        static let lerpSharpness: Float = 4.0
        static let gravityMagnitude: Float = 0.1
    }
    
    private static let query = EntityQuery(where:
        .has(PhysicsMotionComponent.self)
    )
    
    public required init(scene: Scene) {}
    
    public func update(context: SceneUpdateContext) {
        let dt = Float(context.deltaTime)
        
        // If you have a specific user Entity, get its position.
        // Otherwise assume the user is at (0,0,0).
        let userPos = SIMD3<Float>(0, 0, 0)
        
        for entity in context.scene.performQuery(Self.query) {
            guard var motion = entity.components[PhysicsMotionComponent.self] else { continue }
            
            // 1) Current offset from user
            let worldPos = entity.position(relativeTo: nil)
            let offset   = worldPos - userPos
            
            // 2) Radius + angle
            let radius = simd_length(offset)
            // angle in [-π, π], with angle=0 meaning “behind user” if we do atan2(x,z).
            // (Because if x=0 and z>0 => angle=0 => that is “back” in your coordinate scheme.)
            let angle  = atan2(offset.x, offset.z)
            
            // 3) Recompute tangential orbit direction each frame so they keep circling
            let orbitDirection = SIMD3<Float>(
                cos(angle),
                0,
                -sin(angle)
            )
            
            // 4) Base orbital speed
            let baseOrbitSpeed = sqrt(BoostConfig.gravityMagnitude / radius) * 0.5
            
            // 5) Smoothly define a speed‐boost factor based on angle
            //
            //    Example:  f(angle) = 1 + (maxBoost - 1)*((cos(angle)+1)/2)
            //
            //    This yields:
            //      angle=0 (behind user)   => cos(0)=1  => raw=1.0 => boost= max
            //      angle=±π (front user)   => cos(±π)=-1 => raw=0.0 => boost= 1 (none)
            //      angle=±π/2 (left/right) => cos(±π/2)=0 => raw=0.5 => midrange
            //
            let rawFactor  = (cos(angle) + 1) * 0.5  // in [0..1]
            var boostFactor = 1 + (
                BoostConfig.maxBoostMultiplier - 1
            ) * rawFactor
            
            // 6) Final velocity
            let targetVelocity = orbitDirection * (baseOrbitSpeed * boostFactor)

            // Ensure at least some minimal speed-up in front
            boostFactor = max(boostFactor, 1.5)
            
            // 7) Smoothly lerp from current to target so it doesn’t jerk
            motion.linearVelocity = simd_mix(
                motion.linearVelocity,
                targetVelocity,
                SIMD3<Float>(repeating: dt * BoostConfig.lerpSharpness)
            )
            
            entity.components.set(motion)
        }
    }
}

```

File: Systems/AntigenSystem.swift
```swift
import RealityKit
import RealityKitContent
import Foundation

/// A system that handles antigen retraction animation when ADCs attach
@MainActor
public class AntigenSystem: System {
    /// Query to find entities that have AntigenComponent
    static let query = EntityQuery(where: .has(AntigenComponent.self))
    
    // Animation parameters
    static let retractionSpeed: Float = 0.25  // Units per second
    
    public required init(scene: Scene) {}
    
    public func update(context: SceneUpdateContext) {
        let deltaTime = Float(context.deltaTime)
        
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            guard var antigenComponent = entity.components[AntigenComponent.self] else { continue }
            
            if antigenComponent.isRetracting {
                // Update progress
                antigenComponent.retractionProgress = min(antigenComponent.retractionProgress + deltaTime * Self.retractionSpeed, 1.0)
                
                // Calculate new position
                let newY = AntigenSystem.mix(0, antigenComponent.targetY, t: antigenComponent.retractionProgress)
                var newPosition = entity.position
                newPosition.y = newY
                entity.position = newPosition
                
                // Update component
                entity.components[AntigenComponent.self] = antigenComponent
                
                // If retraction is complete, stop particle emission
                if antigenComponent.retractionProgress >= 1.0 {
                    // Look for the particle entity at the same level as the attach point
                    // if let antigenParent = entity.parent,
                    //    let particleEntity = antigenParent.parent?.findEntity(named: "particle"),
                    //    let emitterEntity = particleEntity.findEntity(named: "ParticleEmitter"),
                    //    var emitter = emitterEntity.components[ParticleEmitterComponent.self] {
                    //     emitter.isEmitting = false
                    //     emitterEntity.components[ParticleEmitterComponent.self] = emitter
                    //     print("💫 Stopped particle emission")
                    // }
                }
            }
        }
    }
    
    private static func mix(_ a: Float, _ b: Float, t: Float) -> Float {
        return a * (1 - t) + b * t
    }
}

```

File: Systems/SwirlingSystem.swift
```swift
//
//  SwirlingComponent.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 12/30/24.
//
import RealityKit
import Foundation


struct SwirlingComponent: Component {}

class SwirlingSystem: System {
    static let query = EntityQuery(where: .has(SwirlingComponent.self))
    
    public required init(scene: Scene) { }
    
    public func update(context: SceneUpdateContext) {
        context.scene.performQuery(Self.query).forEach { entity in
            updateEntityPosition(entity, deltaTime: Float(context.deltaTime))
        }
    }
    
    private func updateEntityPosition(_ entity: Entity, deltaTime: Float) {
        // Get the camera position
        let cameraPosition = SIMD3<Float>([0, 1.0, -0.25])
        
        // Calculate direction to camera
        let directionToCamera = (cameraPosition - entity.position).normalized()
        
        // Create more complex swirling motion
        let time = Float(Date().timeIntervalSince1970)
        
        // Primary swirl
        let swirl = SIMD3<Float>(
            sin(time * 2.0) * cos(time * 0.5),
            cos(time * 1.7) * sin(time * 0.3),
            sin(time * 1.3) * cos(time * 0.7)
        ) * 0.05  // Base amplitude
        
        // Combine movements with proper vector math
        let movement = (directionToCamera * 0.5 + swirl) * SIMD3(repeating: deltaTime)
        
        // Update position
        entity.position += movement
        
        // Smoother rotation
        if movement.length() > 0.001 {
            let smoothLookAtPoint = entity.position + movement * 2
            entity.look(at: smoothLookAtPoint, from: entity.position, relativeTo: nil)
        }
    }
}

//Add the Component to an Entity
//let entity = ModelEntity()
//entity.components[SwirlingComponent.self] = SwirlingComponent()


```

File: Systems/RotationSystem.swift
```swift
//
//  RotationSystem.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/4/25.
//

import Foundation
import RealityKit


public struct RotationComponent: Component, Codable {
    public var rotationAxis: RotationAxis = .yAxis
    public var speed: Float = 1.0

    public var axis: SIMD3<Float> {
        return rotationAxis.axis
    }
    
    public init() {}
}

@MainActor
final class RotationSystem: System {
    static let query = EntityQuery(where: .has(RotationComponent.self))
    
    init(scene: Scene) {}
    
    public func update(context: SceneUpdateContext) {
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            /// Ensure the component is found.
            guard let component = entity.components[RotationComponent.self] else { continue }
            /// If the entity has a zero speed ignore it.
            if component.speed == 0.0 { continue }
            /// Set the orientation of the entity relative to itself, based on
            /// the speed and change in the time base.
            entity.orientation *= simd_quatf(angle: component.speed * Float(context.deltaTime),
                                             axis: component.axis)
        }
    }
    
    
}

```

File: Systems/TraceComponent.swift
```swift
//
//  TraceComponent.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 12/30/24.
//


/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A system and component for drawing traces behind satellites.
*/

import Foundation
import RealityKit

/// Trace information for an entity.
struct TraceComponent: Component {
    var accumulatedTime: TimeInterval = 0
    var mesh: TraceMesh
    var isPaused: Bool = false

    weak var anchor: Entity?
    var model: ModelEntity?

    init(anchor: Entity, width: Float) {
        self.anchor = anchor
        self.mesh = TraceMesh(width: width)
    }
}

/// A system that draws a trace behind moving entities that have
/// a trace component.
struct TraceSystem: System {
    static let query = EntityQuery(where: .has(TraceComponent.self))

    init(scene: Scene) { }

    func update(context: SceneUpdateContext) {
        for satellite in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            var trace: TraceComponent = satellite.components[TraceComponent.self]!
            defer { satellite.components[TraceComponent.self] = trace }

            guard let anchor = trace.anchor else { return }

            trace.accumulatedTime += context.deltaTime
            if trace.isPaused || trace.accumulatedTime <= 0.025 { return }
            trace.accumulatedTime = 0

            // Store the satellite's current position in the anchor's
            // coordinate system.
            trace.mesh.addPosition(of: satellite, relativeTo: anchor)

            let contents = trace.mesh.meshContents

            // Update the existing trace mesh or create a new one.
            do {
                if let model = trace.model {
                    try model.model?.mesh.replace(with: contents)
                } else {
                    let model = try ModelEntity.makeTraceModel(with: contents)
                    model.name = "\(anchor.name)-trace"
                    trace.model = model
                    anchor.addChild(model)
                }
            } catch {
                print("Failed to create or update trace mesh.")
            }
        }
    }
}

struct TraceMesh {
    var positions: [SIMD3<Float>] = []
    var uvs: [SIMD2<Float>] = []
    var width: Float = 5
    static let maxIndexCount: UInt32 = 400
    static let triangleIndices = Self.generateIndices()

    init(width: Float) {
        self.width = width
    }
}

extension TraceMesh {
    mutating func addPosition(of entity: Entity, relativeTo referenceEntity: Entity) {
        let width = self.width / 1e5
        positions.append(entity.convert(position: entity.position - [0, width, 0],
                                        to: referenceEntity))
        positions.append(entity.convert(position: entity.position + [0, width, 0],
                                        to: referenceEntity))
        uvs.removeAll(keepingCapacity: true)
        var updatedPositions = [SIMD3<Float>]()
        let rowCount = positions.count
        
        _ = stride(from: 0, to: positions.endIndex, by: 2).map { row in
            let leftPosition = positions[row]
            let rightPosition = positions[row + 1]
            let fractionalValue = Float(row) / Float(rowCount)
           
            uvs.append([fractionalValue, 0])
            uvs.append([fractionalValue, 1])

            let center = (rightPosition + leftPosition) / 2
            let directionVector = simd_normalize(rightPosition - leftPosition)
            updatedPositions.append(center - (directionVector) * (fractionalValue * 0.004))
            updatedPositions.append(center + (directionVector) * (fractionalValue * 0.004))
        }
        positions = updatedPositions
        
        // Limit the trace length.
        if positions.count > Self.maxIndexCount {
            positions.removeFirst(2)
            uvs.removeFirst(2)
        }
    }

    static func generateIndices() -> [UInt32] {
        var indices: [UInt32] = []
        for index in 0 ..< maxIndexCount {
            indices.append(contentsOf: [index, index + 1, index + 2])
            indices.append(contentsOf: [index + 2, index + 1, index])
        }
        return indices
    }
}

extension TraceMesh {
    var meshContents: MeshResource.Contents {
        var meshPart = MeshResource.Part(id: "TracePart", materialIndex: 0)
        // Set up the part and contents using the positions and precalculated indices.
        meshPart.positions = .init(positions)
        meshPart.textureCoordinates = .init(uvs)
        meshPart.triangleIndices = .init(Self.triangleIndices.prefix((positions.count - 2) * 6))

        var contents = MeshResource.Contents()
        contents.models = [.init(id: "Trace", parts: [meshPart])]
        return contents
    }
}

extension ModelEntity {
    static func makeTraceModel(with contents: MeshResource.Contents) throws -> ModelEntity {
        guard let traceResource = try? TextureResource.load(named: "TrailGradient") else {
            fatalError("Unable to load trace texture.")
        }
        let traceMap = MaterialParameters.Texture(traceResource)
        var material = UnlitMaterial(color: .white)
        material.opacityThreshold = 0
        material.blending = .transparent(opacity: .init(texture: traceMap))
       
        return ModelEntity(mesh: try .generate(from: contents),
                           materials: [material])
    }
}

```

File: Systems/UIAttachmentSystem.swift
```swift
import RealityKit
import RealityKitContent
import SwiftUI

@MainActor
public class UIAttachmentSystem: System {
    /// Query for entities with both CancerCell marker and UIAttachment components
    static let query = EntityQuery(where: .has(CancerCellComponent.self) && .has(CancerCellStateComponent.self) && .has(UIAttachmentComponent.self))
    
    public required init(scene: RealityKit.Scene) {}
    
    public func update(context: SceneUpdateContext) {
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            if let _ = entity.components[UIAttachmentComponent.self],
               let _ = entity.components[CancerCellComponent.self],
               let _ = entity.components[CancerCellStateComponent.self] {
                // The system doesn't need to do much here since:
                // 1. The attachment position is handled by RealityKit (parent-child relationship)
                // 2. The hit count is managed in CancerCellStateComponent
                // 3. The UI updates automatically through SwiftUI bindings
                
                // We could add additional logic here if needed, such as:
                // - Updating attachment visibility based on distance/angle to camera
                // - Animating the attachment position/rotation
                // - Handling attachment lifecycle (creation/destruction)
            }
        }
    }
}

```

File: Systems/UIStabilizerSystem.swift
```swift
//
//  UIStabilizerSystem.swift
//  RealityKitContent
//
//  Created by Dale Carman on 11/29/24.
//

import RealityKit
import RealityKitContent

/// System that maintains UI elements at a fixed offset from their target entities
@MainActor
public class UIStabilizerSystem: System {
    /// Query for entities with UIStabilizer component
    static let query = EntityQuery(where: .has(UIAttachmentComponent.self))
    
    /// Initialize the system with the RealityKit scene
    public required init(scene: Scene) { }
    
    /// Update UI elements with stabilizer component
    public func update(context: SceneUpdateContext) {
        // Query for cancer cells that have both marker and state components
        let cellQuery = EntityQuery(where: .has(CancerCellComponent.self) && .has(CancerCellStateComponent.self))
        let cells = context.scene.performQuery(cellQuery)
        
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            guard let attachment = entity.components[UIAttachmentComponent.self] else { continue }
            
            // Find target cell by state component's cellID
            guard let targetCell = cells.first(where: { entity in
                entity.components[CancerCellStateComponent.self]?.parameters.cellID == attachment.attachmentID
            }) else { continue }
            
            // Get target's world position and apply offset
            let targetPos = targetCell.position(relativeTo: nil)
            entity.setPosition(targetPos + attachment.offset, relativeTo: nil)
        }
    }
}

```

File: Systems/UIStateSyncSystem.swift
```swift
import RealityKit
import RealityKitContent

/// System responsible for syncing RealityKit state to UI components
class UIStateSyncSystem: System {
    static let query = EntityQuery(where: .has(CancerCellStateComponent.self))
    
    required init(scene: Scene) {}
    
    func update(context: SceneUpdateContext) {
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            guard let stateComponent = entity.components[CancerCellStateComponent.self] else { continue }
            
            // Write-through pattern: Sync from parameters to HitCountComponent
            entity.components.set(HitCountComponent(
                hitCount: stateComponent.parameters.hitCount,
                requiredHits: stateComponent.parameters.requiredHits,
                isDestroyed: stateComponent.parameters.isDestroyed
            ))
        }
    }
} 
```

File: Utility/CollisionGroups.swift
```swift
import RealityKit

extension CollisionGroup {
    static let cancerCell = CollisionGroup(rawValue: 1 << 0)
    static let adc = CollisionGroup(rawValue: 1 << 1)
    static let microscope = CollisionGroup(rawValue: 1 << 5)
    static let headTracking = CollisionGroup(rawValue: 1 << 6)
    // From reference project: Used to exclude objects from earth's gravity when using custom gravity
    static let actualEarthGravity = CollisionGroup(rawValue: 100 << 0)
}
```

File: Utility/ClosureComponent.swift
```swift
import SwiftUI
import RealityKit

struct ClosureComponent: Component {
    let closure: (TimeInterval) -> Void

    init(closure: @escaping (TimeInterval) -> Void) {
        self.closure = closure
    }
}

struct ClosureSystem: System {
    static let query = EntityQuery(where: .has(ClosureComponent.self))
    
    init(scene: RealityKit.Scene) {}
    
    func update(context: SceneUpdateContext) {
        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            guard let comp = entity.components[ClosureComponent.self] else { continue }
            comp.closure(context.deltaTime)
        }
    }
} 

```

File: Utility/Floats.swift
```swift
import Foundation
import simd

/// The type alias to create a new name for `SIMD3<Float>`.
typealias Float3 = SIMD3<Float>

/// The type alias to create a new name for `SIMD4<Float>`.
typealias Float4 = SIMD4<Float>

/// The type alias to create a new name for `simd_float4x4`.
typealias Float4x4 = simd_float4x4

extension Float3 {
    /// The initializer of a `Float3` from a `Float4`.
    init(_ float4: Float4) {
        self.init()
        x = float4.x
        y = float4.y
        z = float4.z
    }
    
    func length() -> Float {
        sqrt(x * x + y * y + z * z)
    }
    
    func normalized() -> Float3 {
        self * 1 / length()
    }
}

extension Float4 {
    func toFloat3() -> Float3 {
        Float3(self)
    }
}

extension Float4x4 {
    func translation() -> Float3 {
        columns.3.toFloat3()
    }
    
    func forward() -> Float3 {
        columns.2.toFloat3().normalized()
    }
}
```

File: Utility/Gravity.swift
```swift
import RealityKit

struct Gravity: ForceEffectProtocol {
    var parameterTypes: PhysicsBodyParameterTypes { [.position, .distance] }
    var forceMode: ForceMode { .force }
    
    var gravityMagnitude: Float = 0.1
    var minimumDistance: Float = 0.2
    
    func update(parameters: inout ForceEffectParameters) {
        guard let distances = parameters.distances,
              let positions = parameters.positions else { return }
        
        for index in 0..<parameters.physicsBodyCount {
            let distance = distances[index]
            let position = positions[index]
            
            guard distance > minimumDistance else { continue }
            
            let force = computeForce(position: position, distance: distance)
            parameters.setForce(force, index: index)
        }
    }
    
    func computeForce(position: SIMD3<Float>, distance: Float) -> SIMD3<Float> {
        let towardsCenter = normalize(position) * -1
        return towardsCenter * gravityMagnitude / pow(distance, 2)
    }
}
```

File: Utility/HeadTracker.swift
```swift
import SwiftUI
import RealityKit
import ARKit
import RealityKitContent

@MainActor
class HeadTracker: ObservableObject {
    let arSession = ARKitSession()
    let worldTracking = WorldTrackingProvider()
    
    // Configuration
    struct Configuration {
        var heightOffset: Float = 0.0
        var collisionRadius: Float = 0.1
    }
    var config = Configuration()
    
    // Tracking entities
    private var headCollisionEntity: ModelEntity?
    
    @Published var isTracking: Bool = false
    
    // Initial placement
    func getInitialHeadAnchor() -> AnchorEntity {
        let anchor = AnchorEntity(.head)
        anchor.anchoring.trackingMode = .once
        return anchor
    }
    
    // Continuous tracking setup
    func setupCollisionTracking() -> ModelEntity {
        let collisionEntity = ModelEntity(
            mesh: .generateBox(size: config.collisionRadius),
            materials: [SimpleMaterial(color: .clear, isMetallic: false)]
        )
        collisionEntity.name = "HeadCollisionSphere"
        
        collisionEntity.components.set(InputTargetComponent())
        // collisionEntity.components.set(RealityKitContent.GestureComponent())
        
        collisionEntity.collision = CollisionComponent(
            shapes: [.generateSphere(radius: config.collisionRadius)],
            mode: .default,
            filter: CollisionFilter(
                group: CollisionGroup(rawValue: 1),
                mask: .all
            )
        )
        
        // let physicsBody = PhysicsBodyComponent(
        //     shapes: [.generateSphere(radius: config.collisionRadius)],
        //     mass: 1.0,
        //     mode: .static
        // )
        // collisionEntity.components.set(physicsBody)
        collisionEntity.components.set(RealityKitContent.MicroscopeViewerComponent())
        
        self.headCollisionEntity = collisionEntity
        return collisionEntity
    }
    
    func startTracking() async {
        guard WorldTrackingProvider.isSupported else {
            print("HeadTracker: WorldTrackingProvider not supported")
            return
        }
        
        do {
            try await arSession.run([worldTracking])
            isTracking = true
            print("HeadTracker: Started tracking")
        } catch {
            print("Error: \(error). Head-position mode will still work.")
        }
    }
    
    func stopTracking() {
        Task {
            arSession.stop()
            headCollisionEntity?.removeFromParent()
            headCollisionEntity = nil
            isTracking = false
        }
    }
    
    // Update collision entity position
    func updateHeadPosition() {
        guard let transform = worldTracking.queryDeviceAnchor(atTimestamp: CACurrentMediaTime())?.originFromAnchorTransform else {
            if isTracking {
                print("HeadTracker: Failed to get head position")
            }
            return
        }
        headCollisionEntity?.transform = Transform(matrix: transform)
        
        // Debug position
        // if let entity = headCollisionEntity {
        //     print("\n=== Head Tracker Update ===")
        //     print("Entity Name: \(entity.name)")
        //     print("World Position: \(entity.position(relativeTo: nil))")
        //     print("Local Position: \(entity.position)")
        //     print("Has Collision Component: \(entity.components[CollisionComponent.self] != nil)")
        // }
    }
} 

```

File: Utility/IBLUtility.swift
```swift
import RealityKit
import SwiftUI

enum IBLUtility {
    /// Adds Image-Based Lighting to a RealityKit scene
    /// - Parameters:
    ///   - root: The root entity to add the IBL to
    ///   - imageName: Name of the IBL image file (without extension)
    ///   - intensity: The intensity exponent of the IBL (default: 1.0)
    static func addImageBasedLighting(
        to root: Entity,
        imageName: String,
        intensity: Float = 1.0
    ) async throws {
        // Load the image-based lighting resource
        guard let iblURL = Bundle.main.url(forResource: imageName, withExtension: "exr") else {
            fatalError("Failed to load the Image-Based Lighting file: \(imageName).exr")
        }
        
        print("IBL URL: \(iblURL)")
        
        let iblEnv = try await EnvironmentResource(fromImage: iblURL)
        
        // Set up image-based lighting
        let iblEntity = await Entity()
        var iblComp = ImageBasedLightComponent(source: .single(iblEnv), intensityExponent: intensity)
        iblComp.inheritsRotation = true
        await iblEntity.components.set(iblComp)
        
        // Add IBL receiver component to the root
        await root.components.set(ImageBasedLightReceiverComponent(imageBasedLight: iblEntity))
        await root.addChild(iblEntity)
    }
}

```

File: Utility/Logger.swift
```swift
import Foundation
import os

/// A simple logging utility that wraps Apple's os_log API.
public struct Logger {
    private static let subsystem = Bundle.main.bundleIdentifier ?? "com.PfizerOutdoCancer.app"

    public static func info(_ message: String) {
        let log = OSLog(subsystem: subsystem, category: "INFO")
        os_log("%@", log: log, type: .info, message)
    }
    
    public static func debug(_ message: String) {
        let log = OSLog(subsystem: subsystem, category: "DEBUG")
        os_log("%@", log: log, type: .debug, message)
    }
    
    public static func error(_ message: String) {
        let log = OSLog(subsystem: subsystem, category: "ERROR")
        os_log("%@", log: log, type: .error, message)
    }
    
    public static func fault(_ message: String) {
        let log = OSLog(subsystem: subsystem, category: "FAULT")
        os_log("%@", log: log, type: .fault, message)
    }
    
    // New function for audio logging
    public static func audio(_ message: String) {
        let log = OSLog(subsystem: subsystem, category: "AUDIO")
        os_log("%@", log: log, type: .debug, message)
    }
} 
```

File: Utility/PortalManager.swift
```swift
import SwiftUI
import RealityKit

@MainActor
final class PortalManager {
    /// Sets up the portal and adds it to the `root.`
    static func createPortal(appModel: AppModel, environment: Entity, portalPlaneName: String) async -> Entity {
        let root = Entity()

        let portalRoot = Entity()
        portalRoot.name = "portalRoot"
        portalRoot.position.y = 1.5
        portalRoot.position.z = -1.5
        
        // let titleRoot = Entity()
        // titleRoot.name = "titleRoot"
        // titleRoot.scale *= 0.5
        // titleRoot.position.z = 0.1
        
        // portalRoot.addChild(titleRoot)
        
        let portalPlane = ModelEntity(
            mesh: .generatePlane(width: 2.0, height: 1.0, cornerRadius: 0.3),
            materials: [PortalMaterial()]
        )
        portalPlane.name = "portalPlane"
        
        // Set initial x-scale to 0
        var transform = portalPlane.transform
        transform.scale.x = 0
        portalPlane.transform = transform
        
        
        
//        print("🎯 Created portal plane with name: \(portalPlane.name) and scale: \(portalPlane.transform.scale)")
        

        // Create the entity that stores the content within the portal.
        let world = Entity()
        world.name = "world"

        // Shrink the portal world and update the position
        // to make it fit into the portal view.
        world.scale *= 0.55
        world.position.y -= 0.25
        world.position.z -= 4.5

        // Allow the entity to be visible only through a portal.
        world.components.set(WorldComponent())
        
        // Add the provided lab environment to the world
        world.addChild(environment)
        
        root.addChild(world)

        // Set up the portal to show the content in the `world`.
        var portalComp = PortalComponent(target: world)
        portalComp.clippingMode = .disabled
        portalComp.crossingMode = .disabled
        portalPlane.components.set(portalComp)
        
        world.components[PortalCrossingComponent.self] = .init()
        
        portalRoot.addChild(portalPlane)
        root.addChild(portalRoot)

        return root
    }
}

```

File: Utility/RotationHelpers.swift
```swift
//
//  RotationHelpers.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/12/25.
//
import simd

public extension simd_quatf {
    // Return pitch, yaw, roll in radians
    func toEulerAngles() -> SIMD3<Float> {
        // Many ways to do this; here’s one typical approach
        print("extracting euler angles from quaternion")
        let ysqr = imag.y * imag.y

        // roll (x-axis rotation)
        let t0 = 2.0 * (real * imag.x + imag.y * imag.z)
        let t1 = 1.0 - 2.0 * (imag.x * imag.x + ysqr)
        let roll = atan2(t0, t1)

        // pitch (y-axis rotation)
        let t2 = 2.0 * (real * imag.y - imag.z * imag.x)
        let t2Clamped = max(min(t2, 1.0), -1.0)
        let pitch = asin(t2Clamped)

        // yaw (z-axis rotation)
        let t3 = 2.0 * (real * imag.z + imag.x * imag.y)
        let t4 = 1.0 - 2.0 * (ysqr + imag.z * imag.z)
        let yaw = atan2(t3, t4)

        // We'll define them as (pitch, yaw, roll) for clarity
        return [pitch, yaw, roll]
    }

    init(fromEuler angles: SIMD3<Float>) {
        let (pitch, yaw, roll) = (angles.x, angles.y, angles.z)
        let cy = cos(yaw * 0.5)
        let sy = sin(yaw * 0.5)
        let cr = cos(roll * 0.5)
        let sr = sin(roll * 0.5)
        let cp = cos(pitch * 0.5)
        let sp = sin(pitch * 0.5)

        self = simd_quatf(ix: sr * cp * cy - cr * sp * sy,
                          iy: cr * sp * cy + sr * cp * sy,
                          iz: cr * cp * sy - sr * sp * cy,
                          r:  cr * cp * cy + sr * sp * sy)
    }
}

public extension simd_quatf {
    /// Returns a rotation discarding pitch and roll, keeping only yaw
    func onlyYaw() -> simd_quatf {
        let e = self.toEulerAngles()  // (pitch, yaw, roll)
        return simd_quatf(fromEuler: [0, e.y, 0])
    }
}

```

File: Utility/UnorderedPair.swift
```swift
struct UnorderedPair<T> {
    let itemA: T
    let itemB: T
    
    init(_ itemA: T, _ itemB: T) {
        self.itemA = itemA
        self.itemB = itemB
    }
}

extension UnorderedPair: Equatable where T: Equatable {
    static func == (lhs: Self, rhs: Self) -> Bool {
        (lhs.itemA == rhs.itemA && lhs.itemB == rhs.itemB) || 
        (lhs.itemA == rhs.itemB && lhs.itemB == rhs.itemA)
    }
}

extension UnorderedPair: Hashable where T: Hashable {
    func hash(into hasher: inout Hasher) {
        hasher.combine(itemA.hashValue ^ itemB.hashValue)
    }
} 
```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+ADC.swift
```swift
//
//  AttackCancerViewModel+ADC.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 05.02.25.
//

import SwiftUI
import RealityKit
import RealityKitContent

extension AttackCancerViewModel {
    // MARK: - ADC Setup
    func setADCTemplate(_ template: Entity, dataModel: ADCDataModel) {
        print("\n🎯 Setting up ADC Template")
        print("- Template entity: \(template.name)")
        print("- Antibody Color: \(String(describing: dataModel.selectedADCAntibody ?? -1))")
        print("- Linker Color: \(String(describing: dataModel.selectedLinkerType ?? -1))")
        print("- Payload Color: \(String(describing: dataModel.selectedPayloadType ?? -1))")
        
        // Find and apply antibody color
        if let antibody = template.findModelEntity(named: "ADC_complex") {
            if let antibodyColor = dataModel.selectedADCAntibody,
               let modelComponent = antibody.components[ModelComponent.self] {
                if modelComponent.materials.first is ShaderGraphMaterial {
                    antibody.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[antibodyColor])
                    #if DEBUG
                    print("✅ Applied antibody color: \(antibodyColor)")
                    #endif
                }
            }
        }
        
        // Find and apply linker colors (all 4)
        for i in 1...4 {
            let offsetName = "linker0\(i)_offset"
            if let linker = template.findModelEntity(named: "linker", from: offsetName) {
                if let linkerColor = dataModel.selectedLinkerType {
                    // old PBR shader
                    linker.updatePBRDiffuseColor(.adc[linkerColor])
                    // new shaderGraph material
                    linker.updateShaderGraphColor(parameterName: "Basecolor_Tint", color: .adc[linkerColor])
                    #if DEBUG
                    print("✅ Applied linker color \(linkerColor) to \(offsetName)")
                    #endif
                }
            }
        }
        
        // Find and apply payload colors (all 4 sets of inner/outer)
        for i in 1...4 {
            let offsetName = "linker0\(i)_offset"
            if let inner = template.findModelEntity(named: "InnerSphere", from: offsetName),
               let outer = template.findModelEntity(named: "OuterSphere", from: offsetName) {
                if let payloadColor = dataModel.selectedPayloadType {
                    inner.updatePBREmissiveColor(.adcEmissive[payloadColor])
                    outer.updateShaderGraphColor(parameterName: "glowColor", color: .adc[payloadColor])
                    #if DEBUG
                    print("✅ Applied payload color \(payloadColor) to \(offsetName)")
                    #endif
                }
            }
        }
        
        adcTemplate = template
        print("✅ ADC template stored in gameState")
    }
    
    // MARK: - ADC Spawning
    func spawnADC(from position: SIMD3<Float>, targetPoint: Entity, forCellID cellID: Int) async {
        guard let template = adcTemplate,
              let root = rootEntity else {
            return
        }
        
        totalADCsDeployed += 1
        #if DEBUG
        print("\n=== Spawning Natural ADC ===")
        print("Start World Position: \(position)")
        print("Target World Position: \(targetPoint.position(relativeTo: nil))")
        print("Target Cell ID: \(cellID)")
        print("✅ ADC #\(totalADCsDeployed) Launched (Total Taps: \(totalTaps))")
        #endif
        
        // Set the flag for first ADC fired
        if !hasFirstADCBeenFired {
            hasFirstADCBeenFired = true
        }
        
        // Clone the template (colors will be cloned with it)
        let adc = template.clone(recursive: true)
        
        // Set up collision so that the ADC is recognized as 'adc' by cancer cells
        let shape = ShapeResource.generateSphere(radius: 0.069)
        let collision = CollisionComponent(
            shapes: [shape],
            filter: .init(group: .adc, mask: .cancerCell)
        )
        adc.components.set(collision)

        // New: Add a PhysicsBodyComponent so the ADC gets picked up by the physics simulation
        // let physicsBody = PhysicsBodyComponent(shapes: [shape], mass: 0.0, mode: .kinematic)
        // adc.components.set(physicsBody)
        
        // Update ADCComponent properties
        guard var adcComponent = adc.components[ADCComponent.self] else { return }
        adcComponent.targetCellID = cellID
        adcComponent.startWorldPosition = position  // Use the hand position
        adcComponent.proteinSpinSpeed = Float.random(in: 8.0...10.0)  // Set random spin speed per instance
        adc.components[ADCComponent.self] = adcComponent
        
        // Set initial position
        adc.position = position
        
        // Add to scene
        root.addChild(adc)
        
        // Start movement
        ADCMovementSystem.startMovement(entity: adc, from: position, to: targetPoint)
    }
    
    /// Spawns an ADC without a specific target, moving in the direction the user is looking
    func spawnUntargetedADC(from position: SIMD3<Float>) async {
        guard let template = adcTemplate,
              let root = rootEntity else {
            print("❌ Failed to spawn untargeted ADC: missing template or root")
            return
        }
        
        // Create headPosition entity with random positioning
        let headPosition = Entity()
        headPosition.name = "headPosition"
        
        // Random offsets
        let randomX = Float.random(in: -2.0...2.0)
        let randomY = Float.random(in: 1.0...2.5)
        let randomZ = Float.random(in: -7.0...(-6.5))

        // Compensate for root entity's Z offset
        let adjustedZ = randomZ + 1.0  // Add 1.0 to compensate for headTrackingRoot's -1.0 offset

        // Set position with compensation for root offset
        headPosition.position = SIMD3<Float>(randomX, randomY, adjustedZ)
        
        // Create positioning component
        // let positioning = PositioningComponent(
        //     offsetX: randomX,
        //     offsetY: randomY,
        //     offsetZ: randomZ
        // )
        
        // Create attachment point and mark as occupied
        var attachPoint = AttachmentPoint()
        attachPoint.isOccupied = true
        attachPoint.isUntargeted = true
        
        // Add components using proper lifecycle management
        
        // try await headPosition.components.set(positioning)
        headPosition.components.set(attachPoint)
       
        // Add headPosition to the scene's root to avoid ADC root offset
        print("DEBUG: Root entity details:")
        print("- Name: \(root.name)")
        print("- World position: \(root.position(relativeTo: nil))")
        print("- Local position: \(root.position)")
        
        root.addChild(headPosition)
        
        print("DEBUG: HeadPosition target details:")
        print("- Local position set: \(headPosition.position)")
        print("- World position after add: \(headPosition.position(relativeTo: nil))")
        print("- Parent entity: \(headPosition.parent?.name ?? "none")")
        
        totalADCsDeployed += 1
        #if DEBUG
        print("\n=== Spawning Untargeted ADC ===")
        print("Start World Position: \(position)")
        print("Target World Position: \(headPosition.position(relativeTo: nil))")
        print("✅ ADC #\(totalADCsDeployed) Launched (Total Taps: \(totalTaps))")
        #endif
        
        // Set the flag for first ADC fired
        if !hasFirstADCBeenFired {
            hasFirstADCBeenFired = true
        }
        
        // Clone the template (colors will be cloned with it)
        let adc = template.clone(recursive: true)
        
        // Create ADC components
        let shape = ShapeResource.generateSphere(radius: 0.069)
        let collision = CollisionComponent(
            shapes: [shape],
            filter: .init(group: .adc, mask: .cancerCell)
        )
        
        // Set up ADC component
        guard var adcComponent = adc.components[ADCComponent.self] else { return }
        adcComponent.state = .moving  // Use moving state instead of seeking
        adcComponent.startWorldPosition = position
        adcComponent.proteinSpinSpeed = Float.random(in: 8.0...10.0)
        adcComponent.speedFactor = Float.random(in: ADCMovementSystem.speedRange)
        adcComponent.arcHeightFactor = Float.random(in: ADCMovementSystem.arcHeightRange)
        
        // Add components using proper lifecycle management
        
        adc.components.set(collision)
        adc.components.set(adcComponent)
     
        
        // Set initial position
        adc.position = position
        
        // Add to scene
        root.addChild(adc)
        
        // Start movement using headPosition entity as target
        ADCMovementSystem.startMovement(entity: adc, from: position, to: headPosition)
        
        print("✅ Untargeted ADC spawned successfully")
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+Collisions.swift
```swift
//
//  AttackCancerViewModel+Collisions.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 05.02.25.
//

import SwiftUI
import RealityKit
import RealityKitContent
import Combine

extension AttackCancerViewModel {
    // MARK: - Collision Setup
    func setupCollisions(in entity: Entity) {
        print("setting up collisions in \(entity.name)")
        // Cancel any existing subscription first
        subscription?.cancel()
        subscription = nil
        
        if let scene = entity.scene {
            let query = EntityQuery(where: .has(BloodVesselWallComponent.self))
            let objectsToModify = scene.performQuery(query)
            
            for object in objectsToModify {
                if var collision = object.components[CollisionComponent.self] {
                    collision.filter.group = .cancerCell
                    collision.filter.mask = .cancerCell
                    object.components[CollisionComponent.self] = collision
                }
            }
            setupCollisionSubscription(with: scene)
        }
    }
    
    // MARK: - Collision Subscription
    func setupCollisionSubscription(with scene: RealityKit.Scene) {
        print("🎯 Setting up collision subscription")
        // Store the SceneEventSubscription
        subscription = scene.subscribe(to: CollisionEvents.Began.self) { [weak self] event in
        //    print("💥 Collision event received")
            guard let self = self else { return }
            self.handleCollisionBegan(event)
        }
        print("✅ Collision subscription set up")
    }
    
    // MARK: - Collision Handling
    func handleCollisionBegan(_ event: CollisionEvents.Began) {

        guard shouldHandleCollision(event) else { return }
        
        // Check for head-microscope collision - only play sound, no transition
        if hasHeadCollision(event) && hasMicroscopeCollision(event) {
            print("Head collision with microscope detected")
            Task {
                await appModel.transitionToPhase(.building)
            }
            return
        }
        
        let entities = UnorderedPair(event.entityA, event.entityB)
        
        // Handle ADC-to-cell collisions
        if let _ = entities.itemA.components[ADCComponent.self],
           let _ = entities.itemB.components[CancerCellStateComponent.self] {
            handleADCToCellCollision(adc: entities.itemA, cell: entities.itemB, collision: event)
        } else if let _ = entities.itemB.components[ADCComponent.self],
                  let _ = entities.itemA.components[CancerCellStateComponent.self] {
            handleADCToCellCollision(adc: entities.itemB, cell: entities.itemA, collision: event)
        }
    }
    
    private func handleADCToCellCollision(adc: Entity, cell: Entity, collision: CollisionEvents.Began) {
        print("\n=== ADC-Cell Collision ===")
        print("ADC: \(adc.name)")
        print("Cell: \(cell.name)")
        
        guard let stateComponent = cell.components[CancerCellStateComponent.self],
              let cellID = stateComponent.parameters.cellID,
              let parameters = cellParameters.first(where: { $0.cellID == cellID }) else {
            print("❌ Failed to handle collision - missing state component or parameters")
            return
        }
        
        // Check if this ADC is targeting this cell
        if let adcComponent = adc.components[ADCComponent.self],
           adcComponent.targetCellID == cellID {
            // Set the collision flag
            var updatedComponent = adcComponent
            updatedComponent.hasCollided = true
            adc.components[ADCComponent.self] = updatedComponent
            print("✅ ADC collision flag set for target cell \(cellID)")
        }
        
        print("💥 ADC hit cell \(cellID)")
        print("Current hit count: cellParameters \(parameters.hitCount)")
        
        // Update parameters (source of truth) - but trying stateComponent.parameters.hitCount += 1 because it was double counting
        // stateComponent.parameters.hitCount += 1
        // stateComponent.parameters.wasJustHit = true

        print("Current hit count: StateComponent \(stateComponent.parameters.hitCount)")
        
        // Apply scaled physics impact if enabled
        if parameters.physicsEnabled {
            // Scale the collision impulse based on the cell's impact scale, then reduce to 10%
            let scaledImpulse = collision.impulse * parameters.impactScale * 0.1
            
            // Store impact values in parameters for reference (logging, analytics, etc.)
            parameters.linearVelocity = collision.impulseDirection * scaledImpulse
            
            // Calculate angular velocity based on impulse
            let randomRotation = SIMD3<Float>(
                Float.random(in: -1...1),
                Float.random(in: -1...1),
                Float.random(in: -1...1)
            )
            parameters.angularVelocity = normalize(randomRotation) * (scaledImpulse * 2.0)
            
            // NEW: actually apply the impulse to the cell's PhysicsMotionComponent
            var motion = cell.components[PhysicsMotionComponent.self] ?? PhysicsMotionComponent()
            motion.linearVelocity += collision.impulseDirection * scaledImpulse
            motion.angularVelocity += normalize(randomRotation) * (scaledImpulse * 2.0)
            cell.components.set(motion)
            
            if parameters.isTutorialCell {
                print("Tutorial cell impact - using scale: \(parameters.impactScale), impulse: \(scaledImpulse)")
            }
        }
        
        print("New hit count: \(parameters.hitCount)")
        print("Required hits: \(parameters.requiredHits)")
        
        // Check if cell is destroyed
//        if parameters.hitCount >= parameters.requiredHits {
//            print("🎯 Cell \(cellID) destroyed!")
//            parameters.isDestroyed = true
//            // Let the CancerCellSystem handle the destruction effects
//        }
        
        // Always remove the ADC
        // adc.removeFromParent()
    }
    
    private func shouldHandleCollision(_ collision: CollisionEvents.Began) -> Bool {
        // let entities = UnorderedPair(collision.entityA, collision.entityB)
        // let currentTime = Date().timeIntervalSinceReferenceDate
        
        // if let lastCollisionTime = debounce[entities] {
        //     if currentTime - lastCollisionTime < debounceThreshold {
        //         return false
        //     }
        // }
        
        // debounce[entities] = currentTime
        return true
    }
    
    private func hasHeadCollision(_ collision: CollisionEvents.Began) -> Bool {
        let entityA = collision.entityA
        let entityB = collision.entityB
        
        return entityA.name == "head" || entityB.name == "head"
    }
    
    private func hasMicroscopeCollision(_ collision: CollisionEvents.Began) -> Bool {
        let entityA = collision.entityA
        let entityB = collision.entityB
        
        let hasCollision = entityA.components[CollisionComponent.self]?.filter.group == .microscope ||
                          entityB.components[CollisionComponent.self]?.filter.group == .microscope
        
        return hasCollision
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+GameStats.swift
```swift
import SwiftUI
import RealityKitContent
import RealityKit

extension AttackCancerViewModel {
    // MARK: - Game Methods

    /// Resets game state variables to their initial values without affecting entities or scene content.
    /// Use this when you want to restart the game state while keeping the current scene setup.
    ///
    /// Responsibilities:
    /// - Resets game statistics (scores, counters)
    /// - Resets state flags (tutorial state, game phase)
    /// - Resets head positioning state
    /// - Does NOT modify any entities or scene content
    /// - Does NOT affect system connections or subscriptions
    ///
    /// Call this when:
    /// - Starting a new game session
    /// - Restarting after game over
    /// - Resetting tutorial state
    func resetGameState() {
        Logger.debug("""
        
        🔄 Resetting Game State
        ├─ Cells Destroyed: \(cellsDestroyed) → 0
        ├─ Total ADCs: \(totalADCsDeployed) → 0
        ├─ Total Taps: \(totalTaps) → 0
        ├─ Total Hits: \(totalHits) → 0
        └─ Head Positioning: Resetting tracking state
        """)

        cellsDestroyed = 0
        totalADCsDeployed = 0
        totalTaps = 0
        totalHits = 0
        
        hopeMeterTimeLeft = hopeMeterDuration
        isHopeMeterRunning = false
        hasFirstADCBeenFired = false

        // Reset all cell parameters
        for i in 0..<cellParameters.count {
            cellParameters[i].hitCount = 0
            cellParameters[i].isDestroyed = false
        }
        
        // Reset head positioning state
        isRootSetupComplete = false
        isEnvironmentSetupComplete = false
        isHeadTrackingRootReady = false
        shouldUpdateHeadPosition = false
        
        Logger.debug("""
        
        🎯 Head Positioning Reset Complete
        ├─ Root Setup: \(isRootSetupComplete ? "✅" : "❌")
        ├─ Environment: \(isEnvironmentSetupComplete ? "✅" : "❌")
        ├─ Head Tracking: \(isHeadTrackingRootReady ? "✅" : "❌")
        └─ Update Pending: \(shouldUpdateHeadPosition ? "✅" : "❌")
        """)
        
        // Reset hope meter
        hopeMeterTimeLeft = hopeMeterDuration
        isHopeMeterRunning = false
        
        // Reset tutorial state to match first play
        tutorialComplete = false
        appModel.isTutorialStarted = false  // This will trigger the tutorial sequence
        isTestFireActive = false
        testFireComplete = false
        readyToStartGame = false
        isSetupComplete = false
        
        appModel.currentPhase = .playing
        appModel.isInstructionsWindowOpen = true
        appModel.isHopeMeterUtilityWindowOpen = false  // Let the tutorial sequence open this at 24s

        print("🔄 Reset tutorial state: isTutorialStarted: \(appModel.isTutorialStarted), tutorialComplete: \(tutorialComplete), isTestFireActive: \(isTestFireActive), readyToStartGame: \(readyToStartGame)")

    }
    
    // MARK: - ADC Tracking
    func incrementADCsDeployed() {
        totalADCsDeployed += 1
    }
    
    var score: Int {
        // Base score from destroyed cells
        let baseScore = cellsDestroyed * 100
        
        // Efficiency penalty based on ADCs used
        let efficiency = totalADCsDeployed > 0 ? Float(cellsDestroyed) / Float(totalADCsDeployed) : 0
        let efficiencyBonus = Int(efficiency * 50)
        
        return baseScore + efficiencyBonus
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+HandInteraction.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

extension AttackCancerViewModel {
    // MARK: - Tap Handling
    func handleTap(on entity: Entity, location: SIMD3<Float>, in scene: RealityKit.Scene?) async {
        print("\n=== Tapped Entity ===")
        print("Entity name: \(entity.name)")
//        appModel.assetLoadingManager.inspectEntityHierarchy(entity)
        
        // Get pinch distances for both hands to determine which hand tapped
        let leftPinchDistance = handTracking.getPinchDistance(.left) ?? Float.infinity
        let rightPinchDistance = handTracking.getPinchDistance(.right) ?? Float.infinity
        
        // Determine which hand's position to use
        let handPosition: SIMD3<Float>?
        if leftPinchDistance < rightPinchDistance {
            handPosition = handTracking.getFingerPosition(.left)
            print("Left hand tap detected")
        } else {
            handPosition = handTracking.getFingerPosition(.right)
            print("Right hand tap detected")
        }
        
        // Ensure we have a valid scene
        guard let scene = scene else {
            print("No scene available")
            return
        }
        
        // Use hand position if available, otherwise use provided location
        let spawnPosition = handPosition ?? location
        
        // Check if we can target a cancer cell
        if let stateComponent = entity.components[CancerCellStateComponent.self],
           let cellID = stateComponent.parameters.cellID {
            print("Found cancer cell with ID: \(cellID)")
            
            // Use the new approach-aware getAvailablePoint
            if let attachPoint = AttachmentSystem.getAvailablePoint(in: scene, forCellID: cellID, approachPosition: spawnPosition) {
                print("Found attach point: \(attachPoint.name)")
                AttachmentSystem.markPointAsOccupied(attachPoint)
                await spawnADC(from: spawnPosition, targetPoint: attachPoint, forCellID: cellID)
            } else {
                print("No available attach point found")
                await spawnUntargetedADC(from: spawnPosition)
            }
        } else {
            // No valid cancer cell target - spawn untargeted ADC
        if Double.random(in: 0..<1) < hitProbability {
            print("Spawning untargeted ADC based on random chance")
            await spawnUntargetedADC(from: spawnPosition)
        } else {
            print("Skipping untargeted ADC spawn due to random chance")
        }
        }
    }

    func setupHandTracking(in content: RealityViewContent, attachments: RealityViewAttachments? = nil) {
        // Add the hand tracking content entity which includes the debug spheres
        content.add(appModel.trackingManager.handTrackingManager.setupContentEntity())
        
        // Create a separate anchor for the HopeMeter UI
//        let uiAnchor = AnchorEntity(.hand(.left, location: .aboveHand))
//        content.add(uiAnchor)
        
        // if let attachmentEntity = attachments.entity(for: "HopeMeter") {
        //     attachmentEntity.components[BillboardComponent.self] = BillboardComponent()
        //     attachmentEntity.scale *= 0.6
        //     attachmentEntity.position.z -= 0.02
        //     uiAnchor.addChild(attachmentEntity)
        // }
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+Spawning.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

extension AttackCancerViewModel {
    func spawnCancerCells(in root: Entity, from template: Entity, count: Int) async {
        Logger.info("\n=== Starting Cancer Cell Spawning ===")
        Logger.info("Target count: \(count)")
        
        // Create force entity with central gravity
        let forceEntity = createForceEntity()
        root.addChild(forceEntity)
        
        // Track front vs back spawns to ensure good distribution
        var frontSpawnCount = 0
        
        // Spawn cells sequentially
        for i in 0..<count {
            // Prefer front until we have enough there (50% in front)
            let preferFront = frontSpawnCount < Int(Double(count) * 0.5)
            
            // Spawn single cell
            if await spawnSingleCancerCell(in: root, from: template, index: i, preferFront: preferFront) != nil {
                // Track if this was a front spawn
                if preferFront {
                    frontSpawnCount += 1
                }
                
                // Small delay between spawns
                try? await Task.sleep(for: .seconds(0.2))
            }
        }
        
        Logger.info("=== Finished Spawning ===")
        Logger.info("Total parameters created: \(cellParameters.count)")
        Logger.info("Initial cellsDestroyed count: \(appModel.gameState.cellsDestroyed)")
    }
    
    private func spawnSingleCancerCell(in root: Entity, from template: Entity, index: Int, preferFront: Bool) async -> Entity? {
        Logger.info("\n=== Spawning Cancer Cell \(index) ===")
        
        let cell = template.clone(recursive: true)
        cell.name = "cancer_cell_\(index)"
        
        if let complexCell = cell.findEntity(named: "cancerCell_complex") {
            // Start with zero scale instead of zero opacity
            // complexCell.transform.scale = .init(repeating: 0)
            complexCell.opacity = 0
            
            // Setup all the physical aspects first
            configureCellPosition(complexCell, preferFront: preferFront)
            configureCellPhysics(complexCell)
            configureCellMovement(complexCell)
            setupCellIdentification(complexCell, cellID: index)
            
            // Create parameters on-demand
            let parameters = CancerCellParameters(cellID: index)
            Logger.info("Creating parameters for cell \(index)")
            Logger.info("Required hits: \(parameters.requiredHits)")
            cellParameters.append(parameters)
            Logger.info("Total parameters after append: \(cellParameters.count)")
            
            // Add state component with reference to parameters
            cell.components.set(CancerCellStateComponent(parameters: parameters))
            Logger.info("Added CancerCellStateComponent with parameters")
            
            root.addChild(cell)
            setupAttachmentPoints(for: cell, complexCell: complexCell, cellID: index)

            // Fade in after setup
            await complexCell.fadeOpacity(to: 1.0, duration: 0.5)
            Logger.info("✅ Successfully spawned cell \(index)")
            return cell
        } else {
            Logger.error("❌ Warning: Could not find cancerCell_complex entity")
            return nil
        }
    }
    
    private func createForceEntity() -> Entity {
        let forceEntity = Entity()
        // REF: Planet is positioned at [0, 0.5, -2] relative to device in reference project
        forceEntity.position = [0, 1.5, 0]  // Center point where we want gravity
        
        // REF: gravityMagnitude = 0.1 in reference Gravity.swift
        let gravityMagnitude: Float = 0.1
        // REF: minimumDistance = 0.2 in reference Gravity.swift
        let gravity = Gravity(gravityMagnitude: gravityMagnitude, minimumDistance: 0.2)
        // REF: mask = .all.subtracting(.actualEarthGravity) in reference Entity+Planet.swift
        let forceEffect = ForceEffect(
            effect: gravity,
            mask: .all.subtracting(.actualEarthGravity)
        )
        forceEntity.components.set(ForceEffectComponent(effects: [forceEffect]))
        return forceEntity
    }
    
    private func configureCellPosition(_ cell: Entity, preferFront: Bool) {
        // Generate random orbit parameters
        let radius = Float.random(in: 2.0...5.0)  // Increased radius range for more spread
        let height = Float.random(in: 0.0...3.5)  // Increased height range, starting from ground level
        
        // If preferring front, use angle range favoring right side (-30° to +60°)
        let theta: Float
        if preferFront {
            theta = Float.random(in: -Float.pi/6...Float.pi/3)  // -30° to +60°
        } else {
            // For back spawns, favor right side (120° to 270°)
            theta = Float.random(in: 2*Float.pi/3...3*Float.pi/2)
        }
        
        // Place cell on orbit
        // Note: Using negative cos for Z to spawn in front (-Z)
        cell.position = [
            sin(theta) * radius,  // X position on circle
            height,
            -cos(theta) * radius  // Z position on circle (negative for front)
        ]
    }
    
    private func configureCellPhysics(_ cell: Entity) {
        // REF: Planet uses radius = 0.12 or 0.25 in reference project
        let shape2 = ShapeResource.generateSphere(radius: 0.32)  // Cancer cell size
        let collisionComponent2 = CollisionComponent(
            shapes: [shape2],
            filter: .init(group: .cancerCell, mask: .all)
        )
        cell.components.set(collisionComponent2)
        
        // REF: Planet uses mass = 1.0 in reference project
        var physicsBody2 = PhysicsBodyComponent(shapes: [shape2], mass: 1.0, mode: .dynamic)
        // REF: isAffectedByGravity = false in reference project (uses custom gravity)
        physicsBody2.isAffectedByGravity = false
        // REF: linearDamping = 0 in reference project
        physicsBody2.linearDamping = 0
        // REF: angularDamping = 0 in reference project
        physicsBody2.angularDamping = 0
        cell.components[PhysicsBodyComponent.self] = physicsBody2
        
        // Add PhysicsMotionComponent for impulse application
        cell.components.set(PhysicsMotionComponent())
    }
    
    private func configureCellMovement(_ cell: Entity) {
        // Calculate orbital parameters
        let radius = sqrt(cell.position.x * cell.position.x + cell.position.z * cell.position.z)
        let theta = atan2(cell.position.x, cell.position.z)
        
        // Calculate orbital velocity exactly like reference
        // REF: orbitSpeed = sqrt(gravityMagnitude / radius) in reference Entity+Planet.swift calculateVelocity()
        let gravityMagnitude: Float = 0.1
        let baseSpeed = sqrt(gravityMagnitude / radius) * 0.5
        let minSpeed: Float = 0.15 // or whatever feels right
        let orbitSpeed = max(baseSpeed, minSpeed)
        
        // REF: Direction calculation matches reference Entity+Planet.swift calculateVelocity()
        let orbitDirection = SIMD3<Float>(
            cos(theta),   // X component
            0,            // No vertical velocity
            -sin(theta)   // Z component
        )
        
        // REF: Angular velocity = [0, 1, 0] * 0.3 in reference Entity+Planet.swift
        let rx = Float.random(in: -1...1)
        let ry = Float.random(in: -1...1)
        let rz = Float.random(in: -1...1)
        var spin = SIMD3<Float>(rx, ry, rz)

        // If length is tiny, normalize to some minimum spin
        let minSpinMagnitude: Float = 0.5
        let spinLength = simd_length(spin)
        if spinLength < 0.001 {
            // re-randomize or just pick a default axis
            spin = SIMD3<Float>(0,1,0)
        } else if spinLength < minSpinMagnitude {
            spin = normalize(spin) * minSpinMagnitude
        }

        let motionComponent = PhysicsMotionComponent(
            linearVelocity: orbitDirection * orbitSpeed,
            angularVelocity: spin
        )
        cell.components.set(motionComponent)
        
        // NEW: Store the base velocity for later speed adjustments in the speed boost system.
        cell.components.set(CancerCellMovementData(baseLinearVelocity: orbitDirection * orbitSpeed))
    }
    
    private func setupCellIdentification(_ cell: Entity, cellID: Int) {
        // Verify we have the marker component from RCP
        if cell.components.has(CancerCellComponent.self) {
            // Only add state component if it doesn't already exist
            if !cell.components.has(CancerCellStateComponent.self) {
                // Add our state component if not present
                let parameters = CancerCellParameters(cellID: cellID)
                let stateComponent = CancerCellStateComponent(parameters: parameters)
                cell.components.set(stateComponent)
            }
        }
    }
    
    private func setupAttachmentPoints(for cell: Entity, complexCell: Entity, cellID: Int) {
        if let scene = cell.scene {
            let attachPointQuery = EntityQuery(where: .has(AttachmentPoint.self))
            for entity in scene.performQuery(attachPointQuery) {
                // Check if this attachment point is part of our cell's hierarchy
                var current = entity.parent
                while let parent = current {
                    if parent == complexCell {
                        var attachPoint = entity.components[AttachmentPoint.self]!
                        attachPoint.cellID = cellID
                        entity.components[AttachmentPoint.self] = attachPoint
                        // Logger.info("Set cellID \(cellID) for attachment point \(entity.name)")
                        break
                    }
                    current = parent.parent
                }
            }
        }
    }
    
    func setupTutorialCancerCell(_ cell: Entity) {
        Logger.info("\n=== Setting up Tutorial Cancer Cell ===")
        
        if let complexCell = cell.findEntity(named: "cancerCell_complex") {
            // Setup all the physical aspects first (minus position and movement)
            // configureCellPhysics(complexCell)
            configureTestCellPhysics(complexCell, physicsEnabled: false)
            
            // Create parameters before calling setupCellIdentification
            let parameters = CancerCellParameters(cellID: 777)
            parameters.isTutorialCell = true  // Mark as tutorial cell
            parameters.physicsEnabled = false  // Disable physics for tutorial cell
            parameters.impactScale = CancerCellParameters.tutorialImpactScale  // Use reduced impact
            parameters.requiredHits = 10  // Set required hits for tutorial
            cellParameters.append(parameters)
            
            // Create and set state component with our parameters
            let stateComponent = CancerCellStateComponent(parameters: parameters)
            complexCell.components.set(stateComponent)
            
            setupAttachmentPoints(for: cell, complexCell: complexCell, cellID: 777)
        }
    }
    
    // Modify spawnTestFireCell to use the new test configuration functions
    func spawnTestFireCell(in root: Entity) async {
         do {
            Logger.info("📱 Test Fire Cell: Loading test_fire_cell")
            let testFireScene = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "test_fire_cell",
                category: .attackCancerEnvironment
            )
            Logger.info("✅ Test Fire Cell: Retrieved test_fire_cell")
             
             if let testFireCellParent = root.findEntity(named: "headTrackingRoot") {
                 testFireScene.position = testFireCellParent.position
             }

            root.addChild(testFireScene)
             
             let index = 555
             
             if let complexCell = testFireScene.findEntity(named: "cancerCell_complex") {
                 
                 complexCell.opacity = 0
                 
                 // Setup all the physical aspects first (minus position and movement)
                 // configureCellPhysics(complexCell)
                 configureTestCellPhysics(complexCell, physicsEnabled: false)
                 
                 // Create parameters before calling setupCellIdentification
                 let parameters = CancerCellParameters(cellID: index)
                 parameters.isTutorialCell = true  // Mark as tutorial cell
                 parameters.physicsEnabled = false  // Disable physics for tutorial cell
                 parameters.impactScale = CancerCellParameters.tutorialImpactScale  // Use reduced impact
                 parameters.requiredHits = 4  // Set required hits for tutorial
                 cellParameters.append(parameters)
                 
                 // Create and set state component with our parameters
                 let stateComponent = CancerCellStateComponent(parameters: parameters)
                 complexCell.components.set(stateComponent)
                 
                 setupAttachmentPoints(for: testFireScene, complexCell: complexCell, cellID: index)
                 
                  // Fade in after setup
                  await complexCell.fadeOpacity(to: 1.0, duration: 0.5)
                  Logger.info("✅ Successfully spawned cell \(index)")

                  // set isTestFireActive to true
                  appModel.gameState.isTestFireActive = true
             }
        } catch {
            Logger.error("❌ Test Fire: Failed to instantiate cancer cell template: \(error)")
        }
    }

    private func configureTestCellPhysics(_ cell: Entity, physicsEnabled: Bool = true) {
        let shape = ShapeResource.generateSphere(radius: 0.32)  // Cancer cell size
        let collisionComponent = CollisionComponent(
            shapes: [shape],
            filter: .init(group: .cancerCell, mask: .all)
        )
        cell.components.set(collisionComponent)
        
        // Only add the physics body and motion component if physics is enabled.
        if physicsEnabled {
            var physicsBody = PhysicsBodyComponent(shapes: [shape], mass: 1.0, mode: .dynamic)
            physicsBody.isAffectedByGravity = false
            physicsBody.linearDamping = 0
            physicsBody.angularDamping = 0
            cell.components[PhysicsBodyComponent.self] = physicsBody
            cell.components.set(PhysicsMotionComponent())
        }
    }
    
    private func configureTestCellMovement(_ cell: Entity) {
        // Set linear velocity to zero to avoid orbiting
        let linearVelocity = SIMD3<Float>(0, 0, 0)
        
        // Calculate a random spin vector and reduce its intensity
        let rx = Float.random(in: -1...1)
        let ry = Float.random(in: -1...1)
        let rz = Float.random(in: -1...1)
        var spin = SIMD3<Float>(rx, ry, rz)
        let minSpinMagnitude: Float = 0.5
        let spinLength = simd_length(spin)
        if spinLength < 0.001 {
            spin = SIMD3<Float>(0, 1, 0)
        } else if spinLength < minSpinMagnitude {
            spin = normalize(spin) * minSpinMagnitude
        }
        // Scale spin to 60% for a visible, yet slowed, rotation
        spin *= 0.6
        
        let motionComponent = PhysicsMotionComponent(
            linearVelocity: linearVelocity,
            angularVelocity: spin
        )
        cell.components.set(motionComponent)
    }
}

```

File: ViewModels/IntroViewModel/IntroViewModel.swift
```swift
import Foundation
import RealityKit
import RealityKitContent
import SwiftUI

@Observable
@MainActor
final class IntroViewModel {
    // MARK: - Properties
    var introRootEntity: Entity?
    var scene: RealityKit.Scene?
    
    // Animation control flags
    var shouldUseSky = true  // New flag to control sky animation
    var skyDarkness: Float = 0.98
    
    // Animation task tracking
    private var animationTask: Task<Void, Never>?
    
    // Entity references
    private var portal: Entity?
    private var skyDome: Entity?
    private var logo: Entity?
    private var titleRoot: Entity?
    private var material: ShaderGraphMaterial?
    private var assembledLab: Entity?
    var introEnvironment: Entity?
    
    // Attachment entities
    var titleEntity: Entity?
    // var labViewerEntity: Entity?
    var navToggleEntity: Entity?
    
    // Animation States
    var showTitleText = false
    var shouldDimSurroundings = false
    var isSetupComplete = false
    
    // New flag to prevent duplicate environment loading
    var environmentLoaded = false
    
    // Dependencies
    var appModel: AppModel!
    
    // Root setup flags
    var isRootSetupComplete = false
    var isEnvironmentSetupComplete = false
    var isHeadTrackingRootReady = false
    var shouldUpdateHeadPosition = false
    var isPositioningComplete = false
    var isPositioningInProgress = false  // Add positioning progress flag
    
    var isReadyForHeadTracking: Bool {
        isRootSetupComplete && 
        isEnvironmentSetupComplete && 
        isHeadTrackingRootReady
    }
    
    // MARK: - Setup Methods
    func setupRoot() -> Entity {  // Renamed from setupIntroRoot
        Logger.info("""
        
        🔄 === INTRO VIEW INITIAL STATE ===
        ├─ Root Setup: \(isRootSetupComplete)
        ├─ Environment Setup: \(isEnvironmentSetupComplete)
        ├─ Head Tracking Ready: \(isHeadTrackingRootReady)
        ├─ Should Update Position: \(shouldUpdateHeadPosition)
        ├─ Positioning Complete: \(isPositioningComplete)
        ├─ Positioning In Progress: \(isPositioningInProgress)
        ├─ Has Root Entity: \(introRootEntity != nil)
        └─ Has Positioning Component: \(introRootEntity?.components[PositioningComponent.self] != nil)
        """)

        // Reset state tracking first
        isRootSetupComplete = false
        isEnvironmentSetupComplete = false
        isHeadTrackingRootReady = false
        isPositioningComplete = false
        isPositioningInProgress = false  // Reset positioning progress state
        
        Logger.info("🔄 Starting new intro session: tracking states reset")
        Logger.info("📱 IntroViewModel: Setting up root")
        
        let root = Entity()
        root.name = "IntroRoot"
        root.position = AppModel.PositioningDefaults.intro.position
        
        root.components.set(PositioningComponent(
            offsetX: 0,
            offsetY: -1.5,  // Maintain intro's specific offset
            offsetZ: -1.0,
            needsPositioning: false,
            shouldAnimate: false,
            animationDuration: 0.0
        ))
        
        Logger.info("""
        
        ✅ Root Setup Complete
        ├─ Root Entity: \(root.name)
        ├─ Position: \(root.position(relativeTo: nil))
        └─ Positioning: Ready for explicit updates
        """)
        
        introRootEntity = root
        isRootSetupComplete = true
        isHeadTrackingRootReady = true
        return root
    }
    
    // MARK: - Setup Environment
    func setupEnvironment(in root: Entity) async {
        Logger.debug("📱 IntroViewModel: Starting environment setup")
        
        // Load intro environment using on-demand API through appModel.assetLoadingManager
        Logger.debug("📱 IntroViewModel: Attempting to load intro environment")
        var environment: Entity
        do {
            environment = try await appModel.assetLoadingManager.instantiateAsset(withName: "intro_environment", category: AssetCategory.introEnvironment)
            Logger.debug("✅ IntroViewModel: Successfully loaded intro environment")
            // Store but don't add to root yet
            introEnvironment = environment
            
            isEnvironmentSetupComplete = true
            Logger.debug("✅ Environment setup complete")
        } catch {
            Logger.debug("❌ IntroViewModel: Error loading intro environment: \(error)")
            return
        }
        
        // Find and setup entities
        Logger.debug("📱 IntroViewModel: Setting up individual entities")
        setupSkyDome(in: environment)
        await setupPortal(in: root)
        
        Logger.debug("✅ IntroViewModel: Environment setup complete")
    }
    
    func setupAttachments(in environment: Entity, for portal: Entity, titleEntity: Entity? = nil, labViewerEntity: Entity? = nil) {
        // Separate logo setup
        if let l = environment.findEntity(named: "logo") {
            Logger.debug("🔍 Found logo: \(l.name)")
            logo = l
            l.scale = SIMD3<Float>(0.5, 0.5, 0.5)
            l.opacity = 0
            Logger.debug("✅ Set logo scale to 0.5 and opacity to 0")
        } else {
            Logger.error("❌ Logo entity not found during setup")
        }
        
        // Separate title setup
        if let title = environment.findEntity(named: "outdoCancer") {
            Logger.debug("Found title: \(title.name)")
            titleRoot = title
            title.opacity = 0
            Logger.debug("Set title opacity to 0")
        } else {
            Logger.error("❌ Title entity not found during setup")
        }
    }
    
    // MARK: - Private Setup Methods
    private func setupSkyDome(in environment: Entity) {
        if let sky = environment.findEntity(named: "SkySphere") {
            Logger.debug("🔍 Found skyDome: \(sky.name)")
            skyDome = sky
            sky.opacity = 0
            Logger.debug("✅ Set skyDome opacity to 0")
        } else {
            Logger.debug("❌ Could not find SkySphere in environment")
        }
    }
    
    private func setupPortal(in root: Entity) async {
        Logger.debug("📱 IntroViewModel: Starting portal setup")
        do {
            // Load assembled lab using loadAssembledLab
            let labEnvironment = try await appModel.assetLoadingManager.loadAssembledLab()
            Logger.debug("✅ IntroViewModel: Successfully loaded assembled laboratory environment")
            
            assembledLab = labEnvironment
            assembledLab?.name = "assembled_lab"
            
            // Create portal with loaded environment
            let p = await PortalManager.createPortal(
                appModel: appModel,
                environment: labEnvironment,
                portalPlaneName: "Plane_001"
            )
            Logger.debug("✅ IntroViewModel: Created portal")
            
            // Store and configure portal
            portal = p
            p.opacity = 0.0
            p.position = [0, -0.25, 0]
            root.addChild(p)
            
            Logger.debug("Attempting to setup interactive ADC for user")
            await appModel.labState.setupADCPlacer(in: root)
            await appModel.labState.setupExtraADCs(in: root)
            
            Logger.debug("✅ IntroViewModel: Portal setup complete")
            
        } catch {
            Logger.debug("❌ IntroViewModel: Failed to load laboratory environment: \(error)")
            // Handle specific error cases
            if let assetError = error as? AssetError {
                switch assetError {
                case .resourceNotFound:
                    Logger.debug("❌ IntroViewModel: Lab environment resource not found")
                case .protobufError(let name):
                    Logger.debug("❌ IntroViewModel: Protobuf error loading lab environment: \(name)")
                default:
                    Logger.debug("❌ IntroViewModel: Asset error loading lab environment: \(assetError)")
                }
            }
        }
    }
    
    
    // MARK: - Animation Methods
    func runAnimationSequence() async {
        // // Request head position update before starting animation sequence
        // shouldUpdateHeadPosition = true
        
        // Cancel any existing animation task
        animationTask?.cancel()
        
        // Create new animation task
        animationTask = Task { @MainActor in
            let start = Date()
            Logger.debug("🎬 Animation Sequence: Starting at \(start)")
            Logger.debug("🔍 Entity Check - skyDome: \(skyDome != nil), logo: \(logo != nil), portal: \(portal != nil)")
            
            // Example helper guard to ensure an entity is still in the scene (if needed)
            @MainActor
            func ensureValidEntity(_ entity: Entity?, with name: String) -> Bool {
                if let e = entity, e.parent != nil {
                    return true
                } else {
                    Logger.debug("⚠️ Entity \(name) is no longer valid or not attached.")
                    return false
                }
            }
            
            // Check for cancellation before each animation step
            guard !Task.isCancelled else {
                Logger.debug("🛑 Animation sequence cancelled before sky fade")
                return
            }
            
            // Sky fade animation
            if shouldUseSky {
                Logger.debug("🌌 Sky: Starting at +\(Date().timeIntervalSince(start))s")
                if let s = skyDome {
                    Logger.debug("🔍 Sky initial opacity: \(s.opacity)")
                    await s.fadeOpacity(to: skyDarkness, duration: 10.0)
                    Logger.debug("🌌 Sky: Completed fade animation")
                } else {
                    Logger.debug("❌ Sky: skyDome not found")
                }
            }
            
            // Portal warp fade (24s)
            Logger.debug("⏰ Sleeping for 29s before portal warp")
            try? await Task.sleep(for: .seconds(29)) // changed from 19 to 29 since removed portalWarp
            
            guard !Task.isCancelled else {
                Logger.debug("🛑 Animation sequence cancelled before logo")
                return
            }
            
            // Logo and title sequence
            Logger.debug("⏰ Sleeping for 75s before logo")
            try? await Task.sleep(for: .seconds(75))
            
            // Verify both entities before starting animation sequence
            guard ensureValidEntity(logo, with: "logo") else {
                Logger.error("❌ Logo entity not valid or missing before animation")
                return
            }
            guard ensureValidEntity(titleRoot, with: "title") else {
                Logger.error("❌ Title entity not valid or missing before animation")
                return
            }
            
            Logger.debug("🎯 Logo and Title Sequence: Starting at +\(Date().timeIntervalSince(start))s")
            
            if let l = logo, let t = titleRoot {
                // Start logo animation
                Logger.debug("🔍 Logo initial state - opacity: \(l.opacity), scale: \(l.scale)")
                let logoAnimation = Task {
                    await l.fadeOpacity(to: 1.0, duration: 5.0)
                    Logger.debug("✨ Logo fade completed - final opacity: \(l.opacity)")
                }
                
                // Wait for logo animation and delay
                await logoAnimation.value
                Logger.debug("⏰ Waiting 5s before title animation")
                try? await Task.sleep(for: .seconds(5))
                
                // Start title animation
                Logger.debug("🔍 Title initial state - opacity: \(t.opacity)")
                let titleAnimation = Task {
                    await t.fadeOpacity(to: 1.0, duration: 5.0)
                    Logger.debug("✨ Title fade completed - final opacity: \(t.opacity)")
                }
                
                // Wait for title animation to complete
                await titleAnimation.value
                Logger.debug("✅ Logo and Title sequence complete")
                
            } else {
                Logger.error("❌ Logo or Title entity became invalid during animation sequence")
            }
            
            guard !Task.isCancelled else {
                Logger.debug("🛑 Animation sequence cancelled before portal")
                return
            }
            
            // Portal sequence
            Logger.debug("🌐 Portal: Starting at +\(Date().timeIntervalSince(start))s")
            guard ensureValidEntity(portal, with: "portal") else { return }
            Logger.debug("🔍 Portal reference check: \(portal != nil)")
            if let p = portal {
                Logger.debug("🔍 Portal initial opacity: \(p.opacity)")
                await p.fadeOpacity(to: 1.0, duration: 5.0)
                Logger.debug("🌐 Portal: Completed fade animation")
                Logger.debug("🔍 Portal final opacity: \(p.opacity)")
                try? await Task.sleep(for: .seconds(5.0))
                
                // Perform the original portalPlane X-scale animation
                if let portalPlane = p.findEntity(named: "portalPlane") {
                    Logger.debug("🌐 Portal plane: Starting X scale animation at +\(Date().timeIntervalSince(start))s")
                    await portalPlane.animateXScale(from: 0, to: 1.0, duration: 1.0)
                    Logger.debug("🌐 Portal plane: Completed X scale animation")
                } else {
                    Logger.debug("❌ Portal plane: portalPlane not found")
                }

                // Wait 2 seconds after portalPlane animation finishes
                try? await Task.sleep(for: .seconds(2.0))

                // Concurrent animations – first verify that all required entities are still valid.
                guard let portalRoot = p.findEntity(named: "portalRoot"),
                      let portalWorld = p.findEntity(named: "world"),
                      let portalPlane2 = p.findEntity(named: "portalPlane"),
                      ensureValidEntity(introEnvironment, with: "introEnvironment"),
                      ensureValidEntity(introRootEntity, with: "introRootEntity"),
                      let _ = introRootEntity?.findEntity(named: "ExtraItems"),
                      ensureValidEntity(logo, with: "logo"),
                      ensureValidEntity(titleRoot, with: "titleRoot"),
                      ensureValidEntity(skyDome, with: "skyDome")
                else {
                    Logger.debug("❌ One or more entities for concurrent animations not found.")
                    if p.findEntity(named: "portalRoot") == nil {
                        Logger.debug("❌ PortalRoot not found")
                    }
                    if p.findEntity(named: "world") == nil {
                        Logger.debug("❌ World not found")
                    }
                    if p.findEntity(named: "portalPlane") == nil {
                        Logger.debug("❌ PortalPlane not found")
                    }
                    return
                }

                Logger.debug("🌐 Starting concurrent animations for PortalRoot, World, and PortalPlane scale")
                let moveDuration = 20.0
                
                async let _: () = skyDome!.fadeOpacity(to: 0.0, duration: 10.0)
                async let _: () = logo!.fadeOpacity(to: 0.0, duration: 3.0)
                async let _: () = titleRoot!.fadeOpacity(to: 0.0, duration: 3.0)
                async let animatePortalRoot: () = portalRoot.animateAbsolutePositionAndScale(
                    to: SIMD3<Float>(0, 0, 0),
                    scale: SIMD3<Float>(1, 1, 1),
                    duration: moveDuration,
                    timing: .easeInOut,
                    waitForCompletion: true
                )

                async let animateWorld: () = portalWorld.animateAbsolutePositionAndScale(
                    to: SIMD3<Float>(0, 0.25, 1),
                    scale: SIMD3<Float>(1, 1, 1),
                    duration: moveDuration,
                    timing: .easeInOut,
                    waitForCompletion: true
                )

                async let animatePortalPlaneScale: () = portalPlane2.animateScale(
                    to: 20.0,
                    duration: moveDuration,
                    timing: .easeInOut,
                    waitForCompletion: true
                )
                

                _ = await (animatePortalRoot, animateWorld, animatePortalPlaneScale)
                
                Logger.debug("🌐 Completed concurrent animations for PortalRoot, World, and PortalPlane scale")
                

                // Wait for 5 seconds
                try? await Task.sleep(for: .seconds(5))
                
                // Unparent the portalWorld from the portal and reparent it to the root while preserving its transform
                if let lab = assembledLab {
                    // Capture the current transform of the lab in world space
                    let worldTransform = lab.transformMatrix(relativeTo: nil)
                    
                    // Remove the lab from its current parent
                    lab.removeFromParent()
                    
                    // Reparent the lab to the intro root entity
                    introRootEntity!.addChild(lab)
                    Logger.debug("🛑 assembledLab position in world space PRE-TRANSFORM FIX is \(lab.position(relativeTo: nil))")
                    
                    // Restore the lab's transform
                    lab.setTransformMatrix(worldTransform, relativeTo: nil)
                    Logger.debug("✅ assembledLab position in world space is \(lab.position(relativeTo: nil))")
                }

                // Change the portal component to spill out into the world
                if var portalComponent = portalPlane2.components[PortalComponent.self] {
                    portalComponent.crossingMode = .plane(.positiveZ)
                    portalPlane2.components.set(portalComponent)
                } else {
                    Logger.debug("❌ PortalComponent not found on portalPlane2.")
                }
                
                if let portalEnv = self.portal {
                    Logger.debug("\n 🔍 Inspecting portal hierarchy \n")
                    self.appModel.assetLoadingManager.inspectEntityHierarchy(portalEnv)
                    portalEnv.removeFromParent()
                    self.portal = nil
                    Logger.debug("Removed portal completely from the scene as we transition to lab.")
                }

                if let introEnv = introEnvironment {
                    introEnv.removeFromParent()
                    introEnvironment = nil
                    Logger.debug("Removed introEnvironment completely from the scene as we transition to lab.")
                }
                
                // Enable large room reverb and inspect hierarchy
                introRootEntity!.enableLargeRoomReverb()
                // appModel.assetLoadingManager.inspectEntityHierarchy(introRootEntity!)

                appModel.readyToStartLab = true
                Logger.debug("readyToStartLab set to \(appModel.readyToStartLab)")
                
            } else {
                Logger.debug("❌ Portal: portal not found")
            }
            
            Logger.debug("🎬 Animation Sequence: Completed at +\(Date().timeIntervalSince(start))s")
        }
    }
    
    // MARK: - Entity Access Methods
    func getPortal() -> Entity? {
        return portal
    }
    
    // MARK: - Cleanup
    func cleanup() {
        Logger.info("""
        
        🔄 === INTRO VIEW CLEANUP STATE ===
        ├─ Root Setup: \(isRootSetupComplete)
        ├─ Environment Setup: \(isEnvironmentSetupComplete)
        ├─ Head Tracking Ready: \(isHeadTrackingRootReady)
        ├─ Should Update Position: \(shouldUpdateHeadPosition)
        ├─ Positioning Complete: \(isPositioningComplete)
        ├─ Positioning In Progress: \(isPositioningInProgress)
        ├─ Has Root Entity: \(introRootEntity != nil)
        └─ Has Positioning Component: \(introRootEntity?.components[PositioningComponent.self] != nil)
        """)

        // defer will run this logging after all cleanup is complete
        defer {
            Logger.info("""
            
            🔄 === INTRO VIEW FINAL STATE ===
            ├─ Root Setup: \(isRootSetupComplete)
            ├─ Environment Setup: \(isEnvironmentSetupComplete)
            ├─ Head Tracking Ready: \(isHeadTrackingRootReady)
            ├─ Should Update Position: \(shouldUpdateHeadPosition)
            ├─ Positioning Complete: \(isPositioningComplete)
            ├─ Positioning In Progress: \(isPositioningInProgress)
            ├─ Has Root Entity: \(introRootEntity != nil)
            └─ Has Positioning Component: \(introRootEntity?.components[PositioningComponent.self] != nil)
            """)
        }

        Logger.debug("\n=== Starting IntroViewModel Cleanup ===")
        
        // First, cancel any running animation task
        Logger.debug("🛑 Cancelling animation sequence")
        animationTask?.cancel()
        animationTask = nil
        
        // Clear root entity and scene
        if let root = introRootEntity {
            Logger.debug("🗑️ Removing intro root entity")
            // Reset positioning component before removal
            if var positioningComponent = root.components[PositioningComponent.self] {
                Logger.debug("🎯 Resetting positioning component")
                positioningComponent.needsPositioning = true
                root.components[PositioningComponent.self] = positioningComponent
            }
            root.removeFromParent()
        }

        introRootEntity = nil
        scene = nil
        
        // Animation control flags
        shouldUseSky = true  // New flag to control sky animation
        skyDarkness = 0.98

        // Entity references
        portal = nil
        skyDome = nil
        logo = nil
        titleRoot = nil
        material = nil
        introEnvironment = nil
        
        // Attachment entities
        titleEntity = nil
        navToggleEntity = nil
        
        // Animation States
        showTitleText = false
        shouldDimSurroundings = false
        isSetupComplete = false
        
        // New flag to prevent duplicate environment loading
        environmentLoaded = false

        
        // Root setup flags
        isRootSetupComplete = false
        isEnvironmentSetupComplete = false
        isHeadTrackingRootReady = false
        shouldUpdateHeadPosition = false
        isPositioningComplete = false
        isPositioningInProgress = false  // Add positioning progress flag
        
        appModel.readyToStartLab = false
        
        Logger.debug("✅ Completed IntroViewModel cleanup\n")
    }
    
    private func applyMeshSorting(from parent: Entity, to child: Entity) {
        // Old helper remains in case it's needed elsewhere
        if let sortingComponent = parent.components[ModelSortGroupComponent.self] {
            child.components.set(sortingComponent)
            Logger.debug("✅ Applied ModelSortGroupComponent from \(parent.name) to \(child.name)")
        } else {
            Logger.debug("❌ No ModelSortGroupComponent found on \(parent.name) to apply to \(child.name)")
        }
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+UI.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

@Observable
@MainActor
class AttackCancerUIViewModel {
    var hitCounts: [Int] = []
    var requiredHits: [Int] = []
    var destroyedStates: [Bool] = []
    
    func setupUISync(for cell: Entity, index: Int) {
        cell.components.set(
            ClosureComponent { _ in
                guard let hitComponent = cell.components[HitCountComponent.self] else { return }
                
                // Ensure arrays are sized
                while self.hitCounts.count <= index {
                    self.hitCounts.append(0)
                    self.requiredHits.append(0)
                    self.destroyedStates.append(false)
                }
                
                // Update state
                self.hitCounts[index] = hitComponent.hitCount
                self.requiredHits[index] = hitComponent.requiredHits
                self.destroyedStates[index] = hitComponent.isDestroyed
            }
        )
    }

    func setupUIAttachments(in root: Entity, attachments: RealityViewAttachments, count: Int) {
        print("\n=== Setting up UI Attachments ===")
        print("Total attachments to create: \(count)")
        
        for i in 0..<count {
            print("Setting up attachment \(i)")
            if let meter = attachments.entity(for: "\(i)") {
                print("✅ Found meter entity for \(i)")
                if root.findEntity(named: "cancer_cell_\(i)") != nil {
                    print("✅ Found cancer cell \(i)")
                    root.addChild(meter)
                    meter.components[UIAttachmentComponent.self] = UIAttachmentComponent(attachmentID: i)
                    meter.components.set(BillboardComponent())
                    
                    print("✅ Added meter to cancer_cell_\(i) with components")
                } else {
                    print("❌ Could not find cancer cell \(i)")
                }
            } else {
                print("❌ Could not create meter entity for \(i)")
            }
        }
    }
} 

```

File: ViewModels/OutroViewModel/OutroViewModel.swift
```swift
//
//  OutroViewModel.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 2/2/25.
//

import Foundation
import RealityKit
import RealityKitContent
import SwiftUI

@Observable
@MainActor
final class OutroViewModel {
    // MARK: - Properties
    var outroRootEntity: Entity?
    var scene: RealityKit.Scene?
    
    // Entity references
    private var outroEnvironmentEntity: Entity?
    
    // State
    var isSetupComplete = false
    
    // Dependencies
    var appModel: AppModel!
    
    // Animation control flags (from intro)
    var shouldUseSky = true
    var skyDarkness: Float = 0.98  // Same value as intro
    
    // Entity references (from intro)
    private var skyDome: Entity?
    
    // MARK: - Setup Methods
    func setupOutroRoot() -> Entity {
        print("📱 OutroViewModel: Setting up root entity")
        let root = Entity()
        root.name = "OutroRoot"
        root.components.set(PositioningComponent(
            offsetX: 0,
            offsetY: -1.5,
            offsetZ: -1.0
        ))
        outroRootEntity = root
        print("✅ OutroViewModel: Root entity configured")
        return root
    }
    
    func setupEnvironment(in root: Entity) async {
        print("📱 OutroViewModel: Starting environment setup")
        
        // Load environment
        do {
            print("📱 OutroViewModel: Loading environment")
            let environment = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "outro_environment",
                category: .outroEnvironment
            )
            print("✅ OutroViewModel: Successfully loaded outro environment")
            
            root.addChild(environment)
            outroEnvironmentEntity = environment
            print("✅ OutroViewModel: Added environment to root")
            
            // Setup sky dome
            setupSkyDome(in: environment)
            
            // IBL
            do {
                print("📱 OutroViewModel: Setting up IBL lighting")
                try await IBLUtility.addImageBasedLighting(to: root, imageName: "metro_noord_2k")
                print("✅ OutroViewModel: Added IBL lighting")
            } catch {
                print("❌ OutroViewModel: Failed to setup IBL: \(error)")
            }
            
            isSetupComplete = true
            
            // Start sky animation once environment is ready
            await startSkyAnimation()
            
        } catch {
            print("❌ OutroViewModel: Failed to load outro environment: \(error)")
        }
    }
    
    private func setupSkyDome(in environment: Entity) {
        if let sky = environment.findEntity(named: "SkySphere") {
            print("🔍 Found skyDome: \(sky.name)")
            skyDome = sky
            sky.opacity = 0
            print("✅ Set skyDome opacity to 0")
        } else {
            print("❌ Could not find SkySphere in environment")
        }
    }
    
    // MARK: - Animation Methods
    func startSkyAnimation() async {
        print("🌌 Sky: Starting animation")
        if shouldUseSky {
            if let s = skyDome {
                print("🔍 Sky initial opacity: \(s.opacity)")
                await s.fadeOpacity(to: skyDarkness, duration: 10.0)
                print("🌌 Sky: Completed fade animation")
                print("🔍 Sky final opacity: \(s.opacity)")
            } else {
                print("❌ Sky: skyDome not found")
            }
        }
    }
    
    // MARK: - Cleanup
    func cleanup() {
        print("\n=== Starting OutroViewModel Cleanup ===")
        
        // Clear root entity and scene
        if let root = outroRootEntity {
            print("🗑️ Removing outro root entity")
            // Reset positioning component before removal
            if var positioningComponent = root.components[PositioningComponent.self] {
                print("🎯 Resetting positioning component")
                positioningComponent.needsPositioning = true
                root.components[PositioningComponent.self] = positioningComponent
            }
            root.removeFromParent()
        }
        outroRootEntity = nil
        scene = nil
        
        // Clear environment entity
        if let environment = outroEnvironmentEntity {
            print("🌍 Removing environment entity")
            environment.removeFromParent()
        }
        outroEnvironmentEntity = nil
        
        // Reset state
        isSetupComplete = false
        
        print("✅ Completed OutroViewModel cleanup\n")
    }
} 

```

File: Views/Effects/ButtonHoverEffects.swift
```swift
import SwiftUI

// Custom hover effects will be implemented following Apple's patterns 

/// Expands and scales content on hover.
//struct ExpandEffect: CustomHoverEffect {
//    func body(content: Content) -> some CustomHoverEffect {
//        content.hoverEffect { effect, isActive, proxy in
//            effect.animation(.linear.delay(isActive ? 0.8 : 0.2)) {
//                $0.clipShape(
//                    .capsule.size(
//                        width: isActive ? proxy.size.width : proxy.size.height,
//                        height: proxy.size.height,
//                        anchor: .leading
//                    )
//                )
//                .scaleEffect(
//                    isActive ? 1.05 : 1.0,
//                    anchor: UnitPoint(x: (proxy.size.height / 2) / proxy.size.width, y: 0.5)
//                )
//            }
//        }
//    }
//}

/// Fades content between the `from` and `to` properties on hover.
struct FadeEffect: CustomHoverEffect {
    var opacityFrom: Double = 0
    var opacityTo: Double = 1

    func body(content: Content) -> some CustomHoverEffect {
        content.hoverEffect { effect, isActive, _ in
            effect.animation(.linear.delay(isActive ? 0.8 : 0.2)) {
                $0.opacity(isActive ? opacityTo : opacityFrom)
            }
        }
    }
}

/// Creates a glowing outline effect that animates on hover
struct GlowingOutlineEffect: CustomHoverEffect {
    func body(content: Content) -> some CustomHoverEffect {
        content.hoverEffect { effect, isActive, proxy in
            effect.animation(.default.delay(isActive ? 0.2 : 0.2)) {
                $0.clipShape(
                    .capsule.size(
                        width: proxy.size.width,
                        height: proxy.size.height,
                        anchor: .leading
                    )
                )
            }
            .animation(.easeInOut(duration: 0.2)) {
                $0.scaleEffect(isActive ? AppModel.UIConstants.buttonExpandScale : 1.0)
            }
        }
    }
}

/// Creates a rainbow gradient border that animates on hover
struct GradientBorderEffect: CustomHoverEffect {
    func body(content: Content) -> some CustomHoverEffect {
        content.hoverEffect { effect, isActive, _ in
            effect.animation(.default.delay(isActive ? 0.2 : 0.2)) {
                $0.opacity(isActive ? 1.0 : 0.3)
            }
        }
    }
}

```

File: ViewModels/LabViewModel/LabViewModel.swift
```swift
//
//  LabViewModel.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/23/25.
//

import Foundation
import RealityKit
import RealityKitContent
import SwiftUI

@Observable
@MainActor
final class LabViewModel {
    // MARK: - Properties
    var mainEntity: Entity?
    var scene: RealityKit.Scene?
    
    // Entity references
    private var labAudioEntity: Entity?
    
    // Attachment entities
    var adcBuilderViewerButtonEntity: Entity?
    var attackCancerViewerButtonEntity: Entity?
    
    // ADC template reference
    var adcTemplate: Entity?
    
    // State
    var isSetupComplete = false
    var isLibraryOpen = false
    var shouldShowADCButton = false
    
    // Dependencies
    var appModel: AppModel!
    
    // MARK: - Setup Methods
    func setupRoot() -> Entity {
        print("📱 LabViewModel: Setting up root entity")
        let root = Entity()
        root.name = "MainEntity"
        root.components.set(PositioningComponent(
            offsetX: 0,
            offsetY: -1.425,
            offsetZ: -0.25
        ))
        mainEntity = root
        print("✅ LabViewModel: Root entity configured")
        return root
    }
    
    // MARK: extra ADCs
    func setupExtraADCs(in root: Entity) async {
        // Ensure ADC template exists
        guard let template = appModel.gameState.adcTemplate else {
            Logger.info("❌ ADC Template not found, skipping extra ADC placements")
            return
        }
        
        // Recursive function to find all entities with names containing "ADC_xform"
        func findADCTransforms(in entity: Entity) -> [Entity] {
            var results: [Entity] = []
            if entity.name.contains("ADC_xform") {
                results.append(entity)
            }
            for child in entity.children {
                results.append(contentsOf: findADCTransforms(in: child))
            }
            return results
        }
        
        let adcTransforms = findADCTransforms(in: root)
        var placedCount = 0
        
        for transform in adcTransforms {
            // Clone the ADC template
            let adcClone = template.clone(recursive: true)
            
            // Generate a random rotation speed between 0.5 and 2.0
            let randomSpeed = Float.random(in: 0.5...2.0)
            
            // Create and configure a RotationComponent with the random speed
            var rotation = RotationComponent()  // assuming RotationComponent has a mutable property 'rotationSpeed'
            rotation.speed = randomSpeed
            adcClone.components.set(rotation)
            
            // Add the cloned ADC as a child of the transform entity
            transform.addChild(adcClone)
            placedCount += 1
        }
        
        Logger.info("✅ setupExtraADCs: Placed \(placedCount) ADC clones")
    }

    // MARK: Interactive ADC
    func setupADCPlacer(in root: Entity) async {
        Logger.info("""
        
        🎯 Setting up ADC Placer
        ├─ hasBuiltADC: \(appModel.hasBuiltADC)
        └─ Root Entity: \(root.name)
        """)
        
        // Only proceed if we have a built ADC
        let shouldProceed = true // appModel.hasBuiltADC
        
        guard shouldProceed,
              let placerEntity = root.findEntity(named: "ADC_placer"),
              let template = appModel.gameState.adcTemplate else {
            Logger.info("""
            
            ❌ ADC Placer Setup Failed
            ├─ shouldProceed: \(shouldProceed)
            ├─ Found Placer: \(root.findEntity(named: "ADC_placer") != nil)
            └─ Has Template: \(appModel.gameState.adcTemplate != nil)
            """)
            return
        }
        
        Logger.info("""
        
        ✅ ADC Placer Requirements Met
        ├─ Found Placer Entity: \(placerEntity.name)
        ├─ Placer Position: \(placerEntity.position)
        └─ Has Template: true
        """)
        
        // Clone and place template
        let adc = template.clone(recursive: true)
        
        // Add input target and gesture components
        adc.components.set(InputTargetComponent())
        adc.components.set(RotationComponent())
        adc.components.set(ADCGestureComponent(
            canDrag: true,
            pivotOnDrag: false,
            canScale: true,
            canRotate: true
        ))

        // setup collision
        let shape = ShapeResource.generateSphere(radius: 0.069)
        let collision = CollisionComponent(shapes: [shape])
        adc.components.set(collision)
        
        // Add to scene at placer location
        placerEntity.addChild(adc)
        adc.opacity = 0
        await adc.fadeOpacity(to: 1.0, duration: 1.0)
        
        Logger.info("""
        
        ✨ ADC Placer Setup Complete
        ├─ ADC Entity Added
        ├─ Position: \(adc.position)
        ├─ Has InputTarget: \(adc.components[InputTargetComponent.self] != nil)
        ├─ Has Rotation: \(adc.components[RotationComponent.self] != nil)
        └─ Has Gesture: \(adc.components[ADCGestureComponent.self] != nil)
        """)
    }
    
    func setupInitialLabEnvironment(in root: Entity, isIntro: Bool? = nil) async throws {
        print("📱 LabViewModel: Setting up initial environment")
        
        if isIntro != nil {
            // Intro mode - find existing lab and configure devices
            let labEnvironment = root.findEntity(named: "assembled_lab")!
            configureInteractiveDevices(in: labEnvironment)

            // Logger.debug("Attempting to setup interactive ADC for user")
            // await setupADCPlacer(in: root)
            // await setupExtraADCs(in: root)


            Logger.debug("calling setupLabEnvironment")
            try await setupLabEnvironment(in: root, isIntro: isIntro)
        } else {
            // Lab mode - load and set up the complete lab
//            guard let root = mainEntity else {
//                print("❌ LabViewModel: No root entity for initial environment")
//                return
//            }
//            
//            // Load the complete assembled lab
//            print("📱 Loading assembled lab environment")
//            let labEnvironment = try await appModel.assetLoadingManager.loadAssembledLab()
//            root.addChild(labEnvironment)
//            print("🏢 Assembled Lab Environment added to MainEntity")
//            print("📍 Lab Environment position: \(labEnvironment.position)")
//            
//            // Configure the interactive devices
//            configureInteractiveDevices(in: labEnvironment)
//
//            Logger.debug("Attempting to setup interactive ADC for user")
//            setupADCPlacer(in: root)
//
//            Logger.debug("calling setupLabEnvironment")
//            try await setupLabEnvironment(in: root, isIntro: isIntro)
        }
    }
    
    // MARK: - Environment Setup
    func setupLabEnvironment(in root: Entity, isIntro: Bool? = nil) async throws {
        Logger.info("\n=== Lab Environment Setup ===")
        Logger.info("📱 LabViewModel: Starting environment setup")
        Logger.info("🔍 isIntro parameter: \(String(describing: isIntro))")
        

        let showADC = appModel.hasBuiltADC // set to true to debug 
        
        if isIntro == nil {
            // Lab mode - check for main entity
            guard mainEntity != nil else {
                Logger.error("❌ LabViewModel: No root entity for environment setup")
                throw AssetError.resourceNotFound
            }
        }
        
        Logger.info("""
        
        🔍 ADC Button State Check
        ├─ hasBuiltADC: \(appModel.hasBuiltADC)
        ├─ Current shouldShowADCButton: \(shouldShowADCButton)
        └─ isIntro Mode: \(String(describing: isIntro))
        """)
        
        // Set ADC button visibility based on previous build
        shouldShowADCButton = showADC // appModel.hasBuiltADC
        Logger.info("🎯 ADC Button visibility set to: \(shouldShowADCButton)")
        
        // Only start the timer for ADC button if it's not already visible
        if !shouldShowADCButton {
            Logger.info("""
            
            ⏲️ Starting 30-second timer for ADC button visibility
            ├─ Current shouldShowADCButton: \(shouldShowADCButton)
            └─ hasBuiltADC: \(appModel.hasBuiltADC)
            """)
            Task {
                try? await Task.sleep(for: .seconds(38))
                Logger.info("⏲️ Timer complete - showing ADC button")
                withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {
                    shouldShowADCButton = true
                }
            }
        } else {
            Logger.info("""
            
            🎯 Skipping ADC button timer
            ├─ Current shouldShowADCButton: \(shouldShowADCButton)
            └─ hasBuiltADC: \(appModel.hasBuiltADC)
            """)
        }
        
        // Load and add lab VO (timeline will play automatically)
        Logger.info("\n🎙️ Attempting to load lab VO...")
        do {
            let labVO = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "lab_vo",
                category: .labEnvironment
            )
            Logger.info("✅ Lab VO asset loaded successfully")
            root.addChild(labVO)
            Logger.info("✅ Lab VO added to root entity")
        } catch {
            Logger.error("❌ Failed to load lab VO: \(error)")
        }

        Logger.info("\n🔊 Loading lab audio Spatial Ambience...")
        do {
            let labAudio = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "lab_audio",
                category: .labEnvironment
            )
            root.addChild(labAudio)
            labAudioEntity = labAudio
            Logger.info("✅ Lab Audio added to MainEntity")
        } catch {
            Logger.error("❌ Failed to load lab audio: \(error)")
        }
        
        isSetupComplete = true
        Logger.info("""
        
        ✅ Lab Environment Setup Complete
        ├─ isSetupComplete: \(isSetupComplete)
        ├─ shouldShowADCButton: \(shouldShowADCButton)
        └─ hasBuiltADC: \(appModel.hasBuiltADC)
        """)
    }
    
    // MARK: - Attachment Setup
    func setupAttachments(attachments: RealityViewAttachments) {
        // Setup ADC Builder Button
        if let adbBuilderView = attachments.entity(for: "ADCBuilderViewerButton") {
            print("🔧 ADCBuilderViewerButton attachment created")
            if let builderTarget = mainEntity?.findEntity(named: "ADCBuilderAttachment") {
                print("🔧 Found ADCBuilderAttachment entity at position: \(builderTarget.position)")
                builderTarget.addChild(adbBuilderView)
                adbBuilderView.components.set(BillboardComponent())
                adcBuilderViewerButtonEntity = adbBuilderView
            } else {
                print("❌ ADCBuilderAttachment entity not found in scene")
            }
        }
        
        // Setup Attack Cancer Button
        if let attackCancerView = attachments.entity(for: "AttackCancerViewerButton") {
            print("🎯 AttackCancerViewerButton attachment created")
            if let attackTarget = mainEntity?.findEntity(named: "AttackCancerAttachment") {
                print("🎯 Found AttackCancerAttachment entity at position: \(attackTarget.position)")
                attackTarget.addChild(attackCancerView)
                attackCancerView.components.set(BillboardComponent())
                attackCancerViewerButtonEntity = attackCancerView
            }
        }
    }
    
    // MARK: - Interactive Devices
    private func findInteractiveDevices(in root: Entity) -> [(entity: Entity, meshEntity: Entity)] {
        var results: [(Entity, Entity)] = []
        
        // Check if this is a mesh entity with M_screen material
        if root.name.hasSuffix("_mesh") {
            if let modelComponent = root.components[ModelComponent.self],
               modelComponent.materials.contains(where: { $0.name == "M_screen" }) {
                // Find parent that contains "laptop" or "pcmonitor"
                var current = root.parent
                while let parent = current {
                    if parent.name.lowercased().contains("laptop") || 
                       parent.name.lowercased().contains("pcmonitor") {
                        results.append((parent, root))
                        break
                    }
                    current = parent.parent
                }
            }
        }
        
        // Search children
        for child in root.children {
            results.append(contentsOf: findInteractiveDevices(in: child))
        }
        
        return results
    }

    private func configureInteractiveDevices(in entity: Entity) {
        // Find and configure all interactive devices
        let devices = findInteractiveDevices(in: entity)
        print("\n=== Configuring Interactive Devices ===")
        print("🔍 Found \(devices.count) potential interactive devices")
        
        for (device, meshEntity) in devices {
            print("⚙️ Adding hover effect to: \(device.name) with mesh: \(meshEntity.name)")
            
            // Find M_screen material in the mesh entity
            if let modelComponent = meshEntity.components[ModelComponent.self],
               modelComponent.materials.contains(where: { $0.name == "M_screen" }) {
                
                // Add hover effect with shader inputs
                let hoverEffect = HoverEffectComponent(.shader(
                    HoverEffectComponent.ShaderHoverEffectInputs(
                        fadeInDuration: 0.3,
                        fadeOutDuration: 0.2
                    )
                ))
                device.components.set(hoverEffect)
            }
        }
    }
    
    // MARK: - Interactive Device Handling
    func handleTap(on entity: Entity) {
        print("🎯 Tap detected on entity: \(entity.name)")
        
        if entity.components[InteractiveDeviceComponent.self] != nil {
            print("📱 Found InteractiveDeviceComponent, toggling library...")
            isLibraryOpen.toggle()
        }
    }
    
    // MARK: - Cleanup
    func cleanup() {
        print("\n=== Starting LabViewModel Cleanup ===")
        
        // Clear main entity and scene
        if let root = mainEntity {
            print("🗑️ Removing main entity")
            // Reset positioning component before removal
            if var positioningComponent = root.components[PositioningComponent.self] {
                print("🎯 Resetting positioning component")
                positioningComponent.needsPositioning = true
                root.components[PositioningComponent.self] = positioningComponent
            }
            
            root.removeFromParent()
        }
        mainEntity = nil
        scene = nil
        
        // Clear audio entity
        if let audio = labAudioEntity {
            print("🔊 Removing lab audio entity")
            audio.removeFromParent()
        }
        labAudioEntity = nil
        
        // Clear attachment entities
        if let builder = adcBuilderViewerButtonEntity {
            print("🔧 Removing ADC builder button")
            builder.removeFromParent()
        }
        adcBuilderViewerButtonEntity = nil
        
        if let attack = attackCancerViewerButtonEntity {
            print("🎯 Removing Attack Cancer button")
            attack.removeFromParent()
        }
        attackCancerViewerButtonEntity = nil
        
        // Reset state, but preserve ADC button state if ADC has been built
        isSetupComplete = false
        isLibraryOpen = false
        
        // Only reset shouldShowADCButton if we haven't built an ADC
        if !appModel.hasBuiltADC {
            shouldShowADCButton = false
        }
        
        print("✅ Completed LabViewModel cleanup\n")
    }
}

```

File: Views/ADCBuilderViewerButton.swift
```swift
//
//  ADCBuilderViewerButton.swift
//  SpawnAndAttrack
//
//  Created by Dale Carman on 12/13/24.
//

import SwiftUI

struct ADCBuilderViewerButton: View {
    @Environment(AppModel.self) private var appModel
    @Environment(\.openWindow) private var openWindow
    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
    @State private var rotation: CGFloat = 0.0
    @State private var currentTheme: GradientTheme = .lightBlue
    var scaleEffect: CGFloat = 1.2
    var width: CGFloat = 400
    var height: CGFloat = 250
    
    var body: some View {
        NavigationButton(
            title: "ADC Builder",
            action: {
                Task {
                    print("builder window status: \(appModel.isBuilderInstructionsOpen)")
                    print("setting builder window status to true")
                    appModel.isBuilderInstructionsOpen = true
                    await appModel.transitionToPhase(.building)
                }
            },
            font: .title,
            scaleEffect: 1.1,
            width: 200,
            theme: currentTheme,
            gradientWidth: width,
            gradientHeight: height
        )
        .fontWeight(.bold)
        .controlSize(.extraLarge)
        .opacity(appModel.labState.shouldShowADCButton ? 1 : 0)
        .animation(.spring(response: 0.5, dampingFraction: 0.7), value: appModel.labState.shouldShowADCButton)
        .transition(Appear())
    }
}

//#Preview {
//    ADCBuilderViewerButton()
//        .environment(AppModel())
//}

```

File: Views/AttackCancerView.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent


struct AttackCancerView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(\.scenePhase) private var scenePhase
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.realityKitScene) private var scene
    @Environment(\.openWindow) private var openWindow
    
    var body: some View {
        @Bindable var appModel = appModel
        
        RealityView { content, attachments in
            appModel.gameState.resetGameState()
            Logger.info("🔄 Reset game state")
            Logger.info("\n=== AttackCancerView Setup ===")
            Logger.info("📱 AttackCancerView: Setting up root")
            let root = appModel.gameState.setupRoot()
            root.name = "AttackCancerRoot"
            Logger.info("✅ Root entity created: \(root.name)")
            
            content.add(root)
            appModel.gameState.storedAttachments = attachments
            appModel.gameState.setupHandTracking(in: content, attachments: attachments)
            
            // Setup environment in a task after root is configured
            Task { @MainActor in
                Logger.info("\n=== Setting up Environment ===")
                await appModel.gameState.setupEnvironment(in: root, attachments: attachments)
                Logger.info("✅ Environment setup complete")
            }
        } attachments: {

        }
        .task {
            await appModel.trackingManager.processWorldTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.processHandTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.monitorTrackingEvents()
        }
        .gesture(
            SpatialTapGesture()
                .targetedToAnyEntity()
                .onEnded { value in
                    // Allow taps either if the game is running or if we're active in the test fire phase.
                    if appModel.gameState.isGameActive || appModel.gameState.isTestFireActive {
                        let location3D = value.convert(value.location3D, from: .local, to: .scene)
                        appModel.gameState.totalTaps += 1
                        
                        Task {
                            await appModel.gameState.handleTap(on: value.entity, location: location3D, in: scene)
                        }
                    }
                }
        )
        .onChange(of: appModel.gameState.shouldPlayStartButtonVO) { _, isReady in
            Logger.info("onChange: readyToStartGame changed to \(isReady)")
            if isReady {
                if let root = appModel.gameState.rootEntity {
                    Task {
                        // wait just a little to give it a breath...
                        try? await Task.sleep(for: .milliseconds(300))

                        Logger.info("\n>>> Playing start button VO...\n")
                        await appModel.gameState.playStartButtonVO(in: root)
                        
                        self.appModel.isHopeMeterUtilityWindowOpen = true
                        Logger.info("Hope meter utility window open = \(self.appModel.isHopeMeterUtilityWindowOpen)")
                    }
                    
                }
            }
        }
        .onChange(of: scenePhase) { _, newPhase in
            // Let the app handle scene phase changes
        }
        .onChange(of: appModel.isHopeMeterUtilityWindowOpen) { _, isOpen in
            Logger.info("onChange: isHopeMeterUtilityWindowOpen changed to \(isOpen)")
            if isOpen {
                openWindow(id: AppModel.hopeMeterUtilityWindowId)
                Logger.info("🎮 Setting up cancer cells")
                if let root = appModel.gameState.rootEntity {
                    Task {
                        await appModel.gameState.setupGameContent(in: root)
                    }
                }
            }
        }
        .onAppear {
            dismissWindow(id: AppModel.navWindowId)
        }
        .onDisappear {
            // Only perform teardown if not transitioning to a preserving state (e.g., .completed)
            if appModel.currentPhase != .completed {
                Task {
                    await appModel.gameState.tearDownGame()
                }
            } else {
                Logger.info("🚫 Skipping tearDownGame() for completed phase to preserve immersive assets")
            }
        }
        .onChange(of: appModel.shouldStartGame) { _, shouldStart in
            if shouldStart, let root = appModel.gameState.rootEntity {
                Task {
                    await appModel.gameState.handleGameStart(in: root)
                }
            }
        }
        .onChange(of: appModel.gameState.shouldUpdateHeadPosition) { _, shouldUpdate in
            if shouldUpdate && appModel.gameState.isReadyForInteraction {
                if let root = appModel.gameState.rootEntity,
                   let headTrackingRoot = root.findEntity(named: "headTrackingRoot") {
                    Logger.info("""
                    
                    🎯 Head Position Update Requested
                    ├─ Phase: \(appModel.currentPhase)
                    ├─ Current World Position: \(headTrackingRoot.position(relativeTo: nil))
                    ├─ Root Setup: \(appModel.gameState.isRootSetupComplete ? "✅" : "❌")
                    ├─ Environment: \(appModel.gameState.isEnvironmentSetupComplete ? "✅" : "❌")
                    └─ HeadTracking: \(appModel.gameState.isHeadTrackingRootReady ? "✅" : "❌")
                    """)
                    
                    Task {
                        headTrackingRoot.checkHeadPosition(animated: true, duration: 0.5)
                        appModel.gameState.shouldUpdateHeadPosition = false
                        appModel.gameState.isPositioningComplete = true  // Set after animation completes
                    }
                }
            }
        }
        .onChange(of: appModel.gameState.isPositioningComplete) { _, complete in
            if complete {
                Task { @MainActor in
                    // If tutorial should start, start it now
                    if appModel.isTutorialStarted && !appModel.gameState.isSetupComplete,
                       let root = appModel.gameState.rootEntity,
                       let attachments = appModel.gameState.storedAttachments {
                        Logger.info("🎓 Starting tutorial after positioning complete...")
                        await appModel.gameState.startTutorial(in: root, attachments: attachments)
                    }
                }
            }
        }
        .onChange(of: appModel.gameState.isHopeMeterRunning) { _, isRunning in
            if !isRunning {
                Logger.info("Hope meter stopped - closing utility window")
                dismissWindow(id: AppModel.hopeMeterUtilityWindowId)
                appModel.isHopeMeterUtilityWindowOpen = false
            }
        }
    }
}

```

File: Views/AttackCancerViewerButton.swift
```swift
//
//  AttackCancerViewerButton.swift
//  SpawnAndAttrack
//
//  Created by Dale Carman on 12/13/24.
//

import SwiftUI

// Color theme enum for testing different combinations
enum GradientTheme: CaseIterable {
    case darkRed
    case lightRed
    case lightGreen
    case lightMustard
    case lightBlue
    
    var colors: [Color] {
        switch self {
        case .darkRed:
            return [
                Color("DarkRed800"),
                Color("DarkRed600"),
                Color("DarkRed400"),
                Color("DarkRed200"),
                Color("DarkRed050")
            ]
        case .lightRed:
            return [
                Color("LightRed800"),
                Color("LightRed600"),
                Color("LightRed400"),
                Color("LightRed200"),
                Color("LightRed050")
            ]
        case .lightGreen:
            return [
                Color("LightGreen800"),
                Color("LightGreen600"),
                Color("LightGreen400"),
                Color("LightGreen200"),
                Color("LightGreen050")
            ]
        case .lightMustard:
            return [
                Color("LightMustard800"),
                Color("LightMustard600"),
                Color("LightMustard400"),
                Color("LightMustard200"),
                Color("LightMustard050")
            ]
        case .lightBlue:
            return [
                Color("LightBlue800"),
                Color("LightBlue600"),
                Color("LightBlue400"),
                Color("LightBlue200"),
                Color("LightBlue050")
            ]
        }
    }
}

struct AttackCancerViewerButton: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel
    @Environment(\.openWindow) private var openWindow
    @State private var rotation: CGFloat = 0.0
    @State private var currentTheme: GradientTheme = .lightMustard
    var scaleEffect: CGFloat = 1.2
    var width: CGFloat = 450
    var height: CGFloat = 350
    
    // MARK: - Debug Controls
    #if DEBUG
    private let isDebugMode = false
    #else
    private let isDebugMode = false
    #endif
    
    private var shouldShowButton: Bool {
        isDebugMode || appModel.hasBuiltADC
    }
    
    private func cycleTheme() {
        guard let currentIndex = GradientTheme.allCases.firstIndex(of: currentTheme) else { return }
        let nextIndex = (currentIndex + 1) % GradientTheme.allCases.count
        currentTheme = GradientTheme.allCases[nextIndex]
    }
    
    var body: some View {
        Group {
            if shouldShowButton {
                NavigationButton(
                    title: "Attack Cancer",
                    action: {
                        if isDebugMode {
                            cycleTheme()
                        } else {
                            Task {
                                // if !appModel.isMainWindowOpen {
                                //     openWindow(id: AppModel.mainWindowId)
                                //     appModel.isMainWindowOpen = true
                                // }
                                appModel.isInstructionsWindowOpen = true
                                await appModel.transitionToPhase(.playing, adcDataModel: dataModel)
                            }
                        }
                    },
                    font: .title,
                    scaleEffect: AppModel.UIConstants.buttonExpandScale,
                    width: 250,
                    theme: currentTheme,
                    gradientWidth: width,
                    gradientHeight: height
                )
                .fontWeight(.bold)
                .onAppear {
                    withAnimation(.linear(duration: 4).repeatForever(autoreverses: false)) {
                        rotation = 360
                    }
                }
                .transition(Appear())
            }
        }
        .animation(.spring(response: 0.5, dampingFraction: 0.7), value: shouldShowButton)
    }
}

//#Preview {
//    AttackCancerViewerButton()
//}

```

File: Views/CompletedView.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

struct CompletedView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel
    @Environment(\.openWindow) private var openWindow
    @Environment(\.dismissWindow) private var dismissWindow
    @State private var animateStats = false
    @State private var opacity: Double = 0  // Add state for opacity
    
    private var stats: (destroyed: Int, deployed: Int, score: Int) {
        let gameState = appModel.gameState
        return (
            destroyed: gameState.cellsDestroyed,
            deployed: gameState.totalADCsDeployed,
            score: gameState.score
        )
    }
        
    var body: some View {

        VStack(spacing: 0) {
                // Header with logo and title
                ZStack {
                    HStack {
                        Image("Pfizer_Logo_White_RGB")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 100)
                        Spacer()
                    }
                    
                    Text("Mission Complete")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .padding(.bottom, 30)

                    Text("Outstanding work!")
                        .font(.title2)
                        .foregroundStyle(.secondary)
                        .padding(.top, 50)
                }
                .padding(30)
                .background(.black.opacity(0.4))
                .frame(width: 648)
                
                // Content section
                VStack {
                    statRow("ADCs Deployed", value: stats.deployed, icon: "arrow.up.forward")
                }
                .padding(.vertical, 20)
                .padding(.horizontal, 100)
                
                NavigationButton(
                    title: "Continue",
                    action: {
                        Logger.info("=== Starting Transition to Outro ===")
                                Logger.info("Current Phase: \(appModel.currentPhase)")
                                Logger.info("Immersive Space State: \(appModel.immersiveSpaceState)")
                                
                                // Start fade out sequence
                                withAnimation(.easeOut(duration: 1.0)) {
                                    opacity = 0.0
                                }
                                
                                // After window fades, transition to outro
                                Task {
                                    try? await Task.sleep(for: .seconds(1.0))
                                    await appModel.transitionToPhase(.outro)
                                }
                        },
                        font: .title,
                        width: 250
                    )
                    .fontWeight(.bold)
                    .padding(.vertical, 30)
                    .transition(.asymmetric(
                        insertion: .opacity.combined(with: .scale),
                        removal: .opacity.combined(with: .scale).combined(with: .move(edge: .leading))
                    ))
                
            }
            .frame(width: 648)
            .frame(alignment: .top)
            .glassBackgroundEffect()
            .clipShape(RoundedRectangle(cornerRadius: 20))
            .opacity(opacity) 
            .onAppear {
                    withAnimation(.easeIn(duration: 2.0)) {
                        opacity = 1.0
                    }
                }
            .onDisappear {
                withAnimation(.easeOut(duration: 1.0)) {
                    opacity = 1.0
                }
            } // Single opacity modifier for the entire view
            .transition(Appear())
    }

    // Helper functions moved outside of body
    private func statRow(_ title: String, value: Int, icon: String) -> some View {
        HStack {
            Label(title, systemImage: icon)
                .font(.title2)
                .bold()
                .foregroundStyle(.secondary)
            Spacer()
            Text("\(value)")
                .font(.title)
                .bold()
                .monospacedDigit()
        }
    }
}

```

File: Views/ContentView.swift
```swift
//
//  ContentView.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 12/22/24.
//
import SwiftUI

struct ContentView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var adcDataModel
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.openWindow) private var openWindow

    var body: some View {
        Group {
            switch appModel.currentPhase {
            case .loading, .ready, .intro:
                LoadingView()
            case .building:
                ADCView()
                    .environment(adcDataModel)
            case .playing:
                if appModel.isInstructionsWindowOpen {
                    AttackCancerInstructionsView()
                        .environment(appModel)
                        .environment(adcDataModel)
                }
            case .completed:
                CompletedView()
                    .environment(appModel)
                    .environment(adcDataModel)
            case .outro:
                EmptyView()
            default:
                EmptyView()
            }
        }
        .onChange(of: appModel.currentPhase) { oldPhase, newPhase in
            if newPhase == .loading {
                // Reset loading state and re-trigger loading process
                Task {
                    await appModel.startLoading(adcDataModel: adcDataModel)
                }
            }
        }
        .task {
            if appModel.currentPhase == .loading {
                await appModel.startLoading(adcDataModel: adcDataModel)
            }
        }
        .onAppear {
            appModel.isMainWindowOpen = true
        }
    }
}

```

File: Views/ErrorView.swift
```swift
import SwiftUI

struct ErrorView: View {
    var body: some View {
        VStack(spacing: 20) {
            Text("An Error Occurred")
                .font(.largeTitle)
                .fontWeight(.bold)
                .foregroundStyle(.primary)

            Text("We encountered an issue while loading assets.")
                .font(.title3)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal)

            Button(action: {
                // Optionally, provide a way to retry loading assets
                // For example, reset the gamePhase and start loading again
                // appModel.gamePhase = .setup
            }) {
                Text("Retry")
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
            .padding(.horizontal)
        }
        .padding()
    }
} 
```

File: Views/GradientNavigationButtonStyle.swift
```swift
import SwiftUI

struct GradientNavigationButtonStyle: ButtonStyle {
    let theme: GradientTheme
    let width: CGFloat
    let height: CGFloat
    let buttonWidth: CGFloat
    let buttonHeight: CGFloat
    @State private var rotation: CGFloat = 0.0
    
    func makeBody(configuration: Configuration) -> some View {
        ZStack {
            // Outer gradient border
            Capsule()
                .frame(width: width, height: height)
                .foregroundStyle(LinearGradient(gradient: Gradient(colors: theme.colors), 
                    startPoint: .top, endPoint: .bottom))
                .rotationEffect(.degrees(rotation))
                .mask {
                    Capsule()
                        .stroke(lineWidth: 20)
                        .frame(width: buttonWidth, height: buttonHeight)
                        .blur(radius: 10)
                }
                .hoverEffect { effect, isActive, proxy in
                    effect
                        .animation(.easeInOut(duration: 0.2)) {
                            $0.scaleEffect(isActive ? AppModel.UIConstants.buttonExpandScale : 1.0)
                        }
                }
            
            // Inner gradient border
            Capsule()
                .frame(width: width, height: height)
                .foregroundStyle(LinearGradient(gradient: Gradient(colors: theme.colors), 
                    startPoint: .top, endPoint: .bottom))
                .rotationEffect(.degrees(rotation))
                .mask {
                    Capsule()
                        .stroke(lineWidth: 10)
                        .frame(width: buttonWidth, height: buttonHeight)
                }
                .hoverEffect { effect, isActive, proxy in
                    effect
                        .animation(.easeInOut(duration: 0.2)) {
                            $0.scaleEffect(isActive ? AppModel.UIConstants.buttonExpandScale : 1.0)
                        }
                }
            
            // Button content
            configuration.label
                .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
        }
        .animation(.easeInOut(duration: 0.2), value: configuration.isPressed)
        .onAppear {
            withAnimation(.linear(duration: 4).repeatForever(autoreverses: false)) {
                rotation = 360
            }
        }
    }
}

extension View {
    func gradientNavigationButtonStyle(theme: GradientTheme, width: CGFloat, height: CGFloat, buttonWidth: CGFloat, buttonHeight: CGFloat = 60) -> some View {
        self.buttonStyle(GradientNavigationButtonStyle(theme: theme, width: width, height: height, buttonWidth: buttonWidth, buttonHeight: buttonHeight))
    }
}

```

File: Views/HitCounterView.swift
```swift
import SwiftUI

struct HitCounterView: View {
    @Environment(AppModel.self) private var appModel: AppModel
    let hits: Int
    let requiredHits: Int
    let isDestroyed: Bool
    private let lineWidth: CGFloat = 12
    private let fontSize: CGFloat = 75
    @State private var isPulsing = false
    @State private var isHit = false
    
    var progress: CGFloat {
        CGFloat(hits) / CGFloat(requiredHits)
    }
    
    var body: some View {
        if !isDestroyed && hits < requiredHits {
            ZStack {
                // Background circle
                Circle()
                    .stroke(lineWidth: lineWidth)
                    .opacity(0.2)
                    .foregroundColor(.gray)
                    .frame(width: 120, height: 120)
                
                // Progress circle
                Circle()
                    .trim(from: 0, to: progress)
                    .stroke(style: StrokeStyle(lineWidth: lineWidth, lineCap: .round))
                    .foregroundColor(.blue)
                    .rotationEffect(.degrees(-90))
                    .animation(.linear(duration: 0.5), value: hits)
                    .frame(width: 120, height: 120)
                
                Image(systemName: "target")
                    .font(.system(size: fontSize))
                    .foregroundColor(.white)
                    .scaleEffect(isPulsing ? 1.1 : 1.0)
                    .scaleEffect(isHit ? 1.3 : 1.0)
                    .animation(.easeInOut(duration: 0.5), value: isHit)
                    .animation(.easeInOut(duration: 1.0).repeatForever(autoreverses: true), value: isPulsing)
                    .onAppear {
                        isPulsing = true
                    }
            }
            .frame(width: 160, height: 160)
            .padding(30)
            .background(.clear)
            .onChange(of: hits) { _, newValue in
                if newValue >= requiredHits {
                    appModel.gameState.cellsDestroyed += 1
                } else {
                    // Trigger hit animation
                    isHit = true
                    // Reset after animation
                    Task {
                        try? await Task.sleep(for: .milliseconds(500))
                        isHit = false
                    }
                }
            }
        }
    }
}

#Preview(windowStyle: .automatic) {
    HitCounterView(hits: 3, requiredHits: 8, isDestroyed: false)
        .environment(AppModel())
}

```

File: Views/HopeMeterUtilityView.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

struct HopeMeterUtilityView: View {
    @Environment(AppModel.self) private var appModel
    
    private let height: CGFloat = 30
    private let fontSize: CGFloat = 20
    @State private var progressOpacity: Double = 0
    
    var progress: CGFloat {
        1.0 - (CGFloat(appModel.gameState.hopeMeterTimeLeft) / CGFloat(appModel.gameState.hopeMeterDuration))
    }
    
    var percentage: Int {
        Int(progress * 100)
    }
    
    var body: some View {
        if appModel.currentPhase == .playing {
            VStack(spacing: 0) {
                // Header with logo and title
                ZStack {
                    HStack {
                        Image("Pfizer_Logo_White_RGB")
                            .resizable()
                            .scaledToFit()
                            .frame(width: 100)
                        Spacer()
                    }
                    
                    Text("Hope Meter")
                        .font(.largeTitle)
                }
                .padding(30)
                .background(.black.opacity(0.4))
                .frame(width: 648)
                
                // Content section
                if !appModel.gameState.isHopeMeterRunning {
                    NavigationButton(
                        title: "Start",
                        action: {
                            withAnimation(.easeInOut(duration: 0.5)) {
                                appModel.startAttackCancerGame()
                            }
                        },
                        font: .title,
                        width: 250
                    )
                    .fontWeight(.bold)
                    .padding(.vertical, 30)
                    .transition(.asymmetric(
                        insertion: .opacity.combined(with: .scale),
                        removal: .opacity.combined(with: .scale).combined(with: .move(edge: .leading))
                    ))
                } else {
                    ZStack(alignment: .leading) {
                        // Background rectangle
                        RoundedRectangle(cornerRadius: height / 2)
                            .fill(Color("LightBlue200"))
                            .frame(height: height)
                        
                        // Progress rectangle using masking
                        RoundedRectangle(cornerRadius: height / 2)
                            .fill(Color("gradient600"))
                            .frame(height: height)
                            .mask(
                                GeometryReader { geometry in
                                    RoundedRectangle(cornerRadius: height / 2)
                                        .frame(width: geometry.size.width * progress)
                                        .animation(.linear(duration: 0.5), value: progress)
                                }
                            )
                        
                        // Percentage text
                        Text("\(percentage)%")
                            .font(.system(size: fontSize))
                            .bold()
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                    }
                    .frame(width: 598)
                    .padding(.vertical, 30)
                    .opacity(progressOpacity)
                    .onAppear {
                        withAnimation(.easeIn(duration: 0.7)) {
                            progressOpacity = 1.0
                        }
                    }
                    .transition(.asymmetric(
                        insertion: .opacity.combined(with: .scale).combined(with: .move(edge: .trailing)),
                        removal: .opacity.combined(with: .scale)
                    ))
                }
            }
            .frame(width: 648)
            .frame(alignment: .top)
            .glassBackgroundEffect()
            .clipShape(RoundedRectangle(cornerRadius: 20))
            .transition(Appear())
        }
    }
}

//#Preview {
//    HopeMeterUtilityView()
//        .environment(AppModel())
//}

```

File: Views/HopeMeterView.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

struct HopeMeterView: View {
    @Environment(AppModel.self) private var appModel
    
    private let lineWidth: CGFloat = 12
    private let fontSize: CGFloat = 65
    
    var progress: CGFloat {
        1.0 - (CGFloat(appModel.gameState.hopeMeterTimeLeft) / CGFloat(appModel.gameState.hopeMeterDuration))
    }
    
    var percentage: Int {
        Int(progress * 100)
    }
    
    var body: some View {
        ZStack {
            VStack {
                Text("Hope Meter")
                    .font(.system(size: fontSize / 4))
                    .bold()
                Spacer()
                ZStack {
                    // Background circle
                    Circle()
                        .stroke(lineWidth: lineWidth)
                        .opacity(0.2)
                        .foregroundColor(.gray)
                        .frame(width: 120, height: 120)
                    
                    // Progress circle
                    Circle()
                        .trim(from: 0, to: progress)
                        .stroke(style: StrokeStyle(lineWidth: lineWidth, lineCap: .round))
                        .foregroundColor(.blue)
                        .rotationEffect(.degrees(-90))
                        .animation(.linear(duration: 0.5), value: progress)
                        .frame(width: 120, height: 120)
                    
                    // Percentage text
                    Text("\(percentage)%")
                        .font(.system(size: fontSize / 2))
                        .bold()
                        .shadow(color: .black, radius: 10, x: 0, y: 0)
                        .monospacedDigit()
                        .foregroundColor(.white)
                }
            }
        }
        .frame(width: 160, height: 160)
        .padding(30)
        .background(.clear)
    }
}


#Preview {
    
    HopeMeterView()
        .environment(AppModel())
}

```

File: Views/IntroWindowView.swift
```swift
import SwiftUI

struct IntroWindowView: View {
    var body: some View {
        VStack {
            Text("Let's Outdo Cancer")
                .font(.extraLargeTitle)
                .fontWeight(.bold)
                .padding()
        }
    }
}

#Preview {
    IntroWindowView()
}

```

File: Views/LabView.swift
```swift
//
//  LabView.swift
//  SpawnAndAttrack
//
//  Created by Dale Carman on 10/23/24.
//

import SwiftUI
import RealityKit
import RealityKitContent

/// A RealityView that creates an immersive lab environment with spatial audio and IBL lighting
struct LabView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(\.openWindow) private var openWindow
    @Environment(\.dismissWindow) private var dismissWindow
    
    // MARK: - View
    var body: some View {
        
        RealityView { content, attachments in
            print("📱 LabView: Setting up RealityView")
            // Set up root entity
            let root = appModel.labState.setupRoot()
            content.add(root)
            
            Task { @MainActor in
                // Setup initial environment
                try? await appModel.labState.setupInitialLabEnvironment(in: root)
                try? await appModel.labState.setupLabEnvironment(in: root)
                
                // Setup ADC placer if we have a built ADC
                await appModel.labState.setupADCPlacer(in: root)
            }
            
            // Now that environment is loaded, set up attachments
            if let adcButton = attachments.entity(for: "ADCBuilderViewerButton"),
               let attackButton = attachments.entity(for: "AttackCancerViewerButton") {
                
                // Find attachment points and set up buttons
                if let builderTarget = root.findEntity(named: "ADCBuilderAttachment") {
                    print("🎯 Found ADCBuilderAttachment target")
                    builderTarget.addChild(adcButton)
                    adcButton.components.set(BillboardComponent())
                    appModel.labState.adcBuilderViewerButtonEntity = adcButton
                } else {
                    print("❌ ADCBuilderAttachment target not found")
                }
                
                if let attackTarget = root.findEntity(named: "AttackCancerAttachment") {
                    print("🎯 Found AttackCancerAttachment target")
                    attackTarget.addChild(attackButton)
                    attackButton.components.set(BillboardComponent())
                    appModel.labState.attackCancerViewerButtonEntity = attackButton
                } else {
                    print("❌ AttackCancerAttachment target not found")
                }
            }
        } attachments: {
            Attachment(id: "ADCBuilderViewerButton") {
                ADCBuilderViewerButton()
            }
            Attachment(id: "AttackCancerViewerButton") {
                AttackCancerViewerButton()
            }
        }
        .task {
            await appModel.trackingManager.processWorldTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.monitorTrackingEvents()
        }
        .onAppear {
            dismissWindow(id: AppModel.navWindowId)
            // Ensure library window starts closed
            appModel.updateLibraryWindowState(isOpen: false)
        }
        .onDisappear {
            // Cleanup is now handled by AssetLoadingManager during phase transitions
        }
        .onChange(of: appModel.labState.isLibraryOpen) { _, isOpen in
            if isOpen {
                openWindow(id: AppModel.libraryWindowId)
                appModel.updateLibraryWindowState(isOpen: true)
            } else {
                dismissWindow(id: AppModel.libraryWindowId)
                appModel.updateLibraryWindowState(isOpen: false)
            }
        }
        .gesture(
            SpatialTapGesture()
                .targetedToAnyEntity()
                .onEnded { value in
                    appModel.labState.handleTap(on: value.entity)
                }
        )
    }
}

```

File: Views/LabViewerButton.swift
```swift
//
//  AttackCancerViewerButton.swift
//  SpawnAndAttrack
//
//  Created by Dale Carman on 12/13/24.
//

import SwiftUI

struct LabViewerButton: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel
    @Environment(\.openWindow) private var openWindow
    
    var body: some View {
        NavigationButton(
            title: "Enter The Lab",
            action: {
                Task {
                    await appModel.transitionToPhase(.lab, adcDataModel: dataModel)
                }
            },
            font: .title,
            scaleEffect: AppModel.UIConstants.buttonExpandScale,
            width: 250
        )
        .fontWeight(.bold)
    }
}

//#Preview {
//    AttackCancerViewerButton()
//}

```

File: Views/NavigationButton.swift
```swift
//
//  NavigationButton.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/21/25.
//

import SwiftUI

struct VisionNavigationButtonStyle: ButtonStyle {
    var font: Font = .body
    var width: CGFloat?
    var scaleEffect: CGFloat = AppModel.UIConstants.buttonExpandScale
    var theme: GradientTheme?
    var gradientWidth: CGFloat?
    var gradientHeight: CGFloat?
    @State private var rotation: CGFloat = 0.0

    func makeBody(configuration: Configuration) -> some View {
        ZStack {
            // If a gradient theme and sizes are provided, draw the animated gradient borders.
            if let theme = theme, let gradientWidth = gradientWidth, let gradientHeight = gradientHeight {
                // Outer gradient border with soft edge
                Capsule()
                    .frame(width: gradientWidth, height: gradientHeight)
                    .foregroundStyle(
                        LinearGradient(
                            gradient: Gradient(colors: theme.colors),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
                    .rotationEffect(.degrees(rotation))
                    .mask {
                        Capsule()
                            .stroke(lineWidth: 20)
                            .frame(width: width ?? 200, height: 60)
                            .blur(radius: 10)
                    }
                
                // Inner gradient border (sharp)
                Capsule()
                    .frame(width: gradientWidth, height: gradientHeight)
                    .foregroundStyle(
                        LinearGradient(
                            gradient: Gradient(colors: theme.colors),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
                    .rotationEffect(.degrees(rotation))
                    .mask {
                        Capsule()
                            .stroke(lineWidth: 10)
                            .frame(width: width ?? 200, height: 60)
                    }
            }
            
            // The button label and background
            configuration.label
                .font(font)
                .padding(.horizontal, AppModel.UIConstants.buttonPaddingHorizontal)
                .padding(.vertical, AppModel.UIConstants.buttonPaddingVertical)
                .frame(width: width)
                .background {
                    RoundedRectangle(
                        cornerRadius: AppModel.UIConstants.buttonCornerRadius,
                        style: .continuous
                    )
                    .fill(.thinMaterial)
                    .hoverEffect(.lift)
                }
                .glassBackgroundEffect()
                
        }
        // Animate the scale when the button is pressed.
        .scaleEffect(configuration.isPressed ? AppModel.UIConstants.buttonPressScale : 1.0)
        .animation(.easeOut(duration: 0.4), value: configuration.isPressed)
        // (Optional) Animate hover effects if needed.
//        .hoverEffect { effect, isActive, proxy in
//            effect
//                .animation(.easeInOut(duration: AppModel.UIConstants.buttonHoverDuration)) {
//                    $0.scaleEffect(isActive ? scaleEffect : 1.0)
//                }
//        }
        // .hoverEffect(.lift)
        // .hoverEffectGroup()
        // Start the continuous rotation animation for the gradient borders.
        .onAppear {
            withAnimation(.linear(duration: 4).repeatForever(autoreverses: false)) {
                rotation = 360
            }
        }
    }
}

struct NavigationButton: View {
    @Environment(AppModel.self) private var appModel
    let title: String
    let action: () async -> Void
    var font: Font = .body
    var scaleEffect: CGFloat = AppModel.UIConstants.buttonExpandScale
    var width: CGFloat? = nil
    var theme: GradientTheme? = nil
    var gradientWidth: CGFloat? = nil
    var gradientHeight: CGFloat? = nil
    
    var body: some View {
        Button {
            Task {
                // Add a small delay to let the press animation complete
                try? await Task.sleep(for: .milliseconds(150))
                await action()
            }
        } label: {
            Text(title)
        }
        .buttonStyle(VisionNavigationButtonStyle(
            font: font,
            width: width,
            scaleEffect: scaleEffect,
            theme: theme,
            gradientWidth: gradientWidth,
            gradientHeight: gradientHeight
        ))
    }
}

struct ScalableButtonStyle: ButtonStyle {
    var scaleFactor: CGFloat = AppModel.UIConstants.buttonExpandScale

    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? scaleFactor : 1.0)
            .animation(.interactiveSpring(response: 0.3, dampingFraction: 0.5), value: configuration.isPressed)
    }
}

struct ScalableGlassButtonStyle: ButtonStyle {
    var scaleFactor: CGFloat = AppModel.UIConstants.buttonExpandScale
    var cornerRadius: CGFloat = AppModel.UIConstants.buttonCornerRadius

    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding(.horizontal, AppModel.UIConstants.buttonPaddingHorizontal)
            .padding(.vertical, AppModel.UIConstants.buttonPaddingVertical)
            .background(
                Color.clear
                    .glassBackgroundEffect()
                    .clipShape(RoundedRectangle(cornerRadius: cornerRadius, style: .continuous))
            )
            .clipShape(RoundedRectangle(cornerRadius: cornerRadius, style: .continuous))
            .scaleEffect(configuration.isPressed ? scaleFactor : 1.0)
            .animation(.spring(response: AppModel.UIConstants.buttonPressDuration, dampingFraction: 0.5), value: configuration.isPressed)
    }
}

```

File: Views/NavigationView.swift
```swift
import SwiftUI
import RealityKitContent

struct NavigationView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) private var dataModel
    @Environment(\.openWindow) private var openWindow
    @Environment(\.scenePhase) private var scenePhase
    
    private let buttonTitles = ["Lab", "Building", "Attack", "Outro"]
    
    var body: some View {
        HStack(spacing: 30) {
            ForEach(buttonTitles, id: \.self) { title in
                NavigationButton(
                    title: title,
                    action: { await handleNavigation(for: title) },
                    width: 150
                )
                .fontWeight(.bold)
            }
        }
        .padding(20)
        .glassBackgroundEffect()
        .opacity(appModel.isNavWindowOpen ? 1 : 0)
        .animation(.default, value: appModel.isNavWindowOpen)
        
        .onChange(of: scenePhase, initial: true) { oldPhase, newPhase in
            switch newPhase {
            case .inactive, .background:
                appModel.isNavWindowOpen = false
            default:
                break
            }
        }
    }
    
    private func handleNavigation(for title: String) async {
        switch title {
        case "Building":
            appModel.isBuilderInstructionsOpen = true
            await appModel.transitionToPhase(.building)
        case "Attack":
            appModel.isInstructionsWindowOpen = true
            await appModel.transitionToPhase(.playing, adcDataModel: dataModel)
        default:
            await appModel.transitionToPhase(phaseFor(title))
        }
    }
    
    private func phaseFor(_ title: String) -> AppPhase {
        switch title {
        case "Lab": return .lab
        case "Building": return .building
        case "Attack": return .playing
        case "Outro": return .outro
        default: return .lab
        }
    }
}

//#Preview {
//    NavigationView()
//        .environment(AppModel())
//        .environment(ADCDataModel())
//}

```

File: Views/NavToggleView.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

struct NavToggleView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(\.openWindow) private var openWindow
    
    private let size: CGFloat = 60
    private let iconSize: CGFloat = 24
    
    var body: some View {
        Button(action: {
            openWindow(id: AppModel.navWindowId)
            appModel.isNavWindowOpen.toggle()
        }, label: {
            ZStack {
                Circle()
                    .fill(.ultraThinMaterial)
                    .frame(width: size, height: size)
                
                Image(systemName: "sidebar.left")
                    .font(.system(size: iconSize))
                    .fontWeight(.bold)
                    .shadow(radius: 2)
            }
        })
        .buttonStyle(ScalableButtonStyle())
        .glassBackgroundEffect()
        .hoverEffect { effect, isActive, proxy in
            effect
                .animation(.easeInOut(duration: 0.2)) {
                    $0.scaleEffect(isActive ? AppModel.UIConstants.buttonExpandScale : 1.0)
                }
        }
        .opacity(appModel.isNavWindowOpen ? 0 : 1)
    }
}

//#Preview {
//    NavToggleView()
//        .environment(AppModel())
//}

```

File: Views/OutroView.swift
```swift
//
//  OutroView.swift
//  SpawnAndAttrack
//
//  Created by Dale Carman on 10/23/24.
//

import SwiftUI
import RealityKit
import RealityKitContent

//extension Notification.Name {
//    static let changeToLabNotification = Notification.Name("ChangeToLab")
//}

/// A RealityView that creates an immersive lab environment with spatial audio and IBL lighting
struct OutroView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.openWindow) private var openWindow
    
    // Timer for auto-transition
    @State private var outroTintIntensity: Double = 0.02
    
    var surroundingsEffect: SurroundingsEffect? {
        let tintColor = Color(red: outroTintIntensity, green: outroTintIntensity, blue: outroTintIntensity)
        return SurroundingsEffect.colorMultiply(tintColor)
    }
    
    var body: some View {
        RealityView { content in
            print("\n=== Setting up OutroView ===")
            
            // Create and configure root
            let root = Entity()
            root.name = "OutroRoot"
            root.components.set(PositioningComponent(
                offsetX: 0,
                offsetY: -1.5,
                offsetZ: -1.0
            ))
            print("✅ Created root entity: \(root.name)")
            
            // Add root to content
            content.add(root)
            print("✅ Added root to content")
            
            // Load environment
            do {
                print("📱 OutroView: Loading environment")
                let outroEnvironmentEntity = try await appModel.assetLoadingManager.instantiateAsset(
                    withName: "outro_environment",
                    category: .outroEnvironment
                )
                print("✅ OutroView: Successfully loaded outro environment")
                
                root.addChild(outroEnvironmentEntity)
                print("✅ OutroView: Added environment to root")

                // IBL
                print("📱 OutroViewModel: Setting up IBL lighting")
                try await IBLUtility.addImageBasedLighting(to: root, imageName: "metro_noord_2k")
                print("✅ OutroViewModel: Added IBL lighting")
            

            } catch {
                print("❌ OutroView: Failed to load outro environment: \(error)")
            }
        }
        .preferredSurroundingsEffect(surroundingsEffect)
        .task {
            // Wait for environment animation to complete
            try? await Task.sleep(for: .seconds(55))
            print("🎯 OutroView: Transitioning to loading")
            await appModel.transitionToPhase(.loading)
        }
        .onAppear {
            print("\n=== OutroView Appeared ===")
            // Add tint animation
            withAnimation(.linear(duration: 30.0)) {
                outroTintIntensity = 0.02
            }
        }
        .task {
            await appModel.trackingManager.processWorldTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.monitorTrackingEvents()
        }
    }
}

```

File: Views/OutdoCancer.swift
```swift
//
//  OutdoCancer.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 1/8/25.
//

import SwiftUI

struct OutdoCancer: View {
    @Binding var showTitle: Bool
    
    var body: some View {
        VStack {
            ZStack {
                // Invisible placeholder text to maintain consistent layout
                Text("Let's Outdo Cancer")
                    .font(.extraLargeTitle)
                    .opacity(0)
                
                if showTitle {
                    AnimatedText()
                }
            }
            .padding()
            .frame(width: 600, height: 200)
        }
        
    }
}

struct AnimatedText: View {
    var body: some View {
        Text("Let's Outdo Cancer")
            .font(.extraLargeTitle)
            .transition(WordByWordTransition(
                totalDuration: 2.0,
                elementDuration: 0.8,
                extraBounce: 0.2
            ))
    }
}

```

File: Views/Screen.swift
```swift
//
//  Screen.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 2/13/25.
//

import SwiftUI

struct Screen: View {
    var body: some View {
        ScrollView(.vertical, showsIndicators: true) {
                    Image("screen")
                        .resizable()          // Makes the image scalable.
                        .scaledToFit()        // Keeps the aspect ratio while fitting the width.
                        .frame(maxWidth: .infinity)
                }
    }
}

#Preview {
    Screen()
}

```

File: Views/StartButton.swift
```swift
//
//  StartButton.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 12/13/24.
//

import SwiftUI

struct StartButton: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel
    @Environment(\.openWindow) private var openWindow
    @Environment(\.dismissWindow) private var dismissWindow
    
    var body: some View {
        NavigationButton(
            title: "Start",
            action: {
                Task {
                    Logger.info("\n=== Start Button Pressed ===")
                    Logger.info("Current Phase: \(appModel.currentPhase)")
                    Logger.info("isReadyForInteraction: \(appModel.introState.isReadyForHeadTracking)")
                    Logger.info("Setting shouldUpdateHeadPosition = true")
                    appModel.introState.shouldUpdateHeadPosition = true
                }
            },
            font: .title,
            scaleEffect: AppModel.UIConstants.buttonExpandScale,
            width: 200
        )
        .fontWeight(.bold)
    }
}
//#Preview {
//    StartButton()
//}

```

File: Info.plist
```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>NSHandsTrackingUsageDescription</key>
	<string>Hand tracking is required to spawn ADCs from your hand position</string>
	<key>NSWorldSensingUsageDescription</key>
	<string>We need to track your head position to enable interaction with the microscope.</string>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationPreferredDefaultSceneSessionRole</key>
		<string>UIWindowSceneSessionRoleApplication</string>
		<key>UIApplicationSupportsMultipleScenes</key>
		<true/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UISceneSessionRoleImmersiveSpaceApplication</key>
			<array>
				<dict>
					<key>UISceneInitialImmersionStyle</key>
					<string>UIImmersionStyleMixed</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>

```

File: Views/StartView.swift
```swift

import SwiftUI

struct StartView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(\.dismissWindow) private var dismissWindow
    @State private var showTitle = false

    var body: some View {
        Group {
            VStack {
                    Image("Pfizer_Logo_Color_RGB")
                        .resizable()
                        .scaledToFit()
                        .padding(80)
                    
                    if showTitle {
                        Text("Let's Outdo Cancer")
                            .font(.extraLargeTitle)
                            .transition(WordByWordTransition(
                                totalDuration: 2.0,    // Total animation duration
                                elementDuration: 0.8,   // Duration for each word
                                extraBounce: 0.2       // More bounce in the spring animation
                            ))
                    }
                    StartButton()
                    
                }
                .frame(width: 800, height: 600)
                
                .onAppear {
                    // Add 2 second delay before starting animation
                    Task { @MainActor in
                        try? await Task.sleep(for: .seconds(2))
                        withAnimation {
                            showTitle = true
                        }
                    }
                }
            }
        }
    }



//#Preview(windowStyle: .automatic) {
//    StartView()
//        .environment(AppModel())
//}

```

File: AppModel/AppModel.swift
```swift
//
//  AppModel.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman
//

import SwiftUI
import RealityKit
import RealityKitContent
import ARKit
import os

// MARK: - App Constants
extension AppModel {
    nonisolated static let mainWindowId = "main"
    nonisolated static let introWindowId = "intro"
    nonisolated static let libraryWindowId = "library"
    nonisolated static let builderWindowId = "builder"
    nonisolated static let navWindowId = "DebugNavigation"
    nonisolated static let gameCompletedWindowId = "Completed"
    nonisolated static let hopeMeterUtilityWindowId = "HopeMeterUtility"
    
    nonisolated static let introSpaceId = "IntroSpace"
    nonisolated static let outroSpaceId = "OutroSpace"
    nonisolated static let labSpaceId = "LabSpace"
    nonisolated static let buildingSpaceId = "BuildingSpace"
    nonisolated static let attackSpaceId = "AttackSpace"
    
    enum PositioningDefaults {
        case intro
        case building
        case playing
        
        var position: SIMD3<Float> {
            switch self {
            case .intro:    return SIMD3<Float>(0.0, -1.5, -1.0)
            case .building: return SIMD3<Float>(0.0, 1.2, -1.0)
            case .playing:  return SIMD3<Float>(0.0, 1.5, -1.0)
            }
        }
    }
    
    // MARK: - Global UI Settings
    enum UIConstants {
        // Button Dimensions
        static let buttonCornerRadius: CGFloat = 16
        static let buttonPaddingHorizontal: CGFloat = 24
        static let buttonPaddingVertical: CGFloat = 16
        static let buttonExpandScale: CGFloat = 1.1
        static let buttonPressScale: CGFloat = 0.85
        
        // Animation Durations
        static let buttonHoverDuration: CGFloat = 0.2
        static let buttonPressDuration: CGFloat = 0.3
    }
}

enum AppPhase: String, CaseIterable, Codable, Sendable, Equatable {
    case loading
    case ready
    case intro
    case lab
    case building
    case playing
    case completed
    case outro
    case error
    
    var needsImmersiveSpace: Bool {
        return self != .loading && self != .error && self != .building 
    }
    
    var needsHandTracking: Bool {
        switch self {
        case .intro, .lab, .building, .playing, .ready:
            return true
        case .loading, .completed, .outro, .error:
            return false
        }
    }
    
    var shouldKeepPreviousSpace: Bool {
        if self == .completed { return true }
        return false
    }
    
    var spaceId: String {
        switch self {
        case .intro: return AppModel.introSpaceId
        case .lab: return AppModel.labSpaceId
        case .building: return AppModel.buildingSpaceId
        case .playing, .completed: return AppModel.attackSpaceId
        case .outro: return AppModel.outroSpaceId
        case .ready: return AppModel.introSpaceId
        case .loading, .error: return ""
        }
    }
    
    var windowId: String {
        switch self {
        case .loading, .ready, .completed: return AppModel.mainWindowId
        case .intro: return AppModel.introWindowId
        case .lab: return AppModel.libraryWindowId
        case .building: return AppModel.builderWindowId
        case .playing, .outro, .error: return ""
        }
    }
    
    var instructionsWindowId: String? {
        switch self {
        case .playing: return AppModel.mainWindowId // Use main window for instructions
        default: return nil
        }
    }
}

@Observable
@MainActor
final class AppModel {
    // MARK: - Properties
    let trackingManager = TrackingSessionManager()
    
    var shouldDimSurroundings: Bool = false
    var hasBuiltADC: Bool = false
    
    /// Current phase of the app
    var currentPhase: AppPhase = .loading
    
    // MARK: - Immersive Space Management
    enum ImmersiveSpaceState {
        case closed
        case inTransition
        case open
    }
    
    enum DismissReason {
        case manual    // Our code dismissed it
        case system    // Digital Crown or system dismissed it
    }
    
    var immersiveSpaceState: ImmersiveSpaceState = .closed
    var immersiveSpaceDismissReason: DismissReason?
    var triggerImmersiveSpace = false
    
    var gameState: AttackCancerViewModel
    var introState: IntroViewModel
    var labState: LabViewModel
    var outroState: OutroViewModel
    var isNavWindowOpen = false
    var isHopeMeterUtilityWindowOpen = false
    var isLibraryWindowOpen = false
    var isIntroWindowOpen = false
    var isMainWindowOpen = false
    var isBuilderInstructionsOpen = false
    var isBuilderWindowOpen = false
    var isLoadingWindowOpen = false
    var readyToStartLab: Bool = false

    // MARK: - Immersion Style
    var introStyle: ImmersionStyle = .mixed
    var outroStyle: ImmersionStyle = .mixed
    var labStyle: ImmersionStyle = .full
    var buildingStyle: ImmersionStyle = .mixed
    var attackStyle: ImmersionStyle = .progressive(
        0.1...1.0,
        initialAmount: 0.85
    )

    // MARK: - Asset Management
    let assetLoadingManager = AssetLoadingManager.shared
    var loadingProgress: Float {
        switch assetLoadingManager.loadingState {
        case .notStarted:
            return 0
        case .loading(let progress):
            return progress
        case .completed:
            return 1
        case .error:
            return 0 // Or handle errors differently
        }
    }
    var displayedProgress: Float = 0.0 // Displayed progress for animation
    
    func toggleLibrary() {
        // Single source of truth for library state
        labState.isLibraryOpen.toggle()
    }
    
    func updateLibraryWindowState(isOpen: Bool) {
        isLibraryWindowOpen = isOpen
    }
    
    // MARK: - Space Management
    var currentImmersiveSpace: String?
    @ObservationIgnored private(set) var isTransitioning = false
    
    var hasImmersiveSpace: Bool {
        return currentImmersiveSpace != nil
    }
    
    // MARK: Start the Attack Cancer Game
    
    
    var shouldStartGame: Bool {
        gameState.tutorialComplete && gameState.isHopeMeterRunning
    }
    
    func startAttackCancerGame() {
        Logger.debug("🎮 Starting Attack Cancer Game (startAttackCancerGame called)")
        Logger.debug("Starting Hope Meter")
        startHopeMeter()
    }
    
    // MARK: - Hope Meter Management
    @ObservationIgnored private var hopeMeterTimer: Timer?
    
    func startHopeMeter() {
        Logger.debug("🕒 Starting Hope Meter (startHopeMeter called)")
        stopHopeMeter() // Ensure any existing timer is cleaned up
        
        gameState.hopeMeterTimeLeft = gameState.hopeMeterDuration // Reset timer
        gameState.isHopeMeterRunning = true
        
        // Create a task to trigger the ending sequence at 19 seconds
        Task { @MainActor in
            // Wait until 19 seconds remain (hopeMeterDuration - 19 seconds)
            try? await Task.sleep(for: .seconds(gameState.hopeMeterDuration - 19))
            
            // Check if we're still running before playing
            if gameState.isHopeMeterRunning {
                Logger.debug("playingEndingSequence audio")
                await gameState.playEndingSequence()
            }
        }
        
        hopeMeterTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            
            Task { @MainActor in
                if self.gameState.hopeMeterTimeLeft > 0 {
                    self.gameState.hopeMeterTimeLeft -= 1
                } else {
                    self.stopHopeMeter()
                    await self.gameState.hopeMeterDidRunOut()
                    // wait a second for the sound and then transition
                    try? await Task.sleep(for: .milliseconds(2000))
                    await self.transitionToPhase(.completed)
                }
            }
        }
    }
    
    func stopHopeMeter() {
        Logger.debug("🛑 Stopping Hope Meter")
        hopeMeterTimer?.invalidate()
        hopeMeterTimer = nil
        gameState.isHopeMeterRunning = false
    }
    
    @MainActor
    func accelerateHopeMeterToCompletion() async {
        Logger.debug("🚀 Accelerating hope meter to completion")
        
        // Stop the normal timer
        hopeMeterTimer?.invalidate()
        hopeMeterTimer = nil
        
        // Animate the hope meter to completion using SwiftUI's withAnimation over 2 seconds.
        // This assumes that the UI is bound to gameState.hopeMeterTimeLeft.
        await MainActor.run {
            withAnimation(.easeInOut(duration: 2.0)) {
                gameState.hopeMeterTimeLeft = 0
            }
        }
        
        // Wait for 2 seconds after the animation completes.
        try? await Task.sleep(nanoseconds: 2_000_000_000)
        
        // Mark the hope meter as finished.
        await MainActor.run {
            gameState.isHopeMeterRunning = false
        }
    }
    
    deinit {
        // Since we're on MainActor, we can directly invalidate the timer
        hopeMeterTimer?.invalidate()
        hopeMeterTimer = nil
    }
    
    // MARK: - Initialization
    init() {
        self.gameState = AttackCancerViewModel()
        self.introState = IntroViewModel()
        self.labState = LabViewModel()
        self.outroState = OutroViewModel()
        
        // Set up dependencies
        self.gameState.appModel = self
        self.introState.appModel = self
        self.labState.appModel = self
        self.outroState.appModel = self
        self.gameState.handTracking = self.trackingManager.handTrackingManager
        self.trackingManager.appModel = self  // Set the reference to AppModel
        Logger.debug("AppModel init() - Instance: \(ObjectIdentifier(self))")
    }
    
    // MARK: - Phase Management
    @MainActor
    func transitionToPhase(_ newPhase: AppPhase, adcDataModel: ADCDataModel? = nil) async {
        Logger.info("""
        
        🔄 === PHASE TRANSITION START ===
        ├─ From: \(currentPhase)
        ├─ To: \(newPhase)
        ├─ Current Tracking State: \(trackingManager.worldTrackingProvider.state)
        ├─ Has Hand Tracking: \(currentPhase.needsHandTracking)
        └─ Will Need Hand Tracking: \(newPhase.needsHandTracking)
        """)
        
        Logger.debug("🔄 Phase transition: \(currentPhase) -> \(newPhase)")
        Logger.debug("🔍 isTransitioning: \(isTransitioning)")
        Logger.debug("🔍 immersiveSpaceState: \(immersiveSpaceState)")
        guard !isTransitioning else {
            Logger.debug("⚠️ Already transitioning, skipping")
            return
        }
        isTransitioning = true
        defer { 
            isTransitioning = false 
            Logger.debug("✅ Phase transition completed: \(newPhase)")
        }

        // 1. Stop tracking if we're in a phase that uses it
        if currentPhase.needsHandTracking {
            Logger.info("🛑 Stopping tracking for phase transition")
            await trackingManager.stopTracking()
            
            do {
                // Wait for tracking to fully stop with verification
                try await trackingManager.waitForCleanup()
                if !trackingManager.verifyProviderState(expectRunning: false) {
                    Logger.error("❌ Tracking cleanup verification failed")
                    // Continue with transition but log the error
                }
            } catch {
                Logger.error("❌ Tracking cleanup failed: \(error)")
                // Continue with transition but log the error
            }
            
            Logger.info("📊 Post-Stop Tracking State: \(trackingManager.worldTrackingProvider.state)")
        }

        // 2. Pre-load assets for the new phase before cleanup
        await preloadAssets(for: newPhase, adcDataModel: adcDataModel)

        if newPhase == .playing {
            gameState.resetCleanupForNewSession()
        }

        // 3. Clean up current phase
        await cleanupCurrentPhase(for: newPhase)

        // 4. Set the new phase before starting tracking
        currentPhase = newPhase

        // 5. Start tracking if needed with retry logic
        if newPhase.needsHandTracking {
            await startTrackingWithRetry(for: newPhase)
        }
    }

    /// Attempts to start tracking with retry logic
    private func startTrackingWithRetry(for phase: AppPhase) async {
        let maxRetries = 3
        var trackingStarted = false
        
        for attempt in 1...maxRetries {
            do {
                // Add a small delay between attempts
                if attempt > 1 {
                    try await Task.sleep(for: .milliseconds(100))
                }
                
                try await trackingManager.startTracking(needsHandTracking: phase.needsHandTracking)
                
                // Verify tracking state
                if trackingManager.verifyProviderState(expectRunning: true) {
                    trackingStarted = true
                    Logger.info("✅ Tracking started successfully on attempt \(attempt)")
                    break
                } else {
                    Logger.error("❌ Provider state verification failed on attempt \(attempt)")
                }
            } catch {
                Logger.error("""
                
                ❌ Tracking start failed (Attempt \(attempt)/\(maxRetries))
                ├─ Error: \(error)
                ├─ Phase: \(phase)
                └─ Provider State: \(trackingManager.worldTrackingProvider.state)
                """)
                
                if attempt == maxRetries {
                    Logger.error("❌ All tracking start attempts failed")
                }
            }
        }
        
        if !trackingStarted {
            Logger.error("❌ Failed to start tracking after \(maxRetries) attempts")
            // Consider transitioning to error state or implementing recovery logic
        }
    }

    private func preloadAssets(for phase: AppPhase, adcDataModel: ADCDataModel?) async {
        if phase == .intro || phase == .playing {
            Logger.debug("\n=== Preparing ADC for intro and playing ===")
            if let adcDataModel = adcDataModel {
                do {
                    // Load and configure ADC template
                    Logger.debug("🎯 Loading ADC template...")
                    let adcEntity = try await assetLoadingManager.instantiateAsset(
                        withName: "adc",
                        category: .adc
                    )
                    Logger.debug("✅ ADC entity loaded, applying colors...")
                    gameState.setADCTemplate(adcEntity, dataModel: adcDataModel)
                    Logger.debug("✅ ADC template configured with colors")
                    
                    // Pass template to lab state if we have built an ADC
                    labState.adcTemplate = gameState.adcTemplate
                    Logger.debug("✅ ADC template passed to lab state")
                    

                } catch {
                    Logger.debug("❌ Failed to load playing phase assets: \(error)")
                }
            } else {
                Logger.debug("❌ No ADCDataModel available for playing phase")
            }
        }
        if phase == .playing {
            Logger.debug("\n=== Pre-loading Playing Phase Assets ===")
            Logger.debug("📱 Pre-loading required assets for playing phase...")
            if adcDataModel != nil {
                do {
                    
                    // Ensure tutorial asset is loaded and cached
                    Logger.debug("🎯 Loading tutorial assets...")
                    _ = try await assetLoadingManager.instantiateAsset(
                        withName: "game_start_vo",
                        category: .attackCancerEnvironment
                    )
                    Logger.debug("✅ Tutorial assets cached")

                    // ADDED: Load and cache attack_cancer_environment
                    Logger.debug("🎯 Loading attack_cancer_environment...")
                    _ = try await assetLoadingManager.instantiateAsset(
                        withName: "attack_cancer_environment",
                        category: .attackCancerEnvironment
                    )
                    Logger.debug("✅ attack_cancer_environment cached")
                    try? await Task.sleep(for: .milliseconds(100)) // Small delay
                    Logger.debug("✅✅✅ Playing Phase Assets Ready (with delay) ===\n") // More emphatic message

                } catch {
                    Logger.debug("❌ Failed to load playing phase assets: \(error)")
                }
            } else {
                Logger.debug("❌ No ADCDataModel available for playing phase")
            }
        } else if phase == .outro {
            Logger.debug("\n=== Pre-loading Outro Phase Assets ===")
            Logger.debug("📱 Pre-loading outro environment...")
            do {
                _ = try await assetLoadingManager.instantiateAsset(
                    withName: "outro_environment",
                    category: .outroEnvironment
                )
                Logger.debug("✅ Outro environment cached")
                Logger.debug("=== Outro Phase Assets Ready ===\n")
            } catch {
                Logger.debug("❌ Failed to pre-load outro environment: \(error)")
            }
        } else if phase == .building {
            os_log(.debug, "AppModel: Preloading Building Phase Assets...")
            // Optionally trigger a preloading for building assets if needed (for example, loading "antibody_scene" here)
            do {
                let scene = try await assetLoadingManager.instantiateAsset(
                    withName: "antibody_scene",
                    category: .buildADCEnvironment
                )
                os_log(.debug, "AppModel: Preloaded antibody_scene for Building Phase: %@", String(describing: scene))
            } catch {
                os_log(.error, "AppModel: Failed to preload Building Phase asset 'antibody_scene': %@", error.localizedDescription)
            }
        }
    }


    private func cleanupCurrentPhase(for newPhase: AppPhase) async {
        switch currentPhase {
        case .intro:
            // now that intro and lab are combined, we need to cleanup both
            introState.cleanup()
            await assetLoadingManager.releaseIntroEnvironment()
            labState.cleanup()
            await assetLoadingManager.releaseLabEnvironment()
        case .lab:
            labState.cleanup()
            await assetLoadingManager.releaseLabEnvironment()
        case .playing:
            if newPhase != .completed {
                Logger.debug("I am in the playing phase and I am not transitioning to completed so I am cleaning up")
                await gameState.cleanup()
                await assetLoadingManager.releaseAttackCancerEnvironment()
            } else {
                Logger.debug("I am in the playing phase and transitioning to completed, so preserving immersive assets")
            }
        case .completed:
            if newPhase == .outro {
                await gameState.fadeOutScene()
                try? await Task.sleep(for: .seconds(0.5))
                // Note: We're already preserving assets for outro transition
            } else {
                Logger.debug("I am in the completed phase and transitioning to \(newPhase); cleaning up normally.")
                await gameState.cleanup()
                await assetLoadingManager.releaseAttackCancerEnvironment()
            }
        case .outro:
            outroState.cleanup()
            await assetLoadingManager.releaseOutroEnvironment()
        case .ready, .loading, .building, .error:
            break // No cleanup needed.
        }
    }
    
    var isTutorialStarted: Bool = false
    
    // Track instruction window state
    var isInstructionsWindowOpen = false
    
    func startTutorial() {
        isTutorialStarted = true
        
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent
import Combine

@Observable
@MainActor
final class AttackCancerViewModel {
    // MARK: - State Tracking
    var isRootSetupComplete: Bool = false
    var isEnvironmentSetupComplete: Bool = false
    var shouldUpdateHeadPosition: Bool = false
    var isHeadTrackingRootReady: Bool = false
    var isPositioningComplete: Bool = false
    
    // Track when we're fully ready for interactions
    var isReadyForInteraction: Bool {
        isRootSetupComplete && 
        isEnvironmentSetupComplete && 
        isHeadTrackingRootReady
    }
    
    // MARK: - Collision Filters
    static var adcFilter: CollisionFilter {
        let adcMask = CollisionGroup.all.subtracting(adcGroup)
        return CollisionFilter(group: adcGroup, mask: adcMask)
    }
    
    static var cancerCellFilter: CollisionFilter {
        let cellMask = CollisionGroup.all.subtracting(cancerCellGroup)
        return CollisionFilter(group: cancerCellGroup, mask: cellMask)
    }
    
    static var microscopeFilter: CollisionFilter {
        let microscopeMask = CollisionGroup.all
        return CollisionFilter(group: microscopeGroup, mask: microscopeMask)
    }

    // MARK: - Collision Groups
    static let adcGroup = CollisionGroup(rawValue: 1 << 0)
    static let cancerCellGroup = CollisionGroup(rawValue: 1 << 1)
    static let microscopeGroup = CollisionGroup(rawValue: 1 << 2)
    
    // MARK: - Collision Properties
    var debounce: [UnorderedPair<Entity>: TimeInterval] = [:]
    let debounceThreshold: TimeInterval = 0.1
    
    // MARK: - Properties
    var storedAttachments: RealityViewAttachments?
    var rootEntity: Entity?
    var scene: RealityKit.Scene?
    var handTrackedEntity: Entity?
    var isSetupComplete = false
    var environmentLoaded = false
    var tutorialCancerCell: Entity?
    var testFireCell: Entity?
    var tutorialComplete = false
    var isTestFireActive = false
    var testFireComplete = false
    var readyToStartGame = false

    // MARK: - Audio Debug Properties
    var audioDebugCone: ModelEntity?
    var isAudioDebugVisible: Bool = false

    var shouldPlayStartButtonVO: Bool {
        readyToStartGame && tutorialComplete
    }

    // MARK: - Properties for Audio
    var endGameAudioSource: Entity?
    var endGameAudioResource: AudioFileResource?
    var endGameAudioController: AudioPlaybackController?
    var loadedAudioResources: [String: AudioFileResource] = [:]
    
    // MARK: - Sequence-specific Audio Properties
    var endingSequenceAudioSource: Entity?
    var victorySequenceAudioSource: Entity?
    var endingSequenceController: AudioPlaybackController?
    var victorySequenceController: AudioPlaybackController?
    
    // MARK: - Transition Properties
    var isTransitioningOut = false
    var transitionOpacity: Float = 1.0
    
    // Store subscription to prevent deallocation
    internal var subscription: Cancellable?
    
    // Dependencies
    var appModel: AppModel!
    var handTracking: HandTrackingManager!
    
    // MARK: - Game Stats
    var hitProbability: Double = 0.3
    var maxCancerCells: Int = 25
    var cellsDestroyed: Int = 0
    var totalADCsDeployed: Int = 0
    var totalTaps: Int = 0
    var totalHits: Int = 0
    
    // MARK: - Hope Meter
    let hopeMeterDuration: TimeInterval = 30
    var hopeMeterTimeLeft: TimeInterval
    var isHopeMeterRunning = false
    
    var isGameActive: Bool {
        // Only consider the game active if both tutorial is complete AND hope meter is running
        tutorialComplete && testFireComplete && isHopeMeterRunning
    }
    
    // MARK: - ADC Properties
    var adcTemplate: Entity?
    var hasFirstADCBeenFired = false
    
    // MARK: - Cell State Properties
    var cellParameters: [CancerCellParameters] = []
    
    // Add after other private properties
    let tutorialADCDelays: [TimeInterval] = [
        2.0,  // First ADC at 2s
        1.9,  // Second ADC at 3.9s
        1.9,  // Third ADC at 5.8s
        1.9,  // Fourth ADC at 7.7s
        1.9,  // Fifth ADC at 9.6s
        1.9,  // Sixth ADC at 11.5s
        1.9,  // Seventh ADC at 13.4s
        1.9,  // Eighth ADC at 15.3s
        1.9,  // Ninth ADC at 17.2s
        1.8   // Tenth ADC at 19s
    ]
    
    // Root entity for the instructions view
    var instructionsRootEntity: Entity?
    
    // NEW: Store a reference to the CancerCellSystem.
    var cancerCellSystem: CancerCellSystem?
    
    // MARK: - Initialization
    init() {
        // Initialize handTrackedEntity
        self.handTrackedEntity = {
            let handAnchor = AnchorEntity(.hand(.left, location: .aboveHand))
            return handAnchor
        }()
        
        // Initialize hopeMeterTimeLeft
        self.hopeMeterTimeLeft = hopeMeterDuration
    }
    
    // MARK: - Cleanup and Reset Functions
    
    /// Tracks the current state of cleanup operations
    enum CleanupState {
        case none        // No cleanup in progress
        case gameOnly    // tearDownGame() in progress/complete
        case complete    // full cleanup() in progress/complete
    }
    
    /// Current cleanup state
    var cleanupState: CleanupState = .none
    
    /// Flag to prevent concurrent cleanup operations
    private var isCleaningUp = false

    /// Tears down the current game session's content while preserving the core system.
    /// Use this for cleaning up game-specific content without full system shutdown.
    ///
    /// Responsibilities:
    /// - Removes game entities (cells, ADCs)
    /// - Cleans up VO content
    /// - Resets positioning components
    /// - Cancels game-specific subscriptions
    /// - Does NOT clear core system references
    /// - Does NOT remove root entities
    /// - Does NOT affect app model connections
    ///
    /// Call this when:
    /// - Transitioning between game phases
    /// - Ending a game session
    /// - Preparing for a new game session
    func tearDownGame() async {
        // Prevent duplicate teardown
        guard cleanupState == .none else {
            Logger.debug("⚠️ Tear down already in progress or completed: \(cleanupState)")
            return
        }
        
        cleanupState = .gameOnly
        print("\n=== Tearing Down Game [Detailed] ===")
        print("📊 Initial State:")
        print("  - Hope Meter Running: \(isHopeMeterRunning)")
        print("  - Tutorial Started: \(appModel.isTutorialStarted)")
        print("  - Current Phase: \(appModel.currentPhase)")
        print("  - Test Fire Active: \(isTestFireActive)")
        
        // Stop systems first
        appModel.stopHopeMeter()
        subscription?.cancel()
        subscription = nil
        
        // Stop any playing audio
        Logger.audio("Stopping end game audio playback...")
        endGameAudioController?.stop()
        endGameAudioController = nil
        if let audioSource = endGameAudioSource {
            audioSource.removeFromParent()
            Logger.audio("Removed audio source from parent")
        }
        
        // Clear gameplay state
        cellParameters.removeAll()
        
        // Clear debounce dictionary
        debounce.removeAll()

        // Remove gameplay entities
        if let root = rootEntity {
            print("\n🔍 Examining root entity: \(root.name)")
            
            // Remove cancer cells
            var removedCells = 0
            for i in 0..<maxCancerCells {
                if let cell = root.findEntity(named: "cancer_cell_\(i)") {
                    cell.removeFromParent()
                    removedCells += 1
                }
            }
            // Remove test fire cell if it exists
            if let testFireCell = root.findEntity(named: "cancer_cell_555") {
                testFireCell.removeFromParent()
                removedCells += 1
            }
            print("🗑️ Removed cancer cells: \(removedCells)")
            
            // Remove ADCs
            if let scene = root.scene {
                let adcQuery = EntityQuery(where: .has(ADCComponent.self))
                scene.performQuery(adcQuery).forEach { entity in
                    entity.removeFromParent()
                }
            }
            
            // Remove any VO entities from headTrackingRoot
            if let VO_parent = root.findEntity(named: "headTrackingRoot") {
                Logger.info("\n🎯 Cleaning up head tracking root")
                // Remove all child entities
                VO_parent.children.forEach { child in
                    child.removeFromParent()
                }
                
                // Reset positioning component to clean state
                if var positioningComponent = VO_parent.components[PositioningComponent.self] {
                    Logger.info("├─ Resetting PositioningComponent state")
                    positioningComponent.needsPositioning = false
                    positioningComponent.shouldAnimate = false
                    positioningComponent.animationDuration = 0.0
                    VO_parent.components[PositioningComponent.self] = positioningComponent
                }
                
                Logger.info("└─ Head tracking cleanup complete")
            }
        }
        
        // await resetGameState()
        print("✅ Game tear down complete\n")
    }

    /// Performs complete system cleanup and shutdown.
    /// Use this for full system teardown when leaving the game entirely.
    ///
    /// Responsibilities:
    /// - Performs game teardown first
    /// - Removes all entities including root
    /// - Clears all system references
    /// - Resets all flags to initial state
    /// - Prepares system for complete shutdown
    ///
    /// Call this when:
    /// - Exiting the game completely
    /// - Transitioning to a different app section
    /// - Requiring complete system reset
    func cleanup() async {
        guard !isCleaningUp else {
            Logger.debug("⚠️ Cleanup already in progress")
            return
        }
        guard cleanupState != .complete else {
            print("⚠️ Cleanup already completed")
            return
        }
        
        isCleaningUp = true
        print("\n=== Starting AttackCancerViewModel Cleanup ===")
        print("Current Phase: \(appModel.currentPhase)")
        print("Is Transitioning: \(appModel.isTransitioning)")
        
        // First tear down the game if not already done
        if cleanupState != .gameOnly {
            await tearDownGame()
        }
        
        // Clear entity references
        if let root = rootEntity {
            print("🗑️ Removing root entity")
            root.removeFromParent()
        }
        
        // Clear all references
        rootEntity = nil
        scene = nil
        tutorialCancerCell = nil
        instructionsRootEntity = nil
        adcTemplate = nil
        
        // Clear audio system references
        Logger.audio("Clearing audio system references...")
        endGameAudioSource = nil
        endGameAudioResource = nil
        endGameAudioController = nil
        
        // Reset flags
        isSetupComplete = false
        hasFirstADCBeenFired = false
        environmentLoaded = false
        isPositioningComplete = false
        
        cleanupState = .complete
        isCleaningUp = false
        print("✅ Completed AttackCancerViewModel cleanup\n")
    }

    // NEW: Reset function to be called at the start of a new game session.
    func resetCleanupForNewSession() {
        // Reset cleanup flags and other related state if needed.
        cleanupState = .none
        isCleaningUp = false
        // Optionally, reinitialize other game state if necessary.
        // For example, you might want to clear cell parameters and reset counters—
        // however, ensure that this reset does not conflict with the
        // app's intended state management.
        print("🔄 AttackCancerViewModel: Cleanup state has been reset for new session.")
    }

    func findCancerCell(withID id: Int) -> Entity? {
        // First check if ID is valid
        guard id >= 0 && id < cellParameters.count else { return nil }
        
        guard let root = rootEntity else { return nil }
        
        // Find the cell entity
        if let cell = root.findEntity(named: "cancer_cell_\(id)") {
            // Validate it has correct state component
            guard let stateComponent = cell.components[CancerCellStateComponent.self],
                  stateComponent.parameters.cellID == id else {
                print("⚠️ Found cell \(id) but state component mismatch")
                return nil
            }
            return cell
        }
        
        print("⚠️ Could not find cancer cell with ID: \(id)")
        return nil
    }

    func validateCellAlignment() {
        print("\n=== Validating Cell Alignment ===")
        for (index, parameters) in cellParameters.enumerated() {
            // Validate cellID matches index
            assert(parameters.cellID == index, "Cell parameter ID mismatch: expected \(index), got \(String(describing: parameters.cellID))")
            
            // Validate entity exists and has matching state
            guard let cell = findCancerCell(withID: index),
                  let stateComponent = cell.components[CancerCellStateComponent.self] else {
                assertionFailure("Missing cell or state component for index \(index)")
                continue
            }
            
            // Validate state component references same parameters
            assert(stateComponent.parameters.cellID == parameters.cellID, 
                   "State component parameter mismatch for cell \(index)")
            
            print("✅ Cell \(index) alignment validated")
        }
        print("=== Alignment Validation Complete ===\n")
    }

    /// Fades out the entire scene gracefully
    /// - Returns: Void
    @MainActor
    func fadeOutScene() async {
        Logger.info("🎬 Starting scene fade out")
        
        guard let root = rootEntity else {
            Logger.debug("⚠️ No root entity found for fade out")
            return
        }
        
        await root.fadeOpacity(
            to: 0.0,
            duration: 2.0,
            timing: .easeInOut,
            waitForCompletion: true
        )
        
        Logger.info("✨ Scene fade out complete")
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+Audio.swift
```swift
import SwiftUI
import RealityKitContent
import RealityKit

// MARK: - Audio Sequence Types
enum AudioSequenceType {
    case ending
    case victory
}

extension AttackCancerViewModel {
    // MARK: - Audio Setup
    
    /// Toggles the visibility of the audio debug cone
    func toggleAudioDebugVisuals() {
        isAudioDebugVisible.toggle()
        audioDebugCone?.isEnabled = isAudioDebugVisible
        Logger.audio("Audio debug visuals: \(isAudioDebugVisible ? "shown" : "hidden")")
    }
    
    /// Creates a debug cone to visualize the audio source direction
    func createAudioDebugCone() -> ModelEntity {
        // Create a cone mesh with specified dimensions
        let cone = MeshResource.generateCone(height: 0.2, radius: 0.1)
        
        // Create a red material
        var material = PhysicallyBasedMaterial()
        material.baseColor = .init(tint: .red, texture: nil)
        material.roughness = 0.8
        material.metallic = 0.0
        
        // Create the model entity
        let debugCone = ModelEntity(mesh: cone, materials: [material])
        
        // Set transform
        debugCone.transform = Transform(
            scale: .one,
            rotation: simd_quatf(angle: .pi / 2, axis: [1, 0, 0]) * // -90 degrees around X
                     simd_quatf(angle: .pi, axis: [0, 1, 0]),      // 180 degrees around Y
            translation: [0, 0, -0.1]
        )
        
        // Initially disabled
        debugCone.isEnabled = false
        
        return debugCone
    }
    
    func prepareEndGameAudio() async {
        Logger.audio("\n=== Preparing end game audio ===\n")
        
        // First verify we can find our root entities
        guard let root = appModel.gameState.rootEntity else {
            Logger.error("❌ Cannot prepare end game audio - root entity not found")
            return
        }
        Logger.audio("✅ Found root entity: \(root.name)")
        
        guard let headTrackingRoot = root.findEntity(named: "headTrackingRoot") else {
            Logger.error("❌ Cannot prepare end game audio - headTrackingRoot not found")
            return
        }
        Logger.audio("✅ Found headTrackingRoot at position: \(headTrackingRoot.position)")
        
        // Create ending sequence source
        let endingSource = Entity()
        endingSource.name = "EndingSequenceSource"
        endingSource.position = SIMD3<Float>(0, 0, 0.75)
        endingSource.components.set(SpatialAudioComponent(gain: 1.0, directivity: .beam(focus: 1.0)))
        
        // Create and add debug cone for ending sequence
        let endingDebugCone = createAudioDebugCone()
        endingSource.addChild(endingDebugCone)
        self.audioDebugCone = endingDebugCone
        Logger.audio("Added debug cone to ending sequence source")
        
        headTrackingRoot.addChild(endingSource)
        self.endingSequenceAudioSource = endingSource
        Logger.audio("✅ Created ending sequence source")
        
        // Create victory sequence source
        let victorySource = Entity()
        victorySource.name = "VictorySequenceSource"
        victorySource.position = SIMD3<Float>(0.5, 0, 0.75)  // Offset to the right
        victorySource.components.set(SpatialAudioComponent(gain: 1.0, directivity: .beam(focus: 1.0)))
        headTrackingRoot.addChild(victorySource)
        self.victorySequenceAudioSource = victorySource
        Logger.audio("✅ Created victory sequence source")
        
        // Load all audio resources
        do {
            // Load tone_cross
            Logger.audio("Attempting to load tone_cross_wav...")
            let toneCrossResource = try await AudioFileResource(named: "/Root/tone_cross_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["tone_cross"] = toneCrossResource
            Logger.audio("✅ Successfully loaded tone_cross")
            
            // Load heartbeat
            let heartbeatResource = try await AudioFileResource(named: "/Root/heartbeat_progressive_slow_to_fast_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["heartbeat"] = heartbeatResource
            Logger.audio("✅ Successfully loaded heartbeat")
            
            // Load smashed
            let smashedResource = try await AudioFileResource(named: "/Root/smashed_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["smashed"] = smashedResource
            Logger.audio("✅ Successfully loaded smashed")
            
            // Load magic_zing
            let magicZingResource = try await AudioFileResource(named: "/Root/magic_zing_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["magic_zing"] = magicZingResource
            Logger.audio("✅ Successfully loaded magic_zing")
            
            // Load hope meter restored
            let hopeRestoredResource = try await AudioFileResource(named: "/Root/Hope_Meter_Restored_wav", from: "Assets/Game/endGame.usda", in: realityKitContentBundle)
            loadedAudioResources["hope_restored"] = hopeRestoredResource
            Logger.audio("✅ Successfully loaded hope_restored")
            
            Logger.audio("✅ End game audio fully prepared with \(loadedAudioResources.count) sounds")
        } catch {
            Logger.error("❌ Failed to load audio resources: \(error.localizedDescription)")
            Logger.error("Error details: \(error)")
        }
    }
    
    // MARK: - Audio Playback
    func playEndSound(_ soundName: String, forSequence sequenceType: AudioSequenceType) async {
        Logger.audio("\n=== Playing sound: \(soundName) for sequence: \(sequenceType) ===\n")
        
        let (audioSource, controller) = switch sequenceType {
        case .ending:
            (endingSequenceAudioSource, endingSequenceController)
        case .victory:
            (victorySequenceAudioSource, victorySequenceController)
        }
        
        guard let source = audioSource,
              let resource = loadedAudioResources[soundName] else {
            Logger.error("❌ Required resources not found for \(soundName)")
            return
        }
        
        // Stop current controller if it exists
        controller?.stop()
        
        // Create new controller and store it
        let newController = source.prepareAudio(resource)
        newController.play()
        
        // Store the controller in the appropriate property
        switch sequenceType {
        case .ending:
            endingSequenceController = newController
        case .victory:
            victorySequenceController = newController
        }
        
        Logger.audio("✅ Started playing \(soundName) for \(sequenceType)")
    }
    
    /// Plays a sequence of audio elements with specified pauses between them
    /// - Parameters:
    ///   - sequence: Array of tuples containing the sound name and the pause duration
    ///   - type: The type of sequence being played (ending or victory)
    func playAudioSequence(_ sequence: [(sound: String, pauseAfter: TimeInterval)], type: AudioSequenceType) async {
        Logger.audio("\n=== Starting \(type) sequence with \(sequence.count) elements ===\n")
        
        for (index, element) in sequence.enumerated() {
            await playEndSound(element.sound, forSequence: type)
            
            if element.pauseAfter > 0 {
                Logger.audio("Pausing for \(element.pauseAfter) seconds after sound \(element.sound)")
                try? await Task.sleep(for: .seconds(element.pauseAfter))
            }
            
            Logger.audio("Completed playing sequence element \(index + 1)/\(sequence.count)")
        }
        
        Logger.audio("✅ Audio sequence completed")
    }
    
    /// Play hope_restored, wait 2 seconds, then play tone_cross
    func playVictorySequence() async {
        await playAudioSequence([
            ("hope_restored", 2.0),
            ("tone_cross", 0.0)
        ], type: .victory)
    }
    
    /// Play heartbeat, wait 19 seconds, then play magic_zing
    func playEndingSequence() async {
        await playAudioSequence([
            ("heartbeat", 19.0),
            ("magic_zing", 0.0)
        ], type: .ending)
    }
}
```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+Notifications.swift
```swift
import SwiftUI
import RealityKitContent
import RealityKit

extension AttackCancerViewModel {

    // MARK: - Notification Setup (This is now just for the timeline)
    func handleTimelineNotification(for entity: Entity) {
        // Add debug logging
        print("📢 Timeline notification received from \(entity.name)")
        
        // Main thread execution for UI updates
        DispatchQueue.main.async {
            print("🎯 Opening hope meter utility window")
            if !self.appModel.isHopeMeterUtilityWindowOpen {
                self.appModel.isHopeMeterUtilityWindowOpen = true
            }
        }
    }

    // No longer needed: setupNotifications, handleCancerCellUpdate, notifyCellStateChanged, notifyGameStateChanged, notifyScoreChanged

    func checkGameConditions() {
        // Instead, use the global cellsDestroyed counter updated by the CancerCellSystem.
        let totalGameCells = cellParameters.filter { !$0.isTutorialCell }.count
        #if DEBUG
        print("\n=== Game Completion Check ===")
        print("  - Total game cells: \(totalGameCells)")
        print("  - Global destroyed cells: \(cellsDestroyed)")
        #endif
        
        if totalGameCells > 0, cellsDestroyed >= totalGameCells {
            print("✅✅✅ ALL GAME CELLS DESTROYED! Condition met!")
            Task { @MainActor in
                // Play the end game tone using our new function
                await self.playEndSound("magic_zing", forSequence: .victory) // Added forSequence parameter
                
                // Delay a second to give the user a moment to look forward
                try? await Task.sleep(for: .milliseconds(1000))
                print("🎯 All game cells destroyed - accelerating hope meter")
                await appModel.accelerateHopeMeterToCompletion()
                // Wait for an additional 2 seconds after accelerateHopeMeterToCompletion finishes.
                try? await Task.sleep(for: .milliseconds(2000))
                await appModel.transitionToPhase(.completed)
            }
        }
    }

    // Optionally, if there's an area where the hope meter runs out, add a call there as well:
    func hopeMeterDidRunOut() async {
        Task { @MainActor in
            // Play the end game tone when hope meter runs out
            Logger.audio("\n=== playing end sound ===\n")
            await self.playVictorySequence() // self.playEndSound("heartbeat") // Example of playing a different sound
            // Additional actions can be added here
        }
    }
    
    /// Monitor hope meter time and trigger events at specific thresholds
    func checkHopeMeterThresholds() {
        // Only check if the game is active
        guard isGameActive else { return }
        
        // Check for 19 seconds remaining
        if hopeMeterTimeLeft <= 19 && hopeMeterTimeLeft > 18 {
            Logger.audio("Hope meter at 19 seconds - triggering ending sequence")
            Task { @MainActor in
                await playEndingSequence()
            }
        }
    }
    
    /// Update hope meter time and check thresholds
    func updateHopeMeter() {
        guard isHopeMeterRunning else { return }
        
        // Update time left
        hopeMeterTimeLeft = max(0, hopeMeterTimeLeft - 1/60)  // Assuming 60fps updates
        
        // Check for specific time thresholds
        checkHopeMeterThresholds()
        
        // Check for hope meter running out
        if hopeMeterTimeLeft <= 0 {
            isHopeMeterRunning = false
            Task { @MainActor in
                await hopeMeterDidRunOut()
            }
        }
    }
}

```

File: ViewModels/AttackCancerViewModel/AttackCancerViewModel+SceneSetup.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

extension AttackCancerViewModel {
    // MARK: - Setup Functions
    func setupRoot() -> Entity {
        // Reset the cleanup state for a new game session.
        cleanupState = .none
        
        // Reset state tracking
        isRootSetupComplete = false
        isEnvironmentSetupComplete = false
        isHeadTrackingRootReady = false
        isPositioningComplete = false
        
        Logger.info("🔄 Starting new game session: cleanupState and tracking states reset")
        Logger.info("📱 AttackCancerViewModel: Setting up root")
        
        let root = Entity()
        root.name = "AttackCancerRoot"
        // root.enableLargeRoomReverb()
        // root.position = AppModel.PositioningDefaults.playing.position
        
        // Keep headTrackingRoot setup - needed for AttackCancer functionality
        let headTrackingRoot = Entity()
        headTrackingRoot.position = AppModel.PositioningDefaults.playing.position
        headTrackingRoot.name = "headTrackingRoot"
        headTrackingRoot.components.set(PositioningComponent(
            offsetX: 0,
            offsetY: 0,
            offsetZ: -1.0,
            needsPositioning: false,
            shouldAnimate: false,
            animationDuration: 0.0
        ))
        root.addChild(headTrackingRoot)
        
        Logger.info("""
        
        ✅ Root Setup Complete
        ├─ Root Entity: \(root.name)
        ├─ HeadTracking Root: Added
        ├─ Position: \(headTrackingRoot.position(relativeTo: nil))
        └─ Positioning: Ready for explicit updates
        """)
        
        rootEntity = root
        isRootSetupComplete = true
        isHeadTrackingRootReady = true
        return root
    }
    
    func setupEnvironment(in root: Entity, attachments: RealityViewAttachments? = nil) async {
        Logger.info("\n🎯 Setting up AttackCancerView environment...")
        
        // prepare audio
        await prepareEndGameAudio()
        
        // IBL
        do {
            try await IBLUtility.addImageBasedLighting(to: root, imageName: "metro_noord_2k", intensity: 0.5)
        } catch {
            Logger.error("Failed to setup IBL: \(error)")
            isEnvironmentSetupComplete = false
            return
        }
        
        // Environment
        do {
            let environment = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "attack_cancer_environment",
                category: .attackCancerEnvironment
            )
            
            root.addChild(environment)
            
            Logger.info("setting up collisions")
            setupCollisions(in: environment)
            
            // Set up the scene
            scene = root.scene
            
            Logger.info("""
            
            ✅ Environment Setup Complete
            ├─ IBL: Configured
            ├─ Environment: Loaded
            └─ Collisions: Setup
            """)
            
            environmentLoaded = true
            isEnvironmentSetupComplete = true
        } catch {
            Logger.error("❌ Error setting up AttackCancerView environment: \(error)")
            environmentLoaded = false
            isEnvironmentSetupComplete = false
        }
        
        // NEW: Retrieve the shared CancerCellSystem (set via automatic registration)
        if let cancerSystem = CancerCellSystem.shared {
            self.cancerCellSystem = cancerSystem
            // Assign the onCellDestroyed closure.
            cancerSystem.onCellDestroyed = { [weak self] cellID in
                guard let self = self else { return }
                self.cellsDestroyed += 1
                Logger.info("Incremented cellsDestroyed to \(self.cellsDestroyed)")
                
                // Check if this was the test fire cell (ID 555)
                if cellID == 555 {
                    Logger.info("\nTest fire cell (ID 555) was destroyed")
                    testFireComplete = true
                    Logger.info(">>> Test fire complete - opening hope meter window...\n")

                    readyToStartGame = true
                    Logger.info(">>> Setting readyToStartGame to true...\n")

                    // wait 2 seconds before setting isTestFireActive to false
                    // try? await Task.sleep(for: .seconds(2))

                    isTestFireActive = false
                    Logger.info(">>> Setting isTestFireActive to false...\n")
                    
                    // only play the start button VO if the previous VO is finished.
                    // moved this to the onChange
                    
                } else {
                    // For other cells, check game conditions
                    self.checkGameConditions()
                }
            }
        }
    }
    
    // convenience function for Instructions screen
    func setupIBL(in root: Entity) async {
        do {
            try await IBLUtility.addImageBasedLighting(to: root, imageName: "metro_noord_2k", intensity: 0.5)
        } catch {
            Logger.error("Failed to setup IBL: \(error)")
        }
    }
    
    func startTutorial(in root: Entity, attachments: RealityViewAttachments? = nil) async {
        Logger.info("\n=== Starting Tutorial Sequence ===")
        
        // Ensure we have the scene reference
        scene = root.scene
        
        do {
            Logger.info("📱 Tutorial: Loading game start VO")
            let gameStartVO = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "game_start_vo",
                category: .attackCancerEnvironment
            )
            Logger.info("✅ Tutorial: Retrieved game start VO")
            
            if let VO_parent = root.findEntity(named: "headTrackingRoot") {
                Logger.info("🎯 Tutorial: Found VO parent")
                VO_parent.addChild(gameStartVO)
                root.addChild(VO_parent)
                Logger.info("✅ Tutorial: Added VO to scene")
                
                // Find tutorial cancer cell using existing pattern
                if let cell = gameStartVO.findEntity(named: "CancerCell_spawn") {
                    Logger.info("✅ Tutorial: Found tutorial cancer cell")
                    tutorialCancerCell = cell
                    
                    // Set up tutorial cell using ViewModel
                    setupTutorialCancerCell(cell)
                    Logger.info("✅ Tutorial: Cancer cell setup complete")
                    
                    // Start ADC firing sequence
                    Task {
                        await fireTutorialADCs(in: root)
                    }
                    Logger.info("✅ Tutorial: ADC sequence initiated")
                    isSetupComplete = true
                } else {
                    Logger.error("❌ Tutorial: Could not find CancerCell_spawn")
                }
            } else {
                Logger.error("❌ Tutorial: Could not find headTrackingRoot entity")
            }
        } catch {
            Logger.error("❌ Tutorial: Failed to load game start VO: \(error)")
        }
    }
    
    internal func playStartButtonVO(in root: Entity) async {
        Logger.info("\n=== Playing Start Button VO ===")
        do {
            let startButtonVO = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "PressStart_VO",
                category: .attackCancerEnvironment
            )
            Logger.info("✅ Retrieved start button VO")
            
            if let VO_parent = root.findEntity(named: "headTrackingRoot") {
                Logger.info("🎯 Found VO parent")
                VO_parent.addChild(startButtonVO)
                Logger.info("✅ Added start button VO to scene")
            } else {
                Logger.error("❌ Could not find headTrackingRoot entity")
            }
        } catch {
            Logger.error("❌ Failed to load start button VO: \(error)")
        }
    }
    
    private func fireTutorialADCs(in root: Entity, attachments: RealityViewAttachments? = nil) async {
        Logger.info("\n=== Starting Tutorial ADC Sequence ===")
        
        // Launch position is slightly offset to the right and above
        _ = SIMD3<Float>(0.25, 0.5, -0.25)
        
        // Calculate approach vector that points towards the cell from slightly in front
        // This ensures ADCs prefer antigens facing the player's view
        let approachPosition = SIMD3<Float>(0, 0.5, -1.0)  // Position in front of the cell

        // Find the cancerCell_complex within the tutorial cell
        guard let complexCell = tutorialCancerCell?.findEntity(named: "cancerCell_complex") else {
            Logger.error("❌ Could not find cancerCell_complex in tutorial cell")
            return
        }
        
        for (index, delay) in tutorialADCDelays.enumerated() {
            try? await Task.sleep(for: .seconds(delay))
            Logger.info("🚀 Firing tutorial ADC \(index + 1)/10")
            await handleTap(
                on: complexCell,
                location: approachPosition,  // Use approach position for targeting
                in: scene
            )
        }
        Logger.info("✅ Tutorial ADC sequence complete")
        
        Logger.info("⏱️ small delay before the test fire cell is spawned")
        try? await Task.sleep(for: .seconds(4.2))  
        
        // MARK: SPAWN TEST FIRE CELL
        Logger.info("\n🎯 Starting test fire sequence...\n")
        Task { @MainActor in
            await spawnTestFireCell(in: root)
        }

        // add a small delay to set readyToStartGame to true
        try? await Task.sleep(for: .seconds(8))
        
        appModel.gameState.tutorialComplete = true
        Logger.info("✅ Set tutorial complete to true")
        
        // set tutorial complete as a check so that the press start audio doesn't start too soon
        
        // set readyToStartGame to true in closure that checks for test fire completion
        
        // Test fire sequence active – deferring full game cell spawning until test fire is completed.
        // The full game setup will be triggered later (e.g., via UI when the start game button is pressed).
    }
    
    func handleGameStart(in root: Entity) async {
        // Fade out tutorial
        if let tutorialContent = root.findEntity(named: "headTrackingRoot") {
            await tutorialContent.fadeOpacity(to: 0, duration: 1)
        }
    }

    @MainActor
    func setupGameContent(in root: Entity, attachments: RealityViewAttachments? = nil) async {
        Logger.info("\n=== Initializing Cell States ===")
        
        // Reset game state before starting main game
        appModel.gameState.cellsDestroyed = 0
        cellParameters.removeAll()
        
        // ADC template is already set up during phase transition
        
        do {
            let cancerCellTemplate = try await appModel.assetLoadingManager.instantiateAsset(
                withName: "cancer_cell",
                category: .cancerCell
            )
            let maxCells = maxCancerCells
            await spawnCancerCells(in: root, from: cancerCellTemplate, count: maxCells)
            
            // Update required hits and setup hit tracking
            for i in 0..<maxCells {
                if let cell = root.findEntity(named: "cancer_cell_\(i)")?.findEntity(named: "cancerCell_complex") {
                    // Set initial required hits
                    if let stateComponent = cell.components[CancerCellStateComponent.self] {
                        Logger.info("🎯 Cell \(i) initialized - Required hits: \(stateComponent.parameters.requiredHits)")
                    }
                }
            }

            Logger.info("Cell Parameters after setup:")
            for (index, params) in cellParameters.enumerated() {
                Logger.info("  Cell \(index): isTutorialCell=\(params.isTutorialCell), isDestroyed=\(params.isDestroyed)")
            }

        } catch {
            Logger.error("❌ Failed to load cancer cell template: \(error)")
        }
    }
}

```

File: Views/AttackCancerInstructionsView.swift
```swift
//
//  AttackCancerInstructionsView.swift
//  ViewBuilder
//
//  Created by Dale Carman on 1/4/25.
//


import SwiftUI
import RealityKit
import OSLog

struct AttackCancerInstructionsView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel

    @Environment(\.dismiss) private var dismiss
    @Environment(\.openWindow) private var openWindow
    
    @State private var opacity: Double = 0  // Add state for opacity
    
    var body: some View {
        var adcEntity = Entity()
        
        NavigationStack {
            VStack {
//                Spacer()
                VStack {
                    RealityView { content in
                        print("\n=== AttackCancerInstructionsView Rotating ADC Setup ===")
                        print("📱 Instructions View: Setting up root entity")
                        let root = appModel.gameState.setupRoot()
                        content.add(root)
                        
                        // Setup IBL
                        await appModel.gameState.setupIBL(in: root)
                        print("✅ Instructions View: IBL setup complete")
                        
                        // Use the template from gameState (already has colors applied)
                        if let template = appModel.gameState.adcTemplate {
                            print("✅ Instructions View: Found ADC template")
                            adcEntity = template.clone(recursive: true)
                            adcEntity.components.set(RotationComponent())
                            root.addChild(adcEntity)
                            print("✅ Instructions View: Added ADC to display")
                        } else {
                            print("❌ Instructions View: No ADC template available")
                        }
                        print("=== Instructions View Setup Complete ===\n")
                    }
                }
                VStack(spacing: 0) {
                    // Title
                    Text("Attack Cancer Instructions")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .padding(.bottom, 30)
                    
                    // Instructions sections
                    VStack(alignment: .leading, spacing: 20) {
                        instructionSection(
                            title: "Target Cancer Cells",
                            description: "Look at a floating cancer cell in your environment and use a spatial tap gesture to launch an ADC to attack it.",
                            systemImage: "target"
                        )
                        
                        instructionSection(
                            title: "Track Progress",
                            description: "Watch the hit counter above each cell. Some cells require multiple hits.",
                            systemImage: "chart.bar.fill"
                        )
                        
                        instructionSection(
                            title: "Hope Meter",
                            description: "Keep an eye on your Hope Meter on your left hand. You have a limited amount of time!",
                            systemImage: "gauge.medium"
                        )
                        
                        instructionSection(
                            title: "Victory",
                            description: "Destroy as many cancer cells as possible before the Hope Meter depletes to win.",
                            systemImage: "trophy.fill"
                        )
                    }
                    .padding(.bottom, 60)
                    .padding(.horizontal, 120)
                    // Start button
                    NavigationButton(
                        title: appModel.isTutorialStarted ? "Attack Cancer!" : "Start Tutorial",
                        action: {
                            if !appModel.isTutorialStarted {
                                Logger.info("\n🎓 Initiating tutorial sequence...")
                                // Request head position update when ready
                                appModel.gameState.shouldUpdateHeadPosition = true
                                appModel.isTutorialStarted = true
                                appModel.isInstructionsWindowOpen = false
                            } else {
                                Logger.info("\n🎮 Starting game sequence...")
                                // Request head position update when ready
                                appModel.gameState.shouldUpdateHeadPosition = true
                                appModel.startAttackCancerGame()
                                appModel.isInstructionsWindowOpen = false
                                if !appModel.isHopeMeterUtilityWindowOpen {
                                    openWindow(id: AppModel.hopeMeterUtilityWindowId)
                                }
                            }
                        },
                        font: .title,
                        scaleEffect: AppModel.UIConstants.buttonExpandScale,
                        width: 200
                    )
                    .fontWeight(.bold)
                    // .padding(30)
                }
                .padding(.bottom, 100)
                .opacity(opacity)  // Apply opacity
                .onAppear {
                    withAnimation(.easeIn(duration: 2.0)) {
                        opacity = 1.0
                    }
                }
                .onDisappear {
                    withAnimation(.easeOut(duration: 1.0)) {
                        opacity = 1.0
                    }
                }
            }
        }
        .frame(minWidth: 800)
        .frame(minHeight: 900)
        

    }
    
    private func instructionSection(title: String, description: String, systemImage: String) -> some View {
        HStack(alignment: .top, spacing: 15) {
            Image(systemName: systemImage)
                .font(.title)
                .foregroundColor(.blue)
                .frame(width: 30)
            
            VStack(alignment: .leading, spacing: 5) {
                Text(title)
                    .font(.title3)
                    .fontWeight(.semibold)
                    .fixedSize(horizontal: false, vertical: true)
                
                Text(description)
                    .font(.body)
                    .foregroundColor(.secondary)
                    .opacity(0.7)
                    .fixedSize(horizontal: false, vertical: true)
                    .lineLimit(nil)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
    }
}

//#Preview("Instruction View") {
//    @Previewable @State var isVisible: Bool = true
//    
//    VStack {
//        GroupBox {
//            Toggle("Visible", isOn: $isVisible.animation())
//        }
//        Spacer()
//        
//        if isVisible {
//            AttackCancerInstructionsView()
//                .environment(AppModel())
//                .environment(ADCDataModel())
//                .transition(Appear())
//        }
//        Spacer()
//    }
//    .padding()
//    
//}

```

File: Views/IntroView.swift
```swift
import SwiftUI
import RealityKit
import RealityKitContent

/// A RealityView that creates an immersive lab environment with spatial audio and IBL lighting
struct IntroView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(ADCDataModel.self) var dataModel
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.openWindow) private var openWindow
    
    @State private var introTintIntensity: Double = 0.2 {
        didSet {
            print("introTintIntensity changed to: \(introTintIntensity)")
            // Consider adding a breakpoint here to inspect the call stack
        }
    }
    
    @State private var showNavToggle: Bool = false
    
    var surroundingsEffect: SurroundingsEffect? {
        let tintColor = Color(red: introTintIntensity, green: introTintIntensity, blue: introTintIntensity)
        return SurroundingsEffect.colorMultiply(tintColor)
    }

    @State var handTrackedEntity: Entity = {
        let handAnchor = AnchorEntity(.hand(.left, location: .aboveHand))
        return handAnchor
    }()
    
    var body: some View {
        @Bindable var appModel = appModel
        
        RealityView { content, attachments in
            print("\n=== Setting up IntroView ===")
            print("\n=== hasBuiltSDC = \(appModel.hasBuiltADC) ===")
            
            // Create fresh root entity
            let root = appModel.introState.setupRoot()
            content.add(root)
            print("✅ Added root to content")
            
             if showNavToggle {
                 content.add(handTrackedEntity)
                 if let attachmentEntity = attachments.entity(for: "navToggle") {
                     attachmentEntity.components[BillboardComponent.self] = .init()
                     handTrackedEntity.addChild(attachmentEntity)
                 }
             }
            
            // Handle environment and attachments in Task
            Task { @MainActor in
                // Load environment first
                print("📱 IntroView: Starting environment setup")
                await appModel.introState.setupEnvironment(in: root)
                
                appModel.introState.environmentLoaded = true
                print("✅ Environment setup complete")

                // set up the lab attachments
                // Now that environment is loaded, set up attachments
                if let adcButton = attachments.entity(for: "ADCBuilderViewerButton"),
                   let attackButton = attachments.entity(for: "AttackCancerViewerButton") {
                    
                    // Find attachment points and set up buttons
                    if let builderTarget = root.findEntity(named: "ADCBuilderAttachment") {
                        print("🎯 Found ADCBuilderAttachment target")
                        builderTarget.addChild(adcButton)
                        adcButton.components.set(BillboardComponent())
                        appModel.labState.adcBuilderViewerButtonEntity = adcButton
                    } else {
                        print("❌ ADCBuilderAttachment target not found")
                    }
                    
                    if let attackTarget = root.findEntity(named: "AttackCancerAttachment") {
                        print("🎯 Found AttackCancerAttachment target")
                        attackTarget.addChild(attackButton)
                        attackButton.components.set(BillboardComponent())
                        appModel.labState.attackCancerViewerButtonEntity = attackButton
                    } else {
                        print("❌ AttackCancerAttachment target not found")
                    }
                }
            }
        } attachments: {
            if showNavToggle {
                Attachment(id: "navToggle") {
                    NavToggleView()
                }
            }
            Attachment(id: "ADCBuilderViewerButton") {
                ADCBuilderViewerButton()
            }
            Attachment(id: "AttackCancerViewerButton") {
                AttackCancerViewerButton()
            }
            Attachment(id: "AttachmentContent") {
                HStack(spacing: 12) {
                    Button(action: {
                        appModel.isNavWindowOpen.toggle()
                        openWindow(id: AppModel.navWindowId)
                    }, label: {
                        Image(systemName: "arrow.2.circlepath.circle")
                    })

                }
                .opacity(appModel.isNavWindowOpen ? 0 : 1)
            }
        }
        .installGestures()
        .preferredSurroundingsEffect(surroundingsEffect)
        .onChange(of: appModel.labState.isLibraryOpen) { _, isOpen in
            if isOpen {
                print(">>> Library window opened 🚪")
                openWindow(id: AppModel.libraryWindowId)
                appModel.updateLibraryWindowState(isOpen: true)
            } else {
                print(">>> Library window closed")
                dismissWindow(id: AppModel.libraryWindowId)
                appModel.updateLibraryWindowState(isOpen: false)
            }
        }
        .gesture(
            SpatialTapGesture()
                .targetedToAnyEntity()
                .onEnded { value in
                   appModel.labState.handleTap(on: value.entity)
                }
        )
        // Keep tracking tasks separate
        .task {
            await appModel.trackingManager.processWorldTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.processHandTrackingUpdates()
        }
        .task {
            await appModel.trackingManager.monitorTrackingEvents()
        }
        // Add head position update handler
        .onChange(of: appModel.introState.shouldUpdateHeadPosition) { _, shouldUpdate in
            if shouldUpdate {
                Logger.info("""
                
                🎯 Head Position Update Triggered
                ├─ shouldUpdate: \(shouldUpdate)
                ├─ isReadyForHeadTracking: \(appModel.introState.isReadyForHeadTracking)
                ├─ isPositioningInProgress: \(appModel.introState.isPositioningInProgress)
                ├─ Current Phase: \(appModel.currentPhase)
                ├─ Tracking State: \(appModel.trackingManager.worldTrackingProvider.state)
                └─ Has Device Anchor: \(appModel.trackingManager.worldTrackingProvider.queryDeviceAnchor(atTimestamp: CACurrentMediaTime()) != nil)
                """)
            }
            
            if shouldUpdate && appModel.introState.isReadyForHeadTracking && !appModel.introState.isPositioningInProgress {
                if let root = appModel.introState.introRootEntity {
                    // Ensure we're on MainActor
                    Task { @MainActor in
                        Logger.info("""
                        
                        🎯 Starting Head Position Update
                        ├─ Current Position: \(root.position(relativeTo: nil))
                        ├─ Tracking State: \(appModel.trackingManager.worldTrackingProvider.state)
                        ├─ isPositioningInProgress: \(appModel.introState.isPositioningInProgress)
                        └─ isPositioningComplete: \(appModel.introState.isPositioningComplete)
                        """)
                        
                        // Set positioning state first
                        appModel.introState.isPositioningInProgress = true
                        
                        // Update positioning component
                        if var positioningComponent = root.components[PositioningComponent.self] {
                            positioningComponent.needsPositioning = true
                            positioningComponent.shouldAnimate = true
                            positioningComponent.animationDuration = 0.5
                            root.components[PositioningComponent.self] = positioningComponent
                            
                            // Wait for animation plus a small buffer
                            try? await Task.sleep(for: .seconds(0.6))
                            
                            Logger.info("""
                            
                            ✨ Head Position Update Complete
                            ├─ Final Position: \(root.position(relativeTo: nil))
                            ├─ Tracking State: \(appModel.trackingManager.worldTrackingProvider.state)
                            ├─ isPositioningInProgress: \(appModel.introState.isPositioningInProgress)
                            └─ isPositioningComplete: \(appModel.introState.isPositioningComplete)
                            """)
                            
                            // Reset states
                            appModel.introState.shouldUpdateHeadPosition = false
                            appModel.introState.isPositioningComplete = true
                            appModel.introState.isPositioningInProgress = false
                        }
                    }
                }
            }
        }
        // Add positioning completion handler
        .onChange(of: appModel.introState.isPositioningComplete) { _, complete in
            if complete {
                Task { @MainActor in
                    if let root = appModel.introState.introRootEntity,
                       let environment = appModel.introState.introEnvironment {
                        Logger.info("""
                        
                        ✨ Positioning Complete
                        ├─ Phase: \(appModel.currentPhase)
                        ├─ ImmersiveSpaceState: \(appModel.immersiveSpaceState)
                        ├─ Root Entity: \(root.name)
                        └─ Environment Ready: \(environment.name)
                        """)
                        
                        // Now add environment to scene
                        root.addChild(environment)

                        // Get portal and set up attachments
                        if let portal = appModel.introState.getPortal() {
                            print("✅ Found portal for attachments")
                            
                            // Set up attachments on portal
                            appModel.introState.setupAttachments(
                                in: root,
                                for: portal
                            )
                        }
                        
                        // Small delay to ensure everything is settled
                        try? await Task.sleep(for: .seconds(0.3))
                        
                        // Set setup complete before starting animation
                        appModel.introState.isSetupComplete = true
                        
                        // Reset positioning flag before starting animation
                        appModel.introState.isPositioningInProgress = false
                        
                        // Start animation sequence
                        await appModel.introState.runAnimationSequence()
                    }
                }
            }
        }
        // start the lab environment when readyToStartLab becomes true
        .onChange(of: appModel.readyToStartLab) { _, newValue in
            if newValue {
                Logger.info("""
                
                🔄 Starting Lab Setup in IntroView
                ├─ hasBuiltADC: \(appModel.hasBuiltADC)
                ├─ Current Phase: \(appModel.currentPhase)
                └─ readyToStartLab: \(newValue)
                """)
                
                if let root = appModel.introState.introRootEntity {
                    Task { @MainActor in
                        do {
                            try await appModel.labState.setupInitialLabEnvironment(in: root, isIntro: true)
                            // try await appModel.labState.setupLabEnvironment(in: root, isIntro: true)
                        } catch {
                            print("❌ Error setting up lab environment: \(error)")
                        }
                    }
                } else {
                    print("❌ Intro root entity not available for lab setup")
                }
            }
        }
    }
}

```

File: Views/LibraryView.swift
```swift
//
//  LibraryView.swift
//  SpawnAndAttrack
//
//  Created by Dale Carman on 12/13/24.
//

import SwiftUI
import WebKit

struct LibraryView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(\.pushWindow) private var pushWindow
    @Environment(\.openWindow) private var openWindow
    @Environment(\.dismissWindow) private var dismissWindow
    
    var body: some View {
        if appModel.isLibraryWindowOpen {
            // Screen()
           WebView(url: URL(string: "https://cancer.pfizer.com/")!)
        }
            
    }

    
    struct WebView: UIViewRepresentable {
        let url: URL
        
        func makeUIView(context: Context) -> WKWebView {
            WKWebView()
        }
        
        func updateUIView(_ uiView: WKWebView, context: Context) {
            uiView.load(URLRequest(url: url))
        }
    }
}
    //#Preview {
    //    LibraryView()
    //}


```

File: Views/LibraryWindow.swift
```swift
import SwiftUI

struct LibraryWindow: View {
    var body: some View {
        LibraryView()
            .frame(width: 800, height: 300)
    }
} 

```

File: Views/LoadingView.swift
```swift
import SwiftUI

struct LoadingView: View {
    @Environment(AppModel.self) private var appModel
    @Environment(\.dismissWindow) private var dismissWindow
    @State private var showTitle = false
    @State private var viewOpacity: Double = 1.0
    @Namespace private var logoNamespace
    
    var body: some View {
        ZStack {
            if case .loading = appModel.assetLoadingManager.loadingState {
                LoadingBlock(namespace: logoNamespace)
                    .environment(appModel)
            }
            if case .completed = appModel.assetLoadingManager.loadingState {
                CompletedBlock(namespace: logoNamespace)
                    .environment(appModel)
            }
        }
        .frame(width: 800, height: 600)
        .opacity(viewOpacity)
        .animation(.easeInOut(duration: 0.5), value: appModel.assetLoadingManager.loadingState)
        .onChange(of: appModel.assetLoadingManager.loadingState) { oldState, newState in
            // print("Loading state changed from \(oldState) to \(newState)")
            // print("Loading progress: \(appModel.loadingProgress)")
            withAnimation(.easeInOut(duration: 0.2)) {
                appModel.displayedProgress = appModel.loadingProgress
            }
        }
        .onChange(of: appModel.introState.isSetupComplete) { _, complete in
            if complete {
                withAnimation(.easeOut(duration: 1.0)) {
                    viewOpacity = 0.0
                }
            }
        }
        .onDisappear {
            print("🚨 LoadingView disappeared")
        }
        .onAppear {
            Task { @MainActor in
                try? await Task.sleep(for: .seconds(2))
                withAnimation {
                    showTitle = true
                }
            }
        }
    }
}

private struct LoadingBlock: View {
    @Environment(AppModel.self) private var appModel
    let namespace: Namespace.ID
    
    var body: some View {
        VStack {
            Image("Pfizer_Logo_Color_RGB")
                .resizable()
                .scaledToFit()
                .matchedGeometryEffect(id: "PfizerLogo", in: namespace)
                .frame(width: 400)
                .padding(80)
            
            VStack {
                Text("Loading Assets...")
                    .font(.title)
                    .padding()
                    .transition(.opacity.combined(with: .scale))
                
                // Use displayedProgress here
                ProgressView(value: Double(appModel.displayedProgress))
                    .progressViewStyle(.linear)
                    .padding()
                    .transition(.opacity)
                
                Text("Please wait while we prepare your experience...")
                    .foregroundStyle(.secondary)
                    .padding()
                    .transition(.opacity)
                
                Text("build v50 - 2.20.25")
                    .foregroundStyle(.secondary)
                    .font(.caption)
                    .padding()
                    .transition(.opacity)
            }
        }
    }
}

private struct CompletedBlock: View {
    @Environment(AppModel.self) private var appModel
    let namespace: Namespace.ID
    @State private var showTitle = false
    
    var body: some View {
        VStack {
            Image("Pfizer_Logo_Color_RGB")
                .resizable()
                .scaledToFit()
                .matchedGeometryEffect(id: "PfizerLogo", in: namespace)
                .frame(width: 400)
                .padding(40)
            
            // Add a fixed height container for the title
            ZStack {
                // Invisible placeholder text to maintain consistent layout
                Text("Let's Outdo Cancer")
                    .font(.extraLargeTitle)
                    .opacity(0)
                
                if showTitle {
                    Text("Let's Outdo Cancer")
                        .font(.extraLargeTitle)
                        .transition(WordByWordTransition(
                            totalDuration: 2.0,
                            elementDuration: 0.8,
                            extraBounce: 0.2
                        ))
                }
            }
            .padding()
            
            StartButton()
                .padding(.top, 50)
        }
        .onAppear {
            // Delay the title animation slightly to let the logo transition complete
            Task { @MainActor in
                try? await Task.sleep(for: .seconds(0.3))
                withAnimation {
                    showTitle = true
                }
            }
        }
    }
}

//#Preview(windowStyle: .automatic) {
//    LoadingView()
//        .environment(AppModel())
//}

```

File: PfizerOutdoCancerApp.swift
```swift
//
//  PfizerOutdoCancerApp.swift
//  PfizerOutdoCancer
//
//  Created by Dale Carman on 12/20/24.
//

import SwiftUI
import RealityKitContent
import os

@main
struct PfizerOutdoCancerApp: App {
    // Change from @StateObject to @State
    @State private var appModel = AppModel()
    
    // for ADC view
    @State private var adcDataModel = ADCDataModel()
    
    @Environment(\.openImmersiveSpace) private var openImmersiveSpace
    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
    @Environment(\.openWindow) private var openWindow
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.scenePhase) private var scenePhase
    
    @State private var immersionStyle: ImmersionStyle =
        .progressive(0.0...1.0, initialAmount: 0.5)
    
    var body: some Scene {
        // Now $appModel references will work correctly
        WindowGroup(id: AppModel.mainWindowId) {
            ContentView()
                .environment(appModel)
                .environment(adcDataModel)
                .onChange(of: scenePhase) { _, newPhase in
                    Task {
                        await handleScenePhaseChange(to: newPhase)
                    }
                }
        }
        .defaultSize(width: 800, height: 800)
        .windowStyle(.plain)
        .persistentSystemOverlays(appModel.currentPhase == .loading || appModel.currentPhase == .ready ? .visible : .hidden)
        .windowResizability(.contentSize)
        
        WindowGroup(id: AppModel.libraryWindowId) {
            if appModel.currentPhase == .lab || appModel.currentPhase == .intro {
            LibraryView()
                .environment(appModel)
                .environment(adcDataModel)
                .transition(Appear())
            }
        }
        .defaultSize(CGSize(width: 800, height: 600))

        .persistentSystemOverlays(appModel.isLibraryWindowOpen ? .visible : .hidden)


        WindowGroup(id: AppModel.navWindowId) {
            NavigationView()
                .environment(appModel)
                .environment(adcDataModel)
                .transition(Appear())
        }
        .windowStyle(.plain)
        .windowResizability(.contentSize)
        .defaultWindowPlacement { _, context in
            return WindowPlacement(.utilityPanel)
        }

        WindowGroup(id: AppModel.hopeMeterUtilityWindowId) {
            HopeMeterUtilityView()
                .environment(appModel)
                .environment(adcDataModel)
        }
        .windowStyle(.plain)
        .windowResizability(.contentSize)
        .defaultWindowPlacement { _, context in
            return WindowPlacement(.utilityPanel)
        }


        .onChange(of: appModel.currentPhase) { oldPhase, newPhase in
            if oldPhase == newPhase { return }
            if newPhase != .lab {
                dismissWindow(id: AppModel.libraryWindowId)
            }
        }
        
        
        
        
        
        // MARK: Immersive Views
        Group {

            ImmersiveSpace(id: "IntroSpace") {
                if appModel.currentPhase == .intro || appModel.currentPhase == .ready {
                    IntroView()
//                        .preferredSurroundingsEffect(.ultraDark)
                        .environment(appModel)
                        .environment(adcDataModel)
                        .upperLimbVisibility(.visible)
                        .onAppear {
                            // After 3 seconds, animate immersion to full (100%) over 5 seconds
                            DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                                withAnimation(.easeInOut(duration: 5)) {
                                    immersionStyle = .progressive(0.0...1.0, initialAmount: 1.0)
                                }
                            }
                        }
                        .onAppear {
                            appModel.immersiveSpaceState = .open
                        }
                        .onDisappear {
                            if appModel.immersiveSpaceDismissReason == .manual {
                                // We dismissed it, just update state
                                appModel.immersiveSpaceState = .closed
                            } else {
                                // System dismissed it (Digital Crown), clean up
                                Task {
                                    await cleanupAppState()
                                }
                            }
                            // Reset for next time
                            appModel.immersiveSpaceDismissReason = nil
                        }
                }
                
            }
//            .immersionStyle(selection: $appModel.introStyle, in: .progressive)
//            .immersionStyle(selection: $immersionStyle,
//                                in: .progressive(0.0...1.0, initialAmount: 0.5))
            .immersionStyle(selection: $appModel.introStyle, in: .mixed)
            

            ImmersiveSpace(id: "OutroSpace") {
                if appModel.currentPhase == .outro {
                    OutroView()
                        .environment(appModel)
                        .environment(adcDataModel)
                        .onAppear {
                            appModel.immersiveSpaceState = .open
                        }
                        .onDisappear {
                            if appModel.immersiveSpaceDismissReason == .manual {
                                // We dismissed it, just update state
                                appModel.immersiveSpaceState = .closed
                            } else {
                                // System dismissed it (Digital Crown), clean up
                                print("I am in the outro space in the onDisappear else block and think that I have been dismissed")
                                 Task {
                                     await cleanupAppState()
                                 }
                            }
                            // Reset for next time
                            appModel.immersiveSpaceDismissReason = nil
                        }
                }
                
            }
            .immersionStyle(selection: $appModel.outroStyle, in: .mixed)

            
                ImmersiveSpace(id: "LabSpace") {
                    if appModel.currentPhase == .lab  {
                        LabView()
                            .environment(appModel)
                            .environment(adcDataModel)
                            .onAppear {
                                appModel.immersiveSpaceState = .open
                            }
                            .onDisappear {
                                if appModel.immersiveSpaceDismissReason == .manual {
                                    // We dismissed it, just update state
                                    appModel.immersiveSpaceState = .closed
                                } else {
                                    // System dismissed it (Digital Crown), clean up
                                    Task {
                                        await cleanupAppState()
                                    }
                                }
                                // Reset for next time
                                appModel.immersiveSpaceDismissReason = nil
                            }
                    }
                    
                }
                .immersionStyle(selection: $appModel.labStyle, in: .full)
                .upperLimbVisibility(.visible)
            
            
            ImmersiveSpace(id: "BuildingSpace") {
                if appModel.currentPhase == .building && !appModel.isBuilderInstructionsOpen {
                    ADCOptimizedImmersive()
                        .environment(appModel)
                        .environment(adcDataModel)
                        .onAppear {
                            appModel.immersiveSpaceState = .open
                        }
                        .onDisappear {
                            if appModel.immersiveSpaceDismissReason == .manual {
                                // We dismissed it, just update state
                                appModel.immersiveSpaceState = .closed
                            } else {
                                // System dismissed it (Digital Crown), clean up
                                Task {
                                    // Ensure builder instructions are closed first
                                    // appModel.isBuilderInstructionsOpen = false
                                    await cleanupAppState()
                                }
                            }
                            // Reset for next time
                            appModel.immersiveSpaceDismissReason = nil
                        }
                }
                
            }
            .immersionStyle(selection: $appModel.buildingStyle, in: .mixed)

            ImmersiveSpace(id: "AttackSpace") {
                if appModel.currentPhase == .playing || appModel.currentPhase == .completed {
                    AttackCancerView()
                        .environment(appModel)
                        .environment(adcDataModel)
                        .onAppear {
                            appModel.immersiveSpaceState = .open
                        }
                        .onDisappear {
                            if appModel.immersiveSpaceDismissReason == .manual {
                                // We dismissed it, just update state
                                appModel.immersiveSpaceState = .closed
                            } else {
                                // System dismissed it (Digital Crown), clean up
                                Task {
                                    await cleanupAppState()
                                }
                            }
                            // Reset for next time
                            appModel.immersiveSpaceDismissReason = nil
                        }
                }
                
            }
            .immersionStyle(selection: $appModel.attackStyle, in: .progressive)
            .upperLimbVisibility(.visible)
            
            // MARK: PHASE CHANGE
            // Single onChange handler for phase transitions
            .onChange(of: appModel.currentPhase) { oldPhase, newPhase in
                if oldPhase == newPhase { return }

                Task {
                    if oldPhase.needsImmersiveSpace && !newPhase.shouldKeepPreviousSpace {
                        if appModel.immersiveSpaceState == .open {
                            appModel.immersiveSpaceDismissReason = .manual
                            await dismissImmersiveSpace()
                            os_log(.debug, "🧹 **onChange Function**: Immersive space dismissed successfully.")
                            appModel.immersiveSpaceState = .closed
                        }
                    }

                    await handleWindowsForPhase(newPhase)

                    if newPhase.needsImmersiveSpace && !newPhase.shouldKeepPreviousSpace {
                        if newPhase == .playing || newPhase == .outro {
                            // Add a short delay to allow asset preloading and state updates to settle.
                            try? await Task.sleep(nanoseconds: 150_000_000) // 150ms delay
                            print("Transitioning into \(newPhase); delay elapsed. Proceeding to open immersive space.")
                        }
                        let result = await openImmersiveSpace(id: newPhase.spaceId)
                        print("openImmersiveSpace result for \(newPhase): \(result)")
                    }
                    if newPhase == .building {
                        // Explicitly set the immersive space state to closed so that manual launch works.
                        appModel.immersiveSpaceState = .closed
                    }
                }
            }

        }
        
        
    }

    init() {
        print("🏁 PfizerOutdoCancerApp init starting...")
        
        // Set AppModel before registering the system
        print("📲 Setting AppModel in PositioningSystem...")
        PositioningSystem.setAppModel(appModel)
        
        print("📝 Registering components and systems...")
        /// Register components and systems
        RealityKitContent.AttachmentPoint.registerComponent()
        RealityKitContent.CancerCellComponent.registerComponent()
        RealityKitContent.CancerCellStateComponent.registerComponent()
        RealityKitContent.MovementComponent.registerComponent()
        RealityKitContent.UIAttachmentComponent.registerComponent()
        RealityKitContent.ADCComponent.registerComponent()
        // RealityKitContent.BreathingComponent.registerComponent()
        RealityKitContent.CellPhysicsComponent.registerComponent()
        RealityKitContent.MicroscopeViewerComponent.registerComponent()
    //        RealityKitContent.GestureComponent.registerComponent()
        RealityKitContent.AntigenComponent.registerComponent()
        RealityKitContent.InteractiveDeviceComponent.registerComponent()
        
        // Register UI sync components and system
        HitCountComponent.registerComponent()
        UIStateSyncSystem.registerSystem()

        // Register new CancerCellMovementData component
        CancerCellMovementData.registerComponent()
        CancerCellSpeedBoostSystem.registerSystem()

        /// Register systems
        AttachmentSystem.registerSystem()
        // BreathingSystem.registerSystem()
        CancerCellSystem.registerSystem()
        MovementSystem.registerSystem()
        UIAttachmentSystem.registerSystem()
        ADCMovementSystem.registerSystem()
        UIStabilizerSystem.registerSystem()
        AntigenSystem.registerSystem()
        // SwirlingSystem.registerSystem()
        // TraceComponent.registerComponent()
        // TraceSystem.registerSystem()
        RotationComponent.registerComponent()
        RotationSystem.registerSystem()

        // Add PositioningSystem registration
        print("⚙️ Registering PositioningSystem...")
        PositioningSystem.registerSystem()
        PositioningComponent.registerComponent()
        
        // Add ClosureSystem registration
        ClosureSystem.registerSystem()
        ClosureComponent.registerComponent()
        
        // Add HeadTracking FollowSystem
        FollowSystem.registerSystem()
        FollowComponent.registerComponent()
        
        
        
        // for ADC Builder
        ADCGestureComponent.registerComponent()
        ADCCameraSystem.registerSystem()
        ADCBillboardSystem.registerSystem()
        ADCSimpleBillboardSystem.registerSystem()
        ADCProximitySystem.registerSystem()
        
        print("✅ PfizerOutdoCancerApp init completed")
    }
    
    // Helper function to handle window management
    @MainActor
    private func handleWindowsForPhase(_ phase: AppPhase) async {
        print("🎯 Managing windows for phase: \(phase)")
        print("📊 Before state update - nav window open: \(appModel.isNavWindowOpen)")
        
        // First, update model state
        switch phase {
        case .loading:
            // Make sure loading window is open
            if !appModel.isMainWindowOpen {
                openWindow(id: AppModel.mainWindowId)
                appModel.isMainWindowOpen = true
            }
            
        case .ready:
            if !appModel.isMainWindowOpen {
                openWindow(id: AppModel.mainWindowId)
                appModel.isMainWindowOpen = true
            }
            if appModel.isNavWindowOpen {
                dismissWindow(id: AppModel.navWindowId)
                appModel.isNavWindowOpen = false
            }
            
        case .intro: break
            // Handle other windows
//            if !appModel.isNavWindowOpen {
//                openWindow(id: AppModel.navWindowId)
//                appModel.isNavWindowOpen = true
//            }
        case .outro:
            if appModel.isNavWindowOpen {
                dismissWindow(id: AppModel.navWindowId)
                appModel.isNavWindowOpen = false
            }
        case .playing:
            // Explicitly dismiss nav window first
            if appModel.isNavWindowOpen {
                dismissWindow(id: AppModel.navWindowId)
                appModel.isNavWindowOpen = false
            }
            // No need for default case handling
//            return  // Add explicit return to prevent falling through to default
//            openWindow(id: AppModel.mainWindowId)
            
        case .completed:
            // if !appModel.isNavWindowOpen {
            //     openWindow(id: AppModel.navWindowId)
            //     appModel.isNavWindowOpen = true
            // }
            dismissWindow(id: AppModel.hopeMeterUtilityWindowId)
            appModel.isHopeMeterUtilityWindowOpen = false
//            openWindow(id: AppModel.mainWindowId)
            
        case .lab: break

//            if !appModel.isNavWindowOpen {
//                openWindow(id: AppModel.navWindowId)
//                appModel.isNavWindowOpen = true
//            }
        case .building:
            if appModel.isNavWindowOpen {
                print("closing nav window")
                dismissWindow(id: AppModel.navWindowId)
                appModel.isNavWindowOpen = false
            }
        default:
            if !appModel.isMainWindowOpen {
                openWindow(id: AppModel.mainWindowId)
                appModel.isMainWindowOpen = true
            }
            if appModel.isNavWindowOpen {
                dismissWindow(id: AppModel.navWindowId)
                appModel.isNavWindowOpen = false
            }
        }
        
        // // Show/hide hope meter utility window based on phase
        // if phase == .playing {
        //     openWindow(id: AppModel.hopeMeterUtilityWindowId)
        // } else {
        //     dismissWindow(id: AppModel.hopeMeterUtilityWindowId)
        // }

        
        // Always dismiss the completed window if not in completed phase
//        if phase != .completed {
//            dismissWindow(id: AppModel.gameCompletedWindowId)
//        }
        
        print("📊 Window states after update:")
        print("  Main: \(appModel.isMainWindowOpen)")
        print("  Debug: \(appModel.isNavWindowOpen)")
        print("  Library: \(appModel.isLibraryWindowOpen)")
        print("  Builder: \(appModel.isBuilderWindowOpen)")
        print("  Phases:")
        print("    AppPhase: \(appModel.currentPhase)")
        print("    ScenePhase: \(scenePhase)")
        print("    LoadingPhase: \(appModel.assetLoadingManager.loadingState)")
    }

    // MARK: - App State Management
    private func cleanupAppState() async {
        print("🧹 Cleaning up app state")
        Logger.info("""
        
        === Cleaning Up App State ===
        ├─ Current Phase: \(appModel.currentPhase)
        ├─ Immersive Space: \(appModel.immersiveSpaceState)
        └─ Tracking Active: \(appModel.trackingManager.worldTrackingProvider.state)
        """)
        
        // 1. Stop tracking first to ensure clean provider state
        await appModel.trackingManager.stopTracking()
        
        do {
            // Wait for tracking to fully stop with verification
            try await appModel.trackingManager.waitForCleanup()
            if !appModel.trackingManager.verifyProviderState(expectRunning: false) {
                Logger.error("❌ Tracking cleanup verification failed during app state cleanup")
            }
        } catch {
            Logger.error("❌ Tracking cleanup failed during app state cleanup: \(error)")
        }

        // 2. Close immersive space if open
        if appModel.immersiveSpaceState == .open {
            appModel.immersiveSpaceDismissReason = .manual
            if let activeSpace = appModel.currentImmersiveSpace {
                Logger.debug("""
                
                === Attempting to dismiss Immersive Space ===
                Current Phase: \(appModel.currentPhase)
                Active Space: \(String(describing: activeSpace))
                """)
            }
            
            await dismissImmersiveSpace()
            Logger.debug("=== Finished Dismiss Attempt ===\n")
            appModel.immersiveSpaceState = .closed
        }

        // 3. Wait briefly to ensure cleanup completes
        try? await Task.sleep(for: .milliseconds(100))
        
        // 4. Reset state
        appModel.immersiveSpaceState = .closed
        appModel.immersiveSpaceDismissReason = nil
        
        Logger.info("""
        
        === App State Cleanup Complete ===
        ├─ Immersive Space: \(appModel.immersiveSpaceState)
        └─ Tracking State: \(appModel.trackingManager.worldTrackingProvider.state)
        """)
    }

    // MARK: - Scene Phase Management
    private func handleScenePhaseChange(to newPhase: ScenePhase) async {
        Logger.info("""
        
        === Scene Phase Change ===
        ├─ To: \(newPhase)
        ├─ Current App Phase: \(appModel.currentPhase)
        └─ Tracking State: \(appModel.trackingManager.worldTrackingProvider.state)
        """)
        
        switch newPhase {
        case .background:
            // 1. Stop tracking and cleanup
            await cleanupAppState()
            
            // 2. Clean up game state if needed
            if appModel.currentPhase == .playing {
                await appModel.gameState.tearDownGame()
            }
            
        case .inactive:
            // No additional cleanup needed
            break
            
        case .active:
            // 1. Ensure previous cleanup is complete
            try? await Task.sleep(for: .milliseconds(200))
            
            // 2. Always transition to intro with fresh tracking
            await appModel.transitionToPhase(.loading, adcDataModel: adcDataModel)
            
        @unknown default:
            break
        }
    }
}

```
</file_contents>

