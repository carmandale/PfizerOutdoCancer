Ensuring Smooth ARKit Session Resets in visionOS Immersive Spaces

Transitioning between immersive AR spaces on visionOS requires careful management of ARKit and RealityKit sessions to avoid crashes or tracking issues. Apple’s latest guidance emphasizes properly stopping sessions, not reusing certain tracking providers, and resetting tracking state cleanly. Below we outline best practices and how to integrate them into a TrackingSessionManager for reliable session restarts.

Properly Stopping the ARKit Session and Providers

When leaving an immersive space or ending an AR experience, always stop the ARKit session cleanly before starting a new one. In visionOS, an ARKitSession manages a set of data providers (e.g. a WorldTrackingProvider for device tracking, a SceneReconstructionProvider for meshing). To stop tracking:
	•	Call ARKitSession.stop() on exit: This halts all active providers and stops tracking and camera feed updates ￼. Stopping ensures ARKit isn’t still running in the background when you transition out.
	•	Deinitialize or release the session: ARKit automatically stops sessions when the ARKitSession instance is deallocated ￼. Make sure to drop any strong references to the session (e.g. set it to nil) once stopped. This allows ARKit to clean up resources. (Keep the session alive while AR features are needed; Apple notes you should maintain a reference for the duration of use ￼.)
	•	Cleanup RealityKit content (if needed): If you have RealityKit Entity objects or anchors associated with the old session, consider removing or disabling them upon session stop. This prevents leftover virtual content from persisting into the next session. For example, you might remove all anchor entities from the RealityKit scene or reset their state when the session ends.

Stopping the session at the appropriate time (such as when an immersive view disappears or the app goes inactive) prevents half-running sessions or resource leaks. It also avoids issues like inaccurate scene reconstruction if a session is left running incorrectly in the background ￼. Always stop before starting a new session.

Avoid Reusing Stopped Data Providers

A key change in visionOS ARKit is that you cannot restart a session using providers that were previously stopped – doing so will cause an error or crash. In other words, once you stop an ARKit data provider (like the world tracking or scene mesh provider), you must not reuse those same instances. This is a known issue documented by Apple:
	•	Never re-run a stopped provider: If you attempt to call session.run(...) on an ARKitSession that was stopped (without replacing the providers), ARKit throws an exception. For example, developers observed NSInternalInconsistencyException with the message “It is not possible to re-run a stopped data provider (<ar_world_tracking_provider_t: …>)” when reopening an immersive space ￼. This occurs because the code tried to restart world tracking with a provider that had been stopped. Apple’s engineer confirms that re-running stopped providers is not allowed ￼.
	•	Create new providers for each session: The solution is to instantiate new provider objects every time you start/restart a session ￼. For example, if you had a WorldTrackingProvider and SceneReconstructionProvider in the old session, create brand new instances of them for the new session. Don’t attempt to reuse the old provider instances after stopping. Apple notes that creating new providers is cheap, and it’s required to avoid undefined state ￼.
	•	Use a new ARKitSession if needed: In practice, it’s safest to create an entirely new ARKitSession instance when restarting an immersive experience. Even if you supply new providers to an existing session, developers found that an ARKitSession that has been stopped often cannot be run again ￼. The recommended approach is: on each immersive re-entry, allocate a fresh ARKitSession and fresh provider instances, then run the session. This guarantees you aren’t carrying over any stopped internal state.

By always using new provider instances (and a new session if the previous one was stopped), you avoid the “stopped data provider” crash completely. In short: stop and discard the old session, and build a new session for the new space. This aligns with Apple’s guidance that you must not expect to reuse a provider after it’s been stopped ￼.

Handling Tracking State Transitions Gracefully

Tracking quality can fluctuate during AR sessions (for example, when the user moves quickly, covers the cameras, or the app is interrupted). A robust session manager should monitor and handle these transitions to ensure a smooth experience and decide when a full reset is needed. Best practices include:
	•	Monitor AR tracking state: ARKit provides tracking status updates (e.g. normal, limited, not available). In visionOS, you can observe anchor updates or use the WorldTrackingProvider to query device pose; if these updates stall or if the system indicates lost tracking, be prepared to intervene. For instance, if tracking becomes unrecoverably limited or lost, it may not resume on its own. Apple suggests providing a way for users to restart the session if it can’t relocalize (recover) after an interruption ￼. In iOS ARKit, the typical remedy is calling session.run with reset options to start fresh; on visionOS, that translates to restarting the ARKitSession with new providers (see below).
	•	Wait for stable tracking on start: When you start a new session, ARKit may take a moment to gather sufficient environment data and achieve full Normal tracking. During this initialization period, tracking state might be Limited (e.g. “initializing”). Your TrackingSessionManager can handle this by briefly delaying certain actions until tracking is stable. For example, you might hold off on placing user content or inform the user to wait a moment. (In iOS, Apple often uses a coaching overlay or messages until tracking quality improves; on visionOS you may not need an overlay, but still ensure the session is ready before critical operations.)
	•	Handle interruptions (if applicable): If visionOS triggers an interruption (say the user temporarily leaves the immersive space or another app takes over the camera), ARKitSession may stop or pause. On an interruption end, you could attempt to continue the session, but if the tracking state doesn’t recover (e.g. the environment changed), be ready to reset. Apple’s documentation for ARKit on iOS recommends calling a restart (with resetTracking) if the world map can’t be relocalized ￼. For visionOS, since reusing the session isn’t allowed once fully stopped, you would initialize a new session if needed when returning from a long interruption. In short, treat a major tracking loss or app deactivation as a cue to reset the AR experience to avoid prolonged poor tracking or errors.

By proactively managing tracking state, you prevent failures like the app getting stuck trying to track an environment it can’t recognize. If the session is failing (no anchors updating, or ARKit throws a didFailWithError), the manager should shut down the session and start a new one rather than letting the app continue in a bad state. Providing a clean restart path (even exposing a “Reset AR” option to the user if appropriate) is a good practice for any AR experience that might lose tracking ￼.

Clearing and Reinitializing Tracking Resources

A “clean” session reset means clearing out old tracking data and reinitializing fresh state. In visionOS, some AR tracking data may persist between sessions (by design, the system retains knowledge of the environment), but your app should clear what it can and be prepared for fresh anchors. Here are recommendations:
	•	Remove old anchors and entities: If your previous session added AR anchors (e.g. plane anchors, mesh anchors, or tracked objects) or placed RealityKit entities in the scene, remove them when resetting. For example, in ARKit on iOS one would call session.run(configuration, options: [.removeExistingAnchors]) to clear anchors and start fresh ￼. On visionOS, since you will be creating a new session, you should manually drop references to any old anchors stored in your app and let the old session deinit. Ensure your RealityKit scene is cleared of old anchor entities so they don’t carry over. This prevents confusion between old and new tracking results.
	•	Reset tracking state: On iOS you could also use the .resetTracking run option to zero-out the world coordinate origin ￼. On visionOS, Apple has removed the explicit “resetTracking” functionality – “There is no way for you to reset tracking on visionOS” ￼. Instead, starting a brand new session with new providers implicitly gives you a fresh tracking context. ARKit will establish a new world coordinate space for the new session. Essentially, a new WorldTrackingProvider begins tracking from scratch (using the device’s current pose as a reference).
	•	Accept persistent scene understanding (or ignore it): Even though you can’t manually force the system to forget everything about the environment (no manual reset), ARKit will decide what scene understanding data to provide to your app when you start a new provider ￼. This means some anchors from the previous run might reappear if they are still relevant (for example, previously detected walls or meshes that are still in view). If your goal is a completely fresh scan, you might find ARKit is reusing some knowledge. Apple’s advice is that if you “do not care about some of these anchors you can ignore them” ￼ – i.e. filter them out in your app logic. In a TrackingSessionManager, you could, for instance, maintain an ID list of old environment anchors and skip them when the new session sends anchor updates for those. This way, you effectively treat the session as new from the app’s perspective, even if the system has cached data.
	•	Reinitialize needed resources: If your app uses custom tracking resources (like ARReferenceImages, AR objects, or other configuration data), load or configure them anew for the new session. For example, if you were using an ObjectTrackingProvider or image tracking, provide a fresh set of reference objects/images to the new session rather than trying to carry them over in some global state. Each session should be initialized independently with the configurations it needs.

In summary, clearing a session in visionOS means tearing down the old session (and its anchors/entities) entirely and starting over. While you cannot force the device to forget previously seen geometry, your app can ignore or remove old data so the new session feels clean. Always start with a new ARKitSession and brand new providers – this inherently gives a fresh tracking instance to work with ￼ ￼.

Implementing a Robust TrackingSessionManager

To tie these best practices together, integrate them into a centralized TrackingSessionManager that controls the AR session lifecycle. This manager can ensure each transition between immersive spaces is handled consistently. Key recommendations for the manager design:
	•	Encapsulate session lifecycle: Give the manager methods like startSession() and stopSession() (and perhaps restartSession() for convenience). startSession() should create the needed providers and a new ARKitSession instance every time, then call run() on it. For example, when an immersive space is entered, TrackingSessionManager.startSession() would do something like:

func startSession() async throws {
    // Clean up any old session if present
    if let session = currentSession {
        try await stopSession() 
    }
    // Create new ARKitSession and providers
    let session = ARKitSession()
    let worldProvider = WorldTrackingProvider() 
    let meshProvider = SceneReconstructionProvider(.mesh)
    // (Add other providers as needed, e.g. hand tracking, plane detection, etc.)
    try await session.run([worldProvider, meshProvider])  // start the session
    currentSession = session
}

This ensures a fresh session with new providers is always used. The call to stopSession() (shown above) will handle disposing of any existing session first.

	•	Implement stopSession() to clean up: In stopSession(), call currentSession.stop() to halt tracking ￼, remove any anchors or entities from your app’s AR scene, and nil out the session reference. For instance:

func stopSession() async throws {
    guard let session = currentSession else { return }
    try await session.stop()   // Stop all providers (this might be async)
    // Clear anchors/entities from RealityKit scene if applicable
    sceneanchors.removeAll()   // your own data structures
    currentSession = nil       // deinit session
}

By clearing anchors and setting currentSession to nil, you let ARKit fully reset. (Remember, deinitializing the session also stops it ￼, but calling stop() explicitly is a good practice to catch errors.)

	•	Avoid reuse internally: The manager should never reuse an ARKitSession or provider that has been stopped. For example, do not cache the WorldTrackingProvider across runs. Each call to startSession() in the manager should allocate new provider instances (as shown above) and not attempt to reuse any old WorldTrackingProvider or similar object. This prevents the accidental reuse that leads to exceptions ￼. The manager can store configuration info if needed (like what types of providers to create), but not the providers themselves after stop.
	•	Handle errors and tracking callbacks: It’s wise for the manager to observe the session’s events. You can set an ARKit session delegate or subscribe to publisher updates if available. For example, handle any error thrown during session.run() or session.stop() – if an error indicates a failure to start tracking, you might retry with a new session. Also, if your app logic needs to respond to tracking state (like showing a message when tracking is limited), the manager can translate ARKit’s state into higher-level app events. In a SwiftUI app using RealityView, you might instead rely on async anchor updates from providers. The manager can monitor if anchors are coming through and, if not (or if certain anchors like DeviceAnchor query fails), decide to reset the session.
	•	Main-thread execution: Ensure that starting/stopping the session and managing RealityKit content happens on the main thread (main actor). ARKitSession’s docs imply it should be used from the main thread (the VisionOS examples often use @MainActor on ARKitSession usage). Your TrackingSessionManager methods should likely be marked with @MainActor or otherwise dispatch to the main queue, since creating ARKit providers and RealityKit entities interfaces with UI-related frameworks.
	•	Separation of concerns: The manager should focus on the tracking session. If your app has multiple immersive “spaces” with different content, you can still use one manager to handle the AR session resets while the higher-level app logic handles loading/unloading the content for each space. For instance, when transitioning spaces, the app can instruct the manager to restart the session (to get a fresh AR environment) and then populate the new space’s content. Because the manager ensures the old session is fully torn down, you won’t carry over anchors or tracking issues into the new experience.

By following these patterns, your TrackingSessionManager will enforce a clean restart every time: it stops the old session properly, throws away any stale state, and boots up a fresh ARKitSession with new providers for the next immersive scene. This approach aligns with Apple’s best practices and known requirements for visionOS. It avoids the common pitfalls (like attempting to reuse stopped sessions) that cause crashes ￼, and it maintains robust tracking by resetting when needed.

Conclusion

In summary, to ensure smooth transitions between immersive AR spaces on visionOS:
	•	Always stop the AR session when leaving a space (using ARKitSession.stop() and cleaning up providers).
	•	Never reuse providers or sessions that have been stopped – instantiate new ones for each session run ￼.
	•	Monitor tracking state and be prepared to restart if tracking fails or an interruption occurs, rather than persisting in a faulty state ￼.
	•	Clear out old anchors/data from your app and reinitialize needed resources so each session starts fresh (even though the system may carry some environmental knowledge) ￼.
	•	Implement a session manager to coordinate all of the above, making session resets a controlled and predictable operation.

By integrating these best practices into a TrackingSessionManager, you’ll maintain a clean AR session lifecycle. Users will be able to transition between AR experiences without encountering crashes, and tracking will resume in each new immersive space as if it’s a brand-new session – which is exactly how visionOS expects apps to handle ARKit sessions ￼. The result is a more stable and seamless AR experience across multiple immersive contexts.

Sources:
	•	Apple Developer Forums – “Restarting a stopped ARKitSession in visionOS causes app to crash” (Apple Staff response) ￼ ￼
	•	Reddit (r/visionosdev) – Discussion of immersive space re-entry error and solution ￼ ￼
	•	Apple Developer Documentation – ARKitSession stop() and session lifecycle notes ￼ ￼
	•	Stack Overflow – ARKit session reset practices on iOS (for conceptual comparison) ￼
	•	Apple WWDC/Documentation – Guidance on handling AR session interruptions and relocalization ￼

Step-by-Step Plan to Reset ARKit Tracking Sessions in VisionOS

To reset ARKit tracking in a VisionOS app reliably, follow these steps. This ensures each AR session restarts cleanly and aligns with Apple’s VisionOS/RealityKit best practices.

1. Ensure Full Cleanup on Stop
	•	Stop and Dispose of the ARKit Session: Call ARKitSession.stop() to halt all active data providers (e.g. world tracking, hand tracking) and end the session ￼ ￼. This stops ARKit updates and frees associated resources. After stopping, release or destroy the ARKitSession instance (set it to nil or let it go out of scope) to remove any residual state.
	•	Remove Anchors and Entities: Before starting a new session, clear out all existing AR anchors and RealityKit entities tied to the old session. In iOS ARKit, resetting tracking automatically removes existing anchors ￼; in VisionOS you should do this cleanup manually. For example, remove all AnchorEntity objects from your scene. This prevents leftover anchors or virtual content from interfering with the new session.
	•	Clear Old Tracking Providers: Ensure no references to old providers remain. If you previously used a WorldTrackingProvider, HandTrackingProvider, or others, drop those instances. Do not attempt to reuse a provider that was stopped – Apple explicitly warns that once a data provider is stopped, it cannot be run again ￼. Instead, discard it so there are no lingering objects from the old session that might cause conflicts.

2. Fresh Initialization for Each Session
	•	Create a New ARKitSession: Treat each tracking session start as a fresh launch. Initialize a new ARKitSession object instead of reusing the old one. This ensures you begin with a clean slate (no cached state from the previous session).
	•	Instantiate New Data Providers: For each restart, make new instances of your tracking providers (e.g. a new WorldTrackingProvider for world tracking, a new HandTrackingProvider for hand tracking, etc.). Re-using the old provider instances will lead to errors (“It is not possible to re-run a stopped data provider” ￼) because their internal state is invalid after stop. Apple’s engineers note that you must create new provider objects once the old ones have been stopped ￼. The cost of creating providers is low, so it’s expected and safe to do this every time ￼.
	•	Avoid Stale Data Usage: By using new session and provider objects, you ensure the tracking system doesn’t rely on any stale information. The new WorldTrackingProvider will start fresh, and ARKit will decide what scene understanding data your app should get in the new session. (There is no direct “reset tracking” API in visionOS; starting a new provider is the way to reset the feed of AR data ￼.) This way, your session restarts with a clean state, and only current, valid tracking data will be used.

3. Monitor and Confirm Tracking State Transitions
	•	Verify Session Stops and Starts Properly: Implement checks or logging around session state changes. For example, after calling session.stop(), confirm that no further anchor updates or tracking data are coming in from the old providers. When starting the new session (try await session.run([...])), verify that data begins flowing from the new providers (e.g. your anchor update streams emit initial anchors). This ensures the transition from stopped -> running is successful.
	•	Handle Errors on Restart: Wrap the session.run() call in a do/catch block to catch any exceptions thrown during startup ￼. If ARKit fails to start the session (for instance, due to a configuration issue or a misuse of a stopped provider), log or display the error and attempt recovery. A common failure to handle is trying to reuse a stopped provider, which triggers an error at runtime (“It is not possible to re-run a stopped data provider” ￼). By creating new providers (as above) you avoid this, but you should still catch errors and respond (perhaps by re-initializing or alerting the user) if run() fails.
	•	Confirm Tracking Active: Once restarted, check the tracking status if available. In iOS ARKit you would check ARCamera.trackingState; in visionOS, you can infer tracking is active if you start receiving anchor updates from the WorldTrackingProvider or joint updates from the HandTrackingProvider. You might implement a short timeout: if after a couple of seconds no data comes in, consider that a failed restart and handle accordingly. This kind of monitoring helps ensure the session didn’t silently fail to resume.

4. Optimize the Restart Timing
	•	Stop Then Start (No Overlap): Always stop the previous session completely before starting a new one. Never try to run two ARKit sessions or sets of providers concurrently. Call session.stop() and let it finish before invoking a new session.run(). Because ARKitSession.run() is an async call, make sure any prior run() call has returned and its providers stopped before beginning another.
	•	Introduce a Brief Delay: It can help to insert a small delay between stopping a session and starting the next one. This gives the system a moment to finalize teardown of the old session’s resources. For example, after stopping, dispatch a short 0.1–0.5 second delay (or at least await the next run loop) before creating the new session and providers. This precaution avoids any race conditions where the old session might still be cleaning up when the new session begins. In practice, this delay ensures ARKit isn’t doing two things at once under the hood.
	•	Avoid Rapid Toggle Loops: Design your session restart logic so it’s not starting and stopping in quick succession unintentionally. If a user rapidly opens and closes an AR view, for instance, you may want to debounce the restart. Ensuring a clean separation in time between sessions will make the tracking more stable and prevent concurrency issues.

5. Prevent Stuck States and Edge Cases
	•	Ensure Proper Environment for Tracking: Be aware of VisionOS system conditions that can cause providers to appear “stuck.” Vision Pro continuously runs world tracking and scene understanding at the system level ￼, but your app will only receive ARKit data when certain conditions are met. Notably, your app must be in an immersive space (fullscreen AR mode) to get AR anchors and updates – ARKitSession won’t provide anchors if your app is just in a window or if another app is active ￼. Always call openImmersiveSpace (or use an ImmersiveView) before starting the ARKit session, otherwise the providers may remain paused waiting for the right context ￼. Additionally, ensure the user has granted all required permissions. VisionOS ARKit will not deliver data for providers that lack authorization (for example, camera access for world tracking); if you attempt to run a provider without permission, the session will fail to start ￼. By checking that the app is in the proper state (immersive mode, permissions granted), you resolve many cases where tracking providers would otherwise stay in a paused or inactive state unexpectedly.
	•	Implement Fallback Retries: Even with all the above, handle the rare case where the tracking session still doesn’t resume correctly (e.g. the session starts but no anchors ever appear, or a provider stays in a halted state). Implement a fallback mechanism to retry the initialization. For example, if no anchor data is received within a certain time after starting, you might stop the session and attempt one more restart after a short delay. Ensure you create fresh provider instances for the retry as well. If the session continuously fails, gracefully inform the user (you might suggest closing and reopening the app or check for system updates, in case it’s an OS-level issue). These defensive measures make your app robust against edge cases where ARKit might otherwise get stuck. In practice, such issues are rare if you follow Apple’s guidelines, but having a retry or reset pathway is good hygiene.

By following this plan — cleaning up fully on stop, re-initializing new sessions/providers, validating state, timing the restarts, and guarding against edge cases — you can effectively “reset” ARKit tracking in a VisionOS app. This approach aligns with Apple’s recommended usage (since VisionOS doesn’t support an explicit tracking reset call) and avoids conflict with the system’s own spatial tracking management ￼. Each new session will start fresh without carrying over old tracking data, providing a reliable AR experience to the user.